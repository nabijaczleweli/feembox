<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><feed xmlns='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd="http://schemas.google.com/g/2005" xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-6264947694886887540</id><updated>2023-08-07T04:27:11.198-07:00</updated><category term="electronics"/><category term="reverse-engineering"/><category term="chips"/><category term="arc"/><category term="8086"/><category term="power supply"/><category term="random"/><category term="teardown"/><category term="arduino"/><category term="alto"/><category term="ibm1401"/><category term="analog"/><category term="apple"/><category term="intel"/><category term="ir"/><category term="6502"/><category term="microcode"/><category term="8085"/><category term="bitcoin"/><category term="Apollo"/><category term="space"/><category term="ibm"/><category term="math"/><category term="arm"/><category term="snark"/><category term="Z-80"/><category term="beaglebone"/><category term="dx7"/><category term="oscilloscope"/><category term="synth"/><category term="calculator"/><category term="sheevaplug"/><category term="8008"/><category term="8087"/><category term="fractals"/><category term="photo"/><category term="theory"/><category term="fpga"/><category term="genome"/><category term="globus"/><category term="java"/><category term="javascript"/><category term="css"/><category term="html5"/><category term="ipv6"/><category term="spanish"/><category term="c#"/><category term="cadc"/><category term="f#"/><category term="haskell"/><category term="unicode"/><title type='text'>Ken Shirriff&#39;s blog</title><subtitle type='html'>Computer history, restoring vintage computers, IC reverse engineering, and whatever</subtitle><link rel='http://schemas.google.com/g/2005#feed' type='application/atom+xml' href='http://www.righto.com/feeds/posts/default'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default'/><link rel='alternate' type='text/html' href='http://www.righto.com/'/><link rel='hub' href='http://pubsubhubbub.appspot.com/'/><link rel='next' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default?start-index=26&amp;max-results=25'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><generator version='7.00' uri='http://www.blogger.com'>Blogger</generator><openSearch:totalResults>332</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-2195435311934656338</id><published>2023-08-05T09:39:00.000-07:00</published><updated>2023-08-05T09:39:41.415-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="chips"/><category scheme="http://www.blogger.com/atom/ns#" term="intel"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>A close look at the 8086 processor&#39;s bus hold circuitry</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;

&lt;p&gt;The Intel 8086 microprocessor (1978) revolutionized computing by founding the x86 architecture that continues to this day.
One of the lesser-known features of the 8086 is the &quot;hold&quot; functionality, which
allows an external device to temporarily take control of the system&#39;s bus.
This feature was most important for supporting the 8087 math coprocessor chip, which was an option on the IBM PC;
the 8087 used the bus hold so it could interact with the system without conflicting with the 8086 processor.&lt;/p&gt;
&lt;p&gt;This blog post explains in detail how the bus hold feature is implemented in the processor&#39;s logic.
(Be warned that this post is a detailed look at a somewhat obscure feature.)
I&#39;ve also found some apparently undocumented characteristics of the 8086&#39;s hold acknowledge circuitry, designed
to make signal transition faster on the shared control lines.&lt;/p&gt;
&lt;p&gt;The die photo below shows the main functional blocks of the 8086 processor.
In this image, the metal layer on top of the chip is visible, while the silicon and polysilicon underneath are obscured.
The 8086 is partitioned into a Bus Interface Unit (upper) that handles bus traffic, and an Execution Unit (lower) that
executes instructions.
The two units operate mostly independently, which will turn out to be important. The Bus Interface Unit handles read and write operations as requested
by the Execution Unit.
The Bus Interface Unit also prefetches instructions that the Execution Unit uses when it needs them.
The hold control circuitry is highlighted in the upper right; it takes a
nontrivial amount of space on the chip.
The square pads around the edge of the die are connected by tiny bond wires to the chip&#39;s 40 external pins.
I&#39;ve labeled the &lt;code&gt;MN/MX&lt;/code&gt;, &lt;code&gt;HOLD&lt;/code&gt;, and &lt;code&gt;HLDA&lt;/code&gt; pads; these are the relevant signals for this post.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-hold/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under the microscope, with the main functional blocks and relevant pins labeled. Click this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;670&quot; src=&quot;https://static.righto.com/images/8086-hold/die-labeled-w700.jpg&quot; title=&quot;The 8086 die under the microscope, with the main functional blocks and relevant pins labeled. Click this image (or any other) for a larger version.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under the microscope, with the main functional blocks and relevant pins labeled. Click this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;How bus hold works&lt;/h2&gt;
&lt;p&gt;In an 8086 system, the processor communicates with memory and I/O devices over a bus consisting of address and data lines along with
various control signals.
For high-speed data transfer, it is useful for an I/O device to send data directly to memory, bypassing the processor; this is called DMA (Direct Memory Access).
Moreover, a co-processor such as the 8087 floating point unit may need to read data from memory.
The bus hold feature supports these operations: it is a mechanism for the 8086 to give up control of the bus, letting another
device use the bus to communicate with memory.
Specifically, an external device requests a bus hold and the 8086 stops putting electrical signals on the bus and acknowledges
the bus hold.
The other device can now use the bus. When the other device is done, it signals the 8086, which then resumes its regular bus
activity.&lt;/p&gt;
&lt;p&gt;Most things in the 8086 are more complicated than you might expect, and the bus hold feature is no exception, largely
due to the 8086&#39;s minimum and maximum modes.
The 8086 can be designed into a system in one of two ways&amp;mdash;minimum mode and maximum mode&amp;mdash;that redefine the meanings of the 8086&#39;s external pins.
Minimum mode is designed for simple systems and gives the control pins straightforward meanings such as
indicating a read versus a write.
Minimum mode provides bus signals that were similar to the earlier 8080 microprocessor, making migration to the 8086 easier.
On the other hand, maximum mode is designed for sophisticated, multiprocessor systems and encodes the control signals to provide
richer system information.&lt;/p&gt;
&lt;p&gt;In more detail, minimum mode is selected if the &lt;code&gt;MN/MX&lt;/code&gt; pin is wired high, while maximum mode is selected if the &lt;code&gt;MN/MX&lt;/code&gt; pin
is wired low.
Nine of the chip&#39;s pins have different meanings depending on the mode, but only two pins are relevant to
this discussion.
In minimum mode, pin 31 has the function &lt;code&gt;HOLD&lt;/code&gt;, while pin 30 has the function &lt;code&gt;HLDA&lt;/code&gt; (Hold Acknowlege).
In maximum mode, pin 31 has the function &lt;code&gt;RQ/GT0&#39;&lt;/code&gt;, while pin 30 has the function &lt;code&gt;RQ/GT1&#39;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I&#39;ll start by explaining how a hold operation works in minimum mode.
When an external device wants to use the bus, it pulls the &lt;code&gt;HOLD&lt;/code&gt; pin high.
At the end of the current bus cycle, the 8086 acknowledges the hold request by pulling &lt;code&gt;HLDA&lt;/code&gt; high.
The 8086 also puts its bus output pins into &quot;tri-state&quot; mode, in effect disconnecting them electrically from the bus.
When the external device is done, it pulls &lt;code&gt;HOLD&lt;/code&gt; low and the 8086 regains control of the bus.
Don&#39;t worry about the details of the timing below; the key point is that a device pulls &lt;code&gt;HOLD&lt;/code&gt; high and the
8086 responds by pulling &lt;code&gt;HLDA&lt;/code&gt; high.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-hold/hold.png&quot;&gt;&lt;img alt=&quot;This diagram shows the HOLD/HLDA sequence. From iAPX 86,88 User&#39;s Manual, Figure 4-14.&quot; class=&quot;hilite&quot; height=&quot;154&quot; src=&quot;https://static.righto.com/images/8086-hold/hold-w400.png&quot; title=&quot;This diagram shows the HOLD/HLDA sequence. From iAPX 86,88 User&#39;s Manual, Figure 4-14.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This diagram shows the HOLD/HLDA sequence. From &lt;a href=&quot;http://www.bitsavers.org/components/intel/_dataBooks/1981_iAPX_86_88_Users_Manual.pdf&quot;&gt;iAPX 86,88 User&#39;s Manual&lt;/a&gt;, Figure 4-14.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The 8086&#39;s maximum mode is more complex, allowing two other devices to share the bus by using a priority-based scheme.
Maximum mode uses two bidirectional signals, &lt;code&gt;RQ/GT0&lt;/code&gt; and &lt;code&gt;RQ/GT1&lt;/code&gt;.&lt;span id=&quot;fnref:active-low&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:active-low&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
When a device wants to use the bus, it issues a pulse on one of the signal lines, pulling it low.
The 8086 responds by pulsing the same line.
When the device is done with the bus, it issues a third pulse to inform the 8086.
The &lt;code&gt;RQ/GT0&lt;/code&gt; line has higher priority than &lt;code&gt;RQ/GT1&lt;/code&gt;, so if two devices request the bus at the same time,
the &lt;code&gt;RQ/GT0&lt;/code&gt; device wins and the &lt;code&gt;RQ/GT1&lt;/code&gt; device needs to wait.&lt;span id=&quot;fnref:priority&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:priority&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
Keep in mind that the &lt;code&gt;RQ/GT&lt;/code&gt; lines are bidirectional: the 8086 and the external device both use the same line
for signaling.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-hold/rqgt.png&quot;&gt;&lt;img alt=&quot;This diagram shows the request/grant sequence. From iAPX 86,88 User&#39;s Manual, Figure 4-16.&quot; class=&quot;hilite&quot; height=&quot;124&quot; src=&quot;https://static.righto.com/images/8086-hold/rqgt-w500.png&quot; title=&quot;This diagram shows the request/grant sequence. From iAPX 86,88 User&#39;s Manual, Figure 4-16.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This diagram shows the request/grant sequence. From &lt;a href=&quot;http://www.bitsavers.org/components/intel/_dataBooks/1981_iAPX_86_88_Users_Manual.pdf&quot;&gt;iAPX 86,88 User&#39;s Manual&lt;/a&gt;, Figure 4-16.&lt;/div&gt;&lt;/p&gt;
&lt;!--
One tricky thing is that maximum mode and minimum mode use the same pins, even though the signaling
pattern is completely different.
Pin #34 is called `HOLD` in minimum mode and `RQ/GT0` in maximum mode, while pin #30 is
called `HLDA` in minimum mode and `RQ/GT1` in maximum mode.
--&gt;

&lt;p&gt;The bus hold does not completely stop the 8086.
The hold operation stops the Bus Interface Unit, but the Execution Unit will continue executing instructions
until it needs to perform a read or write, or it empties the prefetch queue.
Specifically, the hold signal blocks the Bus Interface Unit from starting a memory cycle and
blocks an instruction prefetch from starting.&lt;/p&gt;
&lt;h2&gt;Bus sharing and the 8087 coprocessor&lt;/h2&gt;
&lt;p&gt;Probably the most common use of the bus hold feature was to support the Intel 8087 math coprocessor.
The &lt;a href=&quot;https://www.righto.com/2018/08/inside-die-of-intels-8087-coprocessor.html&quot;&gt;8087 coprocessor&lt;/a&gt;
greatly improved the performance of floating-point operations, making them up to 100 times faster.
As well as floating-point arithmetic, the 8087 supported trigonometric operations, logarithms and powers.
The 8087&#39;s architecture became part of later Intel processors, and the 8087&#39;s instructions are still a part of today&#39;s x86 computers.&lt;span id=&quot;fnref:8087&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:8087&quot;&gt;3&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The 8087 had its own registers and didn&#39;t have access to the 8086&#39;s registers.
Instead, the 8087 could transfer values to and from the system&#39;s main memory.
Specifically, the 8087 used the &lt;code&gt;RQ/GT&lt;/code&gt; mechanism (maximum mode) to take control of the bus if 
the 8087 needed to transfer operands to or from memory.&lt;span id=&quot;fnref:8087-rq&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:8087-rq&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
The 8087 could be installed as an option on the original IBM PC, which is why the IBM PC used maximum mode.&lt;/p&gt;
&lt;!--
The idea behind the 8087 coprocessor is that when the 8086 encounters an 8087 instruction (an &quot;Escape&quot; code),
the 8087 runs the instruction instead of the 8086.
However, this is more complicated than you might expect.
Because the 8086 prefetches instructions, the 8087 doesn&#39;t directly know what instruction the 8086 is running.
Instead, the 8087 has to maintain its own copy of of the 8086 prefetch queue and keep track of when the
8086 uses a byte from the queue or flushes the queue.
(The 8086 provides queue status pins with this information.)
--&gt;

&lt;!--
For details, see the [5150 Technical Reference Manual](https://www.minuszerodegrees.net/manuals/IBM_5150_Technical_Reference_6025005_AUG81.pdf) page 2-3.
--&gt;

&lt;h2&gt;The enable flip-flop&lt;/h2&gt;
&lt;p&gt;The circuit is built from six flip-flops. The flip-flops are a bit different from typical D flip-flops, so I&#39;ll discuss
the flip-flop behavior before explaining the circuit.&lt;/p&gt;
&lt;p&gt;A flip-flop can store a single bit, 0 or 1. Flip flops are very important in the 8086 because they hold information (state)
in a stable way, and they synchronize the circuitry with the processor&#39;s clock.
A common type of flip-flop is the D flip-flop, which takes a data input (D) and stores that value.
In an edge-triggered flip-flop, this storage happens
on the edge when the clock changes state from low to high.&lt;span id=&quot;fnref:polarity&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:polarity&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
(Except at this transition, the input can change without affecting the output.)
The output is called &lt;code&gt;Q&lt;/code&gt;, while the inverted output is called Q-bar.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-hold/enable-flip-flop.png&quot;&gt;&lt;img alt=&quot;The symbol for the D flip-flop with enable.&quot; class=&quot;hilite&quot; height=&quot;114&quot; src=&quot;https://static.righto.com/images/8086-hold/enable-flip-flop-w150.png&quot; title=&quot;The symbol for the D flip-flop with enable.&quot; width=&quot;150&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The symbol for the D flip-flop with enable.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Many of the 8086&#39;s flip-flops, including the ones in the hold circuit, have an &quot;enable&quot; input. 
When the enable input is high, the flip-flop records the D input, but when the enable input is low, the flip-flop keeps its previous value.
Thus, the enable input allows the flip-flop to hold its value for more than one clock cycle.
The enable input is very important to the functioning of the hold circuit, as it is used to control when the circuit
moves to the next state.&lt;/p&gt;
&lt;h2&gt;How bus hold is implemented (minimum mode)&lt;/h2&gt;
&lt;p&gt;I&#39;ll start by explaining how the hold circuitry works in minimum mode.
To review, in minimum mode the external device requests a hold through the &lt;code&gt;HOLD&lt;/code&gt; input, keeping the input high for the duration of
the request.
The 8086 responds by pulling the hold acknowledge &lt;code&gt;HLDA&lt;/code&gt; output high for the duration of the hold.&lt;/p&gt;
&lt;p&gt;In minimum mode, only three of the six flip-flops are relevant.
The diagram below is highly simplified to show the essential behavior.
(The full schematic is in the footnotes.&lt;span id=&quot;fnref:schematic&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:schematic&quot;&gt;6&lt;/a&gt;&lt;/span&gt;)
At the left is the &lt;code&gt;HOLD&lt;/code&gt; signal, the request from the external device.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-hold/simplified1.png&quot;&gt;&lt;img alt=&quot;Simplified diagram of the circuitry for minimum mode.&quot; class=&quot;hilite&quot; height=&quot;164&quot; src=&quot;https://static.righto.com/images/8086-hold/simplified1-w600.png&quot; title=&quot;Simplified diagram of the circuitry for minimum mode.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Simplified diagram of the circuitry for minimum mode.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;When a &lt;code&gt;HOLD&lt;/code&gt; request comes in, the first flip-flop is activated, and remains activated for the duration of the request.
The second flip-flop waits if any condition is blocking the hold request: a &lt;code&gt;LOCK&lt;/code&gt; instruction, an unaligned
memory access, or so forth.
When the &lt;code&gt;HOLD&lt;/code&gt; can proceed, the second flip-flop is enabled and it latches the request.
The second flip-flop controls the internal hold signal, causing the 8086 to stop further bus activity.
The third flip-flop is then activated when the current bus cycle (if any) completes; when it latches the request,
the hold is &quot;official&quot;.
The third flip-flop drives the external &lt;code&gt;HLDA&lt;/code&gt; (Hold Acknowledge) pin, indicating that the bus is free.
This signal also clears the bus-enabled latch (elsewhere in the 8086), putting the appropriate pins into floating tri-state mode.
The key point is that the flip-flops control the timing of the internal hold and the external &lt;code&gt;HLDA&lt;/code&gt;, moving to the
next step as appropriate.&lt;/p&gt;
&lt;p&gt;When the external device signals an end to the hold by pulling the &lt;code&gt;HOLD&lt;/code&gt; pin low, the process reverses.
The three flip-flops return to their idle state in sequence.
The second flip-flop clears the internal hold signal, restarting bus activity.
The third flip-flop clears the &lt;code&gt;HLDA&lt;/code&gt; pin.&lt;span id=&quot;fnref:tristate&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:tristate&quot;&gt;7&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;How bus hold is implemented (maximum mode)&lt;/h2&gt;
&lt;p&gt;The implementation of maximum mode is tricky because it uses the same circuitry as minimum mode, but the behavior
is different in several ways.
First, minimum mode and maximum mode operate on opposite polarity: a hold is requested by pulling &lt;code&gt;HOLD&lt;/code&gt; high in minimum mode versus pulling a request line low in maximum mode.
Moreover, in minimum mode, a request on the &lt;code&gt;HOLD&lt;/code&gt; pin triggers a response on the opposite pin (HLDA), while in maximum mode, a request and response are on the same pin.
Finally, using the same pin for the request and grant signals requires the pin to act as both an input and an output, with tricky electrical properties.&lt;/p&gt;
&lt;p&gt;In maximum mode, the top three flip-flops handle the request and grant on line 0, while the bottom three
flip-flops handle line 1.
At a high level, these flip-flops behave roughly the same as in the minimum mode case, 
with the first flip-flop tracking the hold request,
the second flip-flop activated when the hold is &quot;approved&quot;, and the third flip-flop activated when the bus
cycle completes.
An &lt;code&gt;RQ 0&lt;/code&gt; input will generate a &lt;code&gt;GT 0&lt;/code&gt; output, while a &lt;code&gt;RQ 1&lt;/code&gt; input will generate
a &lt;code&gt;GT 1&lt;/code&gt; output.
The diagram below is highly simplified, but illustrates the overall behavior.
Keep in mind that &lt;code&gt;RQ 0&lt;/code&gt;, &lt;code&gt;GT 0&lt;/code&gt;, and &lt;code&gt;HOLD&lt;/code&gt; use the same physical pin, as do &lt;code&gt;RQ 1&lt;/code&gt;, &lt;code&gt;GT 1&lt;/code&gt;, and &lt;code&gt;HLDA&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-hold/simplified2.png&quot;&gt;&lt;img alt=&quot;Simplified diagram of the circuitry for maximum mode.&quot; class=&quot;hilite&quot; height=&quot;407&quot; src=&quot;https://static.righto.com/images/8086-hold/simplified2-w550.png&quot; title=&quot;Simplified diagram of the circuitry for maximum mode.&quot; width=&quot;550&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Simplified diagram of the circuitry for maximum mode.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;In more detail, the first flip-flop converts the pulse request input into a steady signal.
This is accomplished by configuring the first flip-flop is configured with to toggle on when the request pulse
is received and toggle off when the end-of-request pulse is received.&lt;span id=&quot;fnref:feedback&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:feedback&quot;&gt;10&lt;/a&gt;&lt;/span&gt;
The toggle action is implemented by feeding the output pulse back to the input, inverted (A);
since the flip-flop is enabled by the &lt;code&gt;RQ&lt;/code&gt; input, the flip-flop holds its value until an input pulse.
One tricky part is that the acknowledge pulse must not toggle the flip-flop.
This is accomplished by using the output signal to block the toggle.
(To keep the diagram simple, I&#39;ve just noted the &quot;block&quot; action rather than showing the logic.)&lt;/p&gt;
&lt;p&gt;As before, the second flip-flop is blocked until the hold is &quot;authorized&quot; to proceed.
However, the circuitry is more complicated since it must prioritize the two request lines and ensure that only one
hold is granted at a time.
If &lt;code&gt;RQ0&lt;/code&gt;&#39;s first flip-flop is active, it blocks the enable of RQ1&#39;s second flip-flop (B).
Conversely, if &lt;code&gt;RQ1&lt;/code&gt;&#39;s second flip-flop is active, it blocks the enable of RQ0&#39;s second flip-flop (C).
Note the asymmetry, blocking on &lt;code&gt;RQ0&lt;/code&gt;&#39;s &lt;em&gt;first&lt;/em&gt; flip-flop and &lt;code&gt;RQ1&lt;/code&gt;&#39;s &lt;em&gt;second&lt;/em&gt; flip-flop.
This enforces the priority of &lt;code&gt;RQ0&lt;/code&gt;  over &lt;code&gt;RQ1&lt;/code&gt;, since an &lt;code&gt;RQ0&lt;/code&gt; request blocks &lt;code&gt;RQ1&lt;/code&gt; but only an &lt;code&gt;RQ1&lt;/code&gt; &quot;approval&quot; blocks
&lt;code&gt;RQ0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When the second flip-flop is activated in either path, it triggers the internal hold signal (D).&lt;span id=&quot;fnref:hold-out&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:hold-out&quot;&gt;8&lt;/a&gt;&lt;/span&gt;
As before, the hold request is latched into the third flip-flop when any existing memory cycle completes.
When the hold request is granted, a pulse is generated (E) on the corresponding &lt;code&gt;GT&lt;/code&gt; pin.&lt;span id=&quot;fnref:pulse&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:pulse&quot;&gt;9&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The same circuitry is used for minimum mode and maximum mode, although the above diagrams show differences between
the two modes. How does this work?
Essentially, logic gates are used to change the behavior between minimum mode and maximum mode as required.
For the most part, the circuitry works the same, so only a moderate amount of logic is required to make
the same circuitry work for both.
On the schematic, the signal &lt;code&gt;MN&lt;/code&gt; is active during minimum mode, while &lt;code&gt;MX&lt;/code&gt; is active during maximum mode,
and these signals control the behavior.&lt;/p&gt;
&lt;h3&gt;The &quot;hold ok&quot; circuit&lt;/h3&gt;
&lt;p&gt;As usually happens with the 8086, there are a bunch of special cases when different features interact.
One special case is if a bus hold request comes in while the 8086 is acknowledging an interrupt.
In this case, the interrupt takes priority and the bus hold is not processed until the interrupt acknowledgment
is completed.
A second special case is if the bus hold occurs while the 8086 is halted. In this case, the 8086 issues
a second HALT indicator at the end of the bus hold.
Yet another special case is the 8086&#39;s &lt;code&gt;LOCK&lt;/code&gt; prefix, which locks the use of the bus for the following instruction,
so a bus hold request is not honored until the locked instruction has completed.
Finally, the 8086 performs an unaligned word access to memory by breaking it into two 8-bit bus cycles;
these two cycles can&#39;t be interrupted by a bus hold.&lt;/p&gt;
&lt;p&gt;In more detail, the &quot;hold ok&quot; circuit determines at each cycle if a hold could proceed. There are several conditions under which the hold can proceed:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The bus cycle is `T2`, except if an unaligned bus operation is taking place (i.e. a word split into two byte operations), or
&lt;li&gt;A memory cycle is not active and a microcode memory operation is not taking place, or
&lt;li&gt;A memory cycle is not active and a hold is currently active.
&lt;/ul&gt;

&lt;p&gt;The first case occurs during bus (memory) activity, where a hold request before cycle T2 will be handled at the end of that cycle.
The second case allows a hold if the bus is inactive. But if microcode is performing a memory operation, the hold will be delayed, even if the request is just starting.
The third case is opposite from the other two: it enables the flip flop so a hold request can be dropped.
(This ensures that the hold request can still be dropped in the corner case where a hold starts and then the microcode makes a memory
request, which will be blocked by the hold.)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-hold/hold-ok-circuit.png&quot;&gt;&lt;img alt=&quot;The &amp;quot;hold ok&amp;quot; circuit. This has been rearranged from the schematic to make the behavior more clear.&quot; class=&quot;hilite&quot; height=&quot;118&quot; src=&quot;https://static.righto.com/images/8086-hold/hold-ok-circuit-w400.png&quot; title=&quot;The &amp;quot;hold ok&amp;quot; circuit. This has been rearranged from the schematic to make the behavior more clear.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The &quot;hold ok&quot; circuit. This has been rearranged from the schematic to make the behavior more clear.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;An instruction with the &lt;code&gt;LOCK&lt;/code&gt; prefix causes the bus to be locked against other devices for the duration of the instruction.
Thus, a hold cannot be granted while the instruction is running. This is implemented through a separate path.
This logic is between the output of the first (request) flip-flop and the second (accepted) flip-flop, tied into the &lt;code&gt;LOCK&lt;/code&gt; signal.
Conceptually, it seems that the &lt;code&gt;LOCK&lt;/code&gt; signal should block &lt;code&gt;hold-ok&lt;/code&gt; and thus block the second (accepted) flip-flop from
being enabled.
But instead, the &lt;code&gt;LOCK&lt;/code&gt; signal blocks the data path, unless the request has already been granted.
I think the motivation is to allow dropping of a hold request to proceed uninterrupted.
In other words, &lt;code&gt;LOCK&lt;/code&gt; prevents a hold from being accepted, but it doesn&#39;t prevent a hold from being dropped, and it
was easier to implement this in the data path.&lt;/p&gt;
&lt;h3&gt;The pin drive circuitry&lt;/h3&gt;
&lt;p&gt;The circuitry for the &lt;code&gt;HOLD/RQ0/GT0&lt;/code&gt; and &lt;code&gt;HLDA/RQ1/GT1&lt;/code&gt; pins is somewhat complicated, since they are used for both input and output.
In minimum mode, the &lt;code&gt;HOLD&lt;/code&gt; pin is an input, while the &lt;code&gt;HLDA&lt;/code&gt; pin is an output.
In maximum mode, both pins act as an input, with a low-going pulse from an external device to start or stop the hold.
But the 8086 also issues pulses to grant the hold. 
Pull-up resistors inside the 8086 to ensure that the pins remain high (idle) when unused.
Finally, an undocumented active pull-up system restores a pin to a high state after it is pulled low, providing faster
response than the resistor.&lt;/p&gt;
&lt;p&gt;The schematic below shows the heart of the tri-state output circuit.
Each pin is connected to two large output MOSFETs, one to drive the pin high and one to drive the pin low.
The transistors have separate control lines; if both control lines are low, both transistors are off and the pin
floats in the &quot;tri-state&quot; condition. 
This permits the pin to be used as an input, driven by an external device. 
The pull-up resistor keeps the pin in a high state.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-hold/pin-output.png&quot;&gt;&lt;img alt=&quot;The tri-state output circuit for each hold pin.&quot; class=&quot;hilite&quot; height=&quot;231&quot; src=&quot;https://static.righto.com/images/8086-hold/pin-output-w300.png&quot; title=&quot;The tri-state output circuit for each hold pin.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The tri-state output circuit for each hold pin.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The diagram below shows how this circuitry looks on the die.
In this image, the metal and polysilicon layers have been removed with acid to show the underlying doped
silicon regions. The thin white stripes are transistor gates where polysilicon wiring crossed the silicon.
The black circles are vias that connected the silicon to the metal on top.
The empty regions at the right are where the metal pads for &lt;code&gt;HOLD&lt;/code&gt; and &lt;code&gt;HLDA&lt;/code&gt; were.
Next to the pads are the large transistors to pull the outputs high or low.
Because the outputs require much higher current than internal signals, these transistors are much
larger than logic transistors.
They are composed of several transistors placed in parallel, resulting in the parallel stripes.
The small pullup resistors are also visible.
For efficiency, these resistors are actually depletion-mode transistors, specially doped to act as constant-current sources.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-hold/output-die.jpg&quot;&gt;&lt;img alt=&quot;The HOLD/HLDA pin circuitry on the die.&quot; class=&quot;hilite&quot; height=&quot;496&quot; src=&quot;https://static.righto.com/images/8086-hold/output-die-w500.jpg&quot; title=&quot;The HOLD/HLDA pin circuitry on the die.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The HOLD/HLDA pin circuitry on the die.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;At the left, some of the circuitry is visible.
The large output transistors are driven by &quot;superbuffers&quot; that provide more current than regular NMOS buffers.
(A superbuffer uses separate transistors to pull the signal high and low, rather than using a pull-up to pull
the signal high as in a standard NMOS gate.)
The small transistors are the pass transistors that gate output signals according to the clock.
The thick rectangles are crossovers, allowing the vertical metal wiring (no longer visible) to cross over
a horizontal signal in the signal layer.
The 8086 has only a single metal layer, so the layout requires a crossover if signals will otherwise
intersect.
Because silicon&#39;s resistance is much higher than metal&#39;s resistance, the crossover is relatively wide
to reduce the resistance.&lt;/p&gt;
&lt;p&gt;The problem with a pull-up resistor is that it is relatively slow when connected to a line with high capacitance.
You essentially end up with a resistor-capacitor delay circuit, as the resistor slowly charges the line and
brings it up to a high level.
To get around this, the 8086 has an active drive circuit to pulse the RQ/GT lines high to pull them back from a low level.
This circuit pulls the line high one cycle after the 8086 drops it low for a grant acknowledge.
This circuit also pulls the line high after the external device pulls it low.&lt;span id=&quot;fnref:pullup&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:pullup&quot;&gt;11&lt;/a&gt;&lt;/span&gt;
(The schematic for this circuit is in the footnotes.)
The curious thing is that I couldn&#39;t find this behavior documented in the datasheets. The datasheets describe
the internal pull-up resistor, but don&#39;t mention that the 8086 actively pulls the lines high.&lt;span id=&quot;fnref:driver&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:driver&quot;&gt;12&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The hold circuitry was a key feature of the 8086, largely because it was necessary for the 8087 math coprocessor chip.
The hold circuitry seems like it should be straightforward, but there are many corner cases in this circuitry:
it interacts with unaligned memory accesses, the &lt;code&gt;LOCK&lt;/code&gt; prefix, and minimum vs. maximum modes.
As a result, it is fairly complicated.&lt;/p&gt;
&lt;p&gt;Personally, I find the hold circuitry somewhat unsatisfying to study, with few fundamental concepts but a lot of special-case logic.
The circuitry seems overly complicated for what it does.
Much of the complexity is probably due to the wildly different behavior of the pins between minimum and maximum mode.
Intel should have simply used a larger package (like the Motorola 68000) rather than re-using pins to support different
modes, as well as using the same pin for a request and a grant.
It&#39;s impressive, however, the same circuitry was made to work for both minimum and maximum modes, despite using
completely different signals to request and grant holds.
This circuitry must have been a nightmare for Intel&#39;s test engineers, trying to ensure that the circuitry performed properly
when there were so many corner cases and potential race conditions.&lt;/p&gt;
&lt;p&gt;I plan to write more on the 8086, so 
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@kenshirriff@oldbytes.space&lt;/a&gt;
and Bluesky as &lt;a href=&quot;https://staging.bsky.app/profile/righto.com&quot;&gt;@righto.com&lt;/a&gt; so you can follow me there too.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:priority&quot;&gt;
&lt;p&gt;The timing of priority between &lt;code&gt;RQ0&lt;/code&gt; and &lt;code&gt;RQ1&lt;/code&gt; is left vague in the documentation.
In practice, even if &lt;code&gt;RQ1&lt;/code&gt; is requested first, a later &lt;code&gt;RQ0&lt;/code&gt; can still preempt it until the point that &lt;code&gt;RQ1&lt;/code&gt; is internally
granted (i.e. the second flip-flop is activated).
This happens before the hold is externally acknowledged, so it&#39;s not obvious to the user at what point priority no longer applies.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:priority&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:active-low&quot;&gt;
&lt;p&gt;The &lt;code&gt;RQ/GT0&lt;/code&gt; and &lt;code&gt;RQ/GT1&lt;/code&gt; signals are active-low. These signals should have an overbar to indicate this,
but it makes the page formatting ugly :-)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:active-low&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:8087&quot;&gt;
&lt;p&gt;Modern x86 processors still support the 8087 (x87) instruction set.
Starting with the 80486DX, the floating point unit was included on the CPU die, rather than as an external coprocessor.
The x87 instruction set used a stack-based model, which made it harder to parallelize.
To mitigate this, Intel introduced &lt;a href=&quot;https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions&quot;&gt;SSE&lt;/a&gt; in 1999, a different set of
floating point instructions that worked on an independent register set.
The x87 instructions are now considered mostly obsolete and are &lt;a href=&quot;https://www.realworldtech.com/physx87/4/&quot;&gt;deprecated&lt;/a&gt; in &lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/dxtecharts/sixty-four-bit-programming-for-game-developers#porting-applications-to-64-bit-platforms&quot;&gt;64-bit Windows&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:8087&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:8087-rq&quot;&gt;
&lt;p&gt;The 8087 provides another &lt;code&gt;RQ/GT&lt;/code&gt; input line for an external device. Thus, two external devices
can still be used in a system with an 8087.
That is, although the 8087 uses up one of the 8086&#39;s two &lt;code&gt;RQ/GT&lt;/code&gt; lines, the 8087 provides another one, so
there are still two lines available.
The 8087 has logic to combine its bus requests and external bus requests into a single &lt;code&gt;RQ/GT&lt;/code&gt; line to the 8086.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:8087-rq&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:polarity&quot;&gt;
&lt;p&gt;Confusingly, some of the flip-flops in the hold circuit transistion when the clock goes high, while others
use the inverted clock signal and transition when the clock goes low.
Moreover, the flip-flops are inconsistent about how they treat the data. In each group of three flip-flops, the first flip-flop is active-high, while the remaining flip-flops are active-low.
For the most part, I&#39;ll ignore this in the discussion.
You can look at the schematic if you want to know the details.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:polarity&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:schematic&quot;&gt;
&lt;p&gt;The schematics below shows my reverse-engineered schematic for the hold circuitry.
I have partitioned the schematic into the hold logic and the output driver circuitry.
This split matches the physical partitioning of the circuitry on the die.&lt;/p&gt;
&lt;p&gt;In the first schematic, the upper part handles &lt;code&gt;HOLD&lt;/code&gt; and &lt;code&gt;request0&lt;/code&gt;, while the lower part handles
&lt;code&gt;request1&lt;/code&gt;. There is some circuitry in the middle to handle the common enabling and to generate the
internal hold signal.
I won&#39;t explain the circuitry in much detail, but there are a few things I want to point out.
First, even though the hold circuit seems like it should be simple, there are a lot of gates connected in complicated ways.
Second, although there are many inverters, NAND, and NOR gates, there are also complex gates such as
AND-NOR, OR-NAND, AND-OR-NAND, and so forth.
These are implemented as single gates.
Due to how gates are constructed from NMOS transistors, it is just as easy to build a hierarchical gate as
a single gate. (The last step must be inversion, though.)
The XOR gates are more complex; they are constructed from a NOR gate and an AND-NOR gate.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-hold/schematic1.png&quot;&gt;&lt;img alt=&quot;Schematic of the hold circuitry. Click this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;391&quot; src=&quot;https://static.righto.com/images/8086-hold/schematic1-w700.png&quot; title=&quot;Schematic of the hold circuitry. Click this image (or any other) for a larger version.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Schematic of the hold circuitry. Click this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The schematic below shows the output circuits for the two pins. These circuits are similar, but have a few
differences because only the bottom one is used as an output (&lt;code&gt;HLDA&lt;/code&gt;) in minimum mode.
Each circuit has two inputs: what the current value of the pin is, and what the desired value of the pin is.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-hold/schematic2.png&quot;&gt;&lt;img alt=&quot;Schematic of the pin output circuits.&quot; class=&quot;hilite&quot; height=&quot;386&quot; src=&quot;https://static.righto.com/images/8086-hold/schematic2-w700.png&quot; title=&quot;Schematic of the pin output circuits.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Schematic of the pin output circuits.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- --&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:schematic&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:tristate&quot;&gt;
&lt;p&gt;Interestingly, the external pins aren&#39;t taken out of tri-state mode immediately when the &lt;code&gt;HLDA&lt;/code&gt; signal is dropped.
Instead, the 8086&#39;s bus drivers are re-enabled when a bus cycle starts, which is slightly later.
The bus circuitry has a separate flip-flop to manage the enable/disable state, and the start of a bus cycle
is what re-enables the bus.
This is another example of behavior that the documentation leaves ambiguous.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:tristate&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:hold-out&quot;&gt;
&lt;p&gt;There&#39;s one more complication for the &lt;code&gt;hold-out&lt;/code&gt; signal. If a hold is granted on one line, a request comes in on
the other line, and then the hold is released on the first line, the desired behavior is for the bus to remain
in the hold state as the hold switches to the second line.
However, because of the way a hold on line 1 blocks a hold on line 0, the &lt;code&gt;GT1&lt;/code&gt; second flip-flop will drop a cycle before
the GT0 second flip-flop is activated.
This would cause &lt;code&gt;hold-out&lt;/code&gt; to drop for a cycle and the 8086 could start unwanted bus activity.
To prevent this case, the &lt;code&gt;hold-out&lt;/code&gt; line is also activated if there is an RQ0 request and RQ1 is granted.
This condition seems a bit random but it covers the &quot;gap&quot;.
I have to wonder if Intel planned the circuit this way, or they added the extra test as a bug fix.
(The asymmetry of the priority circuit causes this problem to occur only going from a hold on line 1 to line 0, not the
other direction.)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:hold-out&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:pulse&quot;&gt;
&lt;p&gt;The pulse-generating circuit is a bit tricky. 
A pulse signal is generated if the request has been accepted, has not been granted, and will be granted on the next clock (i.e. no memory request is active so the flip-flop is enabled).
(Note that the pulse will be one cycle wide, since granting the request on the next cycle will cause the conditions to be no longer satisfied.)
This provides the pulse one clock cycle before the flip-flop makes it &quot;official&quot;.
Moreover, the signals come from the inverted Q outputs from the flip-flops, which are updated half a clock cycle earlier.
The result is that the pulse is generated 1.5 clock cycles before the flip-flop output.
Presumably the point of this is to respond to hold requests faster, but it seems overly complicated.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:pulse&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:feedback&quot;&gt;
&lt;p&gt;The request pulse is required to be one clock cycle wide. The feedback loop shows why:
if the request is longer than one clock cycle, the first flip-flop will repeatedly toggle on and off,
resulting in unexpected behavior.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:feedback&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:pullup&quot;&gt;
&lt;p&gt;The details of the active pull-up circuitry don&#39;t make sense to me.
First it XORs the state of the pin with the desired state of the pin and uses this signal to control a
multiplexer, which generates the pull-up action based on other gates.
The result of all this ends up being simply NAND, implemented with excessive gates.
Another issue is that minimum mode blocks the active pull-up, which makes sense.
But there are additional logic gates so minimum mode can affect the value going into the multiplexer,
which gets blocked in minimum mode, so that logic seems wasted.
There are also two separate circuits to block pull-up during reset.
My suspicion is that the original logic accumulated bug fixes and redundant logic wasn&#39;t removed.
But it&#39;s possible that the implementation is doing something clever that I&#39;m just missing.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:pullup&quot; title=&quot;Jump back to footnote 11 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:driver&quot;&gt;
&lt;p&gt;My analysis of the &lt;code&gt;RQ/GT&lt;/code&gt; lines being pulled high is based on simulation.
It would be interesting to verify this behavior on a physical 8086 chip.
By measuring the current out of the pin, the pull-up pulses should be visible.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:driver&quot; title=&quot;Jump back to footnote 12 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/2195435311934656338/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=2195435311934656338' title='1 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/2195435311934656338'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/2195435311934656338'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/08/intel-8086-bus-hold.html' title='A close look at the 8086 processor&#39;s bus hold circuitry'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-5516205124640022120</id><published>2023-07-15T23:28:00.012-07:00</published><updated>2023-07-17T17:52:27.160-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="intel"/><category scheme="http://www.blogger.com/atom/ns#" term="microcode"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>Undocumented 8086 instructions, explained by the microcode</title><content type='html'>&lt;style&gt;
&gt;Undocumented 8086 instructions, explained by the microcode&lt;/h1&gt;
&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;
&lt;style&gt;
  pre.microcode {font-family: courier, fixed; padding: 10px; background-color: #f5f5f5; display:inline-block;border:none;}
  pre.microcode span {color: green; font-style:italic; font-family: sans-serif; font-size: 90%;}
&lt;/style&gt;

&lt;p&gt;What happens if you give the Intel 8086 processor an instruction that doesn&#39;t exist?
A modern microprocessor (80186 and later) will generate an exception, indicating that an illegal instruction
was executed.
However, early microprocessors didn&#39;t include the circuitry to detect illegal instructions, since the chips didn&#39;t have
transistors to spare. Instead these processors would do &lt;em&gt;something&lt;/em&gt;,
but the results weren&#39;t specified.&lt;span id=&quot;fnref:6502&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:6502&quot;&gt;1&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The 8086 has a number of undocumented instructions.
Most of them are simply duplicates of regular instructions, but a few have unexpected behavior, such as revealing the
values of internal, hidden registers.
In the 8086, most instructions are implemented in microcode, so examining the 8086&#39;s microcode can explain why these instructions
behave the way they do.&lt;/p&gt;
&lt;p&gt;The photo below shows the 8086 die under a microscope, with the important functional blocks labeled. The metal layer is visible, while the underlying silicon and polysilicon wiring is mostly hidden.
The microcode ROM and the microcode address decoder are in the lower right.
The Group Decode ROM (upper center) is also important, as it performs the first step of instruction decoding.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-undoc/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled. Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;589&quot; src=&quot;https://static.righto.com/images/8086-ad-undoc/die-labeled-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled. Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled. Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Microcode and 8086 instruction decoding&lt;/h2&gt;
&lt;p&gt;You might think that machine instructions are the basic steps that a computer performs.
However, instructions usually require multiple steps inside the processor.
One way of expressing these multiple steps is through microcode, a technique dating back to 1951.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.
In other words, microcode forms  nother layer between the machine instructions and the hardware.
The main advantage of microcode is that it turns the processor&#39;s control logic into a programming task instead of a difficult logic design task.&lt;/p&gt;
&lt;p&gt;The 8086&#39;s &lt;a href=&quot;https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html&quot;&gt;microcode ROM&lt;/a&gt; holds 512 micro-instructions, each 21 bits wide.
Each micro-instruction performs two actions in parallel. First is a move between a source and a destination, typically registers.
Second is an operation that can range from an arithmetic (ALU) operation to a memory access.
The diagram below shows the structure of a 21-bit micro-instruction, divided into six types.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-undoc/microcode-format.jpg&quot;&gt;&lt;img alt=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; class=&quot;hilite&quot; height=&quot;203&quot; src=&quot;https://static.righto.com/images/8086-ad-undoc/microcode-format-w700.jpg&quot; title=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The encoding of a micro-instruction into 21 bits. Based on &lt;a href=&quot;https://digitalcommons.law.scu.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=1031&amp;context=chtlj&quot;&gt;NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;When executing a machine instruction, the 8086 performs a decoding step.
Although the 8086 is a 16-bit processor, its instructions are based on bytes. In most cases, the first byte specifies the
opcode, which may be followed by additional instruction bytes.
In other cases, the byte is a &quot;prefix&quot; byte, which changes the behavior of the following instruction.
The first byte is analyzed
by something called the &lt;a href=&quot;https://www.righto.com/2023/05/8086-processor-group-decode-rom.html&quot;&gt;Group Decode ROM&lt;/a&gt;.
This circuit categorizes the first byte of the instruction into about &lt;code&gt;35&lt;/code&gt; categories that control how the instruction is
decoded and executed.
One category is &quot;1-byte logic&quot;; this indicates a one-byte instruction or prefix that is simple and implemented by logic circuitry in the 8086.
For instructions in this category, microcode is not involved while
the remaining instructions are implemented in microcode.
Many of these instructions are in the &quot;two-byte ROM&quot; category indicating that the instruction has a second byte
that also needs to be decoded by microcode.
This second byte, called the ModR/M byte, specifies that memory addressing mode or registers that the instruction uses.&lt;/p&gt;
&lt;p&gt;The next step is the microcode&#39;s address decoder circuit, which determines where to start executing microcode based on
the opcode.
Conceptually, you can think of the microcode as stored in a ROM, indexed by the instruction opcode and a few sequence bits.
However, since many instructions can use the same microcode, it would be inefficient to store duplicate copies of these routines.
Instead, the microcode address decoder permits multiple instructions to reference the same entries in the ROM.
This decoding circuitry is similar to a PLA (Programmable Logic Array) so it matches bit patterns to determine a particular starting point.
This turns out to be important for undocumented instructions since undocumented instructions often match the pattern for a &quot;real&quot; instruction, making the undocumented instruction an alias.&lt;/p&gt;
&lt;p&gt;The 8086 has several internal registers that are invisible to the programmer but are used by the microcode.
Memory accesses use the Indirect (&lt;code&gt;IND&lt;/code&gt;) and Operand (&lt;code&gt;OPR&lt;/code&gt;) registers; the &lt;code&gt;IND&lt;/code&gt; register holds the address in the segment,
while the &lt;code&gt;OPR&lt;/code&gt; register holds the data value that is read or written.
Although these registers are normally not accessible by the programmer, some undocumented instructions provide access to these registers, as will be described later.&lt;/p&gt;
&lt;p&gt;The Arithmetic/Logic Unit (ALU) performs arithmetic, logical, and shift operations in the 8086.
The ALU uses three internal registers: &lt;code&gt;tmpA&lt;/code&gt;, &lt;code&gt;tmpB&lt;/code&gt;, and &lt;code&gt;tmpC&lt;/code&gt;. An ALU operation requires two micro-instructions.
The first micro-instruction specifies the operation (such as &lt;code&gt;ADD&lt;/code&gt;) and the temporary register that holds one argument (e.g. &lt;code&gt;tmpA&lt;/code&gt;);
the second argument is always in &lt;code&gt;tmpB&lt;/code&gt;.
A following micro-instruction can access the ALU result through the pseudo-register &lt;code&gt;&lt;/code&gt; (sigma).&lt;/p&gt;
&lt;h3&gt;The ModR/M byte&lt;/h3&gt;
&lt;p&gt;A fundamental part of the 8086 instruction format is the ModR/M byte, a byte that specifies addressing for many instructions.
The 8086 has a variety of addressing modes, so the ModR/M byte is somewhat complicated.
Normally it specifies one memory address and one register. The memory address is specified through one of eight addressing
modes (below) along with an optional 8- or 16-bit displacement in the instruction.
Instead of a memory address, the ModR/M byte can also specify a second register.
For a few opcodes, the ModR/M byte selects what instruction to execute rather than a register.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-undoc/modrm.png&quot;&gt;&lt;img alt=&quot;The 8086&#39;s addressing modes. From The register assignments, from MCS-86 Assembly Language Reference Guide.&quot; class=&quot;hilite&quot; height=&quot;220&quot; src=&quot;https://static.righto.com/images/8086-ad-undoc/modrm-w250.png&quot; title=&quot;The 8086&#39;s addressing modes. From The register assignments, from MCS-86 Assembly Language Reference Guide.&quot; width=&quot;250&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086&#39;s addressing modes. From &lt;a href=&quot;http://bitsavers.org/components/intel/8086/9800749-1_MCS-86_Assembly_Language_Reference_Guide_Oct78.pdf&quot;&gt;The register assignments, from MCS-86 Assembly Language Reference Guide&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The implementation of the ModR/M byte plays an important role in the behavior of undocumented instructions.
Support for this byte is implemented in both microcode and hardware.
The various memory address modes above are implemented by microcode subroutines, which compute the appropriate memory address and
perform a read if necessary.
The subroutine leaves the memory address in the &lt;code&gt;IND&lt;/code&gt; register, and if a read is performed, the value is in the &lt;code&gt;OPR&lt;/code&gt; register.&lt;/p&gt;
&lt;p&gt;The hardware hides the ModR/M byte&#39;s selection of memory versus register, by making the value available through the pseudo-register &lt;code&gt;M&lt;/code&gt;, while the second register is available through &lt;code&gt;N&lt;/code&gt;.
Thus, the microcode for an instruction doesn&#39;t need to know if the value was in memory or a register, or which register was selected.
The Group Decode ROM examines the first byte of the instruction to determine if a ModR/M byte is present, and if a read
is required.
If the ModR/M byte specifies memory, the Translation ROM determines which micro-subroutines to call before handling the
instruction itself.
For more on the ModR/M byte, see my post on &lt;a href=&quot;https://www.righto.com/2023/02/8086-modrm-addressing.html&quot;&gt;Reverse-engineering the ModR/M addressing microcode&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Holes in the opcode table&lt;/h2&gt;
&lt;p&gt;The first byte of the instruction is a value from &lt;code&gt;00&lt;/code&gt; to &lt;code&gt;FF&lt;/code&gt; in hex.
Almost all of these opcode values correspond to documented 8086 instructions, but there are a few exceptions, &quot;holes&quot; in the opcode table.
The table below shows the 256 first-byte opcodes for the 8086, from hex &lt;code&gt;00&lt;/code&gt; to &lt;code&gt;FF&lt;/code&gt;. Valid opcodes for the 8086 are in white;
the colored opcodes are undefined and interesting to examine.
Orange, yellow, and green opcodes were given meaning in the 80186, 80286, and 80386 respectively.
The purple opcode is unusual: it was implemented in the 8086 and later processors but not documented.&lt;span id=&quot;fnref:prefixes&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:prefixes&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
In this section, I&#39;ll examine the microcode for these opcode holes.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-undoc/opcodes.png&quot;&gt;&lt;img alt=&quot;This table shows the 256 opcodes for the 8086, where the white ones are valid instructions. Click for a larger version.&quot; class=&quot;hilite&quot; height=&quot;453&quot; src=&quot;https://static.righto.com/images/8086-ad-undoc/opcodes-w450.png&quot; title=&quot;This table shows the 256 opcodes for the 8086, where the white ones are valid instructions. Click for a larger version.&quot; width=&quot;450&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This table shows the 256 opcodes for the 8086, where the white ones are valid instructions. Click for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;D6&lt;/code&gt;: &lt;code&gt;SALC&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The opcode &lt;code&gt;D6&lt;/code&gt; (purple above) performs a well-known but undocumented operation that is typically called &lt;code&gt;SALC&lt;/code&gt;, for Set AL to Carry.
This instruction sets the &lt;code&gt;AL&lt;/code&gt; register to 0 if the carry flag is 0, and sets the &lt;code&gt;AL&lt;/code&gt; register to &lt;code&gt;FF&lt;/code&gt; if the carry flag is 1.
The curious thing about this undocumented instruction is that it exists in all x86 CPUs, but Intel didn&#39;t mention it until 2017.
Intel probably put this instruction into the processor deliberately as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Fictitious_entry#Copyright_traps&quot;&gt;copyright trap&lt;/a&gt;.
The idea is that if a company created a copy of the 8086 processor and the processor included the &lt;code&gt;SALC&lt;/code&gt; instruction, this
would prove that the company had copied Intel&#39;s microcode and thus had potentially violated Intel&#39;s copyright on the microcode.
This came to light when NEC created improved versions of the 8086, the NEC V20 and V30 microprocessors, and was sued by Intel.
Intel analyzed NEC&#39;s microcode but was disappointed to find that NEC&#39;s chip did not include the hidden instruction, showing
that NEC hadn&#39;t copied the microcode.&lt;span id=&quot;fnref:magic-instruction&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:magic-instruction&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
Although a Federal judge &lt;a href=&quot;https://www.nytimes.com/1989/02/08/business/intel-loses-copyright-case-to-nec.html&quot;&gt;ruled&lt;/a&gt; in 1989 that NEC hadn&#39;t infringed
Intel&#39;s copyright, the 5-year trial ruined NEC&#39;s market momentum.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;SALC&lt;/code&gt; instruction is implemented with three micro-instructions, shown below.&lt;span id=&quot;fnref:microcode&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:microcode&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
The first micro-instruction jumps if the carry (&lt;code&gt;CY&lt;/code&gt;) is set.
If not, the next instruction moves 0 to the AL register. &lt;code&gt;RNI&lt;/code&gt; (Run Next Instruction) ends the microcode execution
causing the next machine instruction to run.
If the carry was set, all-ones (i.e. &lt;code&gt;FF&lt;/code&gt; hex) is moved to the &lt;code&gt;AL&lt;/code&gt; register and RNI ends the microcode sequence.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
           JMPS CY 2 &lt;span&gt;&lt;b&gt;SALC&lt;/b&gt;: jump on carry&lt;/span&gt;
ZERO  AL  RNI       &lt;span&gt;Move 0 to AL, run next instruction&lt;/span&gt;
ONES  AL  RNI       &lt;span&gt;&lt;b&gt;2:&lt;/b&gt;Move FF to AL, run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;0F&lt;/code&gt;: &lt;code&gt;POP CS&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;0F&lt;/code&gt; opcode is the first hole in the opcode table.
The 8086 has instructions to push and pop the four segment registers, except opcode &lt;code&gt;0F&lt;/code&gt; is undefined where &lt;code&gt;POP CS&lt;/code&gt; should be.
This opcode performs &lt;code&gt;POP CS&lt;/code&gt; successfully, so the question is why is it undefined?
The reason is that &lt;code&gt;POP CS&lt;/code&gt; is essentially useless and doesn&#39;t do what you&#39;d expect, so Intel figured it was best not
to document it.&lt;/p&gt;
&lt;p&gt;To understand why &lt;code&gt;POP CS&lt;/code&gt; is useless, I need to step back and explain the 8086&#39;s segment registers.
The 8086 has a &lt;code&gt;20&lt;/code&gt;-bit address space, but 16-bit registers.
To make this work, the 8086 has the concept of segments: memory is accessed in 64K chunks called segments, which are positioned
in the 1-megabyte address space.
Specifically, there are four segments: Code Segment, Stack Segment, Data Segment, and Extra Segment,
with four segment registers that define the start of the segment: &lt;code&gt;CS&lt;/code&gt;, &lt;code&gt;SS&lt;/code&gt;, &lt;code&gt;DS&lt;/code&gt;, and &lt;code&gt;ES&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;An inconvenient part of segment addressing  is that if you want to access more than 64K, you need to change the segment register.
So you might push the data segment register, change it temporarily so you can access a new part of memory, and then pop the old data segment
register value off the stack.
This would use the &lt;code&gt;PUSH DS&lt;/code&gt; and &lt;code&gt;POP DS&lt;/code&gt; instructions.
But why not &lt;code&gt;POP CS&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;The 8086 executes code from the code segment, with the instruction pointer (&lt;code&gt;IP&lt;/code&gt;) tracking the location in the code segment.
The main problem with &lt;code&gt;POP CS&lt;/code&gt; is that it changes the code segment, but not the instruction pointer, so now you are executing
code at the old offset in a new segment.
Unless you line up your code extremely carefully, the result is that you&#39;re jumping to an unexpected place in memory.
(Normally, you want to change &lt;code&gt;CS&lt;/code&gt; and the instruction pointer at the same time, using a &lt;code&gt;CALL&lt;/code&gt; or &lt;code&gt;JMP&lt;/code&gt; instruction.)&lt;/p&gt;
&lt;p&gt;The second problem with &lt;code&gt;POP CS&lt;/code&gt; is prefetching.
For efficiency, the 8086 prefetches instructions before they are needed, storing them in an 8-byte prefetch queue.
When you perform a jump, for instance, the microcode flushes the prefetch queue so execution will continue with the
new instructions, rather than the old instructions.
However, the instructions that pop a segment register don&#39;t flush the prefetch buffer.
Thus, &lt;code&gt;POP CS&lt;/code&gt; not only jumps to an unexpected location in memory, but it will execute an unpredictable number of instructions
from the old code path.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;POP segment register&lt;/code&gt; microcode below packs a lot into three micro-instructions.
The first micro-instruction pops a value from the stack.
Specifically, it moves the stack pointer (&lt;code&gt;SP&lt;/code&gt;) to the Indirect (&lt;code&gt;IND&lt;/code&gt;) register.
The Indirect register is an internal register, invisible to the programmer, that holds the address offset for memory
accesses.
The first micro-instruction also performs a memory read (&lt;code&gt;R&lt;/code&gt;) from the stack segment (&lt;code&gt;SS&lt;/code&gt;) and then increments &lt;code&gt;IND&lt;/code&gt;
by 2 (&lt;code&gt;P2&lt;/code&gt;, plus 2).
The second micro-instruction moves &lt;code&gt;IND&lt;/code&gt; to the stack pointer, updating the stack pointer with the new value.
It also tells the microcode engine that this micro-instruction is the next-to-last (&lt;code&gt;NXT&lt;/code&gt;) and the next machine instruction
can be started.
The final micro-instruction moves the value read from memory to the appropriate segment register and runs the next instruction.
Specifically, reads and writes put data in the internal &lt;code&gt;OPR&lt;/code&gt; (Operand) register.
The hardware uses the register &lt;code&gt;N&lt;/code&gt; to indicate the register specified by the instruction.
That is, the value will be stored in the &lt;code&gt;CS&lt;/code&gt;, &lt;code&gt;DS&lt;/code&gt;, &lt;code&gt;ES&lt;/code&gt;, or &lt;code&gt;SS&lt;/code&gt; register, depending on the bit pattern in the instruction.
Thus, the same microcode works for all four segment registers.
This is why &lt;code&gt;POP CS&lt;/code&gt; works even though &lt;code&gt;POP CS&lt;/code&gt; wasn&#39;t explicitly implemented in the microcode; it uses the common code.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
SP  IND  R SS,P2 &lt;span&gt;&lt;b&gt;POP sr&lt;/b&gt;: read from stack, compute IND plus 2&lt;/span&gt;
IND  SP  NXT     &lt;span&gt;Put updated value in SP, start next instruction.&lt;/span&gt;
OPR  N   RNI     &lt;span&gt;Put stack value in specified segment register&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;But why does &lt;code&gt;POP CS&lt;/code&gt; run this microcode in the first place?
The microcode to execute is selected based on the instruction, but multiple instructions can execute the same microcode.
You can think of the address decoder as pattern-matching on the instruction&#39;s bit patterns, where some of the bits can be ignored.
In this case, the &lt;code&gt;POP sr&lt;/code&gt; microcode above is run by any instruction with the bit pattern 000??111, where a question mark
can be either a 0 or a 1.
You can verify that this pattern matches &lt;code&gt;POP ES&lt;/code&gt; (&lt;code&gt;07&lt;/code&gt;), &lt;code&gt;POP SS&lt;/code&gt; (&lt;code&gt;17&lt;/code&gt;), and &lt;code&gt;POP DS&lt;/code&gt; (&lt;code&gt;1F&lt;/code&gt;).
However, it also matches &lt;code&gt;0F&lt;/code&gt;, which is why the &lt;code&gt;0F&lt;/code&gt; opcode runs the above microcode and performs &lt;code&gt;POP CS&lt;/code&gt;.
In other words, to make &lt;code&gt;0F&lt;/code&gt; do something other than &lt;code&gt;POP CS&lt;/code&gt; would require additional circuitry, so it was easier to
leave the action implemented but undocumented.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;60&lt;/code&gt;-&lt;code&gt;6F&lt;/code&gt;: conditional jumps&lt;/h3&gt;
&lt;p&gt;One whole row of the opcode table is unused: values &lt;code&gt;60&lt;/code&gt; to &lt;code&gt;6F&lt;/code&gt;.
These opcodes simply act the same as &lt;code&gt;70&lt;/code&gt; to &lt;code&gt;7F&lt;/code&gt;, the conditional jump instructions.&lt;/p&gt;
&lt;p&gt;The conditional jumps use the following microcode.
It fetches the jump offset from the instruction prefetch queue (&lt;code&gt;Q&lt;/code&gt;) and puts the value into the ALU&#39;s &lt;code&gt;tmpBL&lt;/code&gt; register,
the low byte of the &lt;code&gt;tmpB&lt;/code&gt; register.
It tests the condition in the instruction (&lt;code&gt;XC&lt;/code&gt;) and jumps to the &lt;code&gt;RELJMP&lt;/code&gt; micro-subroutine if satisfied.
The &lt;code&gt;RELJMP&lt;/code&gt; code (not shown) updates the program counter to perform the jump.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
Q  tmpBL                &lt;span&gt;&lt;b&gt;Jcond cb:&lt;/b&gt; Get offset from prefetch queue&lt;/span&gt;
           JMP XC RELJMP &lt;span&gt;Test condition, if true jump to RELJMP routine&lt;/span&gt;
           RNI           &lt;span&gt;No jump: run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;This code is executed for any instruction matching the bit pattern &lt;code&gt;011?????&lt;/code&gt;, i.e. anything from &lt;code&gt;60&lt;/code&gt; to &lt;code&gt;7F&lt;/code&gt;.
The condition is specified by the four low bits of the instruction.
The result is that any instruction &lt;code&gt;60&lt;/code&gt;-&lt;code&gt;6F&lt;/code&gt; is an alias for the corresponding conditional jump &lt;code&gt;70&lt;/code&gt;-&lt;code&gt;7F&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;C0&lt;/code&gt;, &lt;code&gt;C8&lt;/code&gt;: &lt;code&gt;RET/RETF imm&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;These undocumented opcodes act like a return instruction, specifically &lt;code&gt;RET imm16&lt;/code&gt; (&lt;a href=&quot;https://www.os2museum.com/wp/undocumented-8086-opcodes-part-i/&quot;&gt;source&lt;/a&gt;).
Specifically, the instruction &lt;code&gt;C0&lt;/code&gt; is the same as &lt;code&gt;C2&lt;/code&gt;, near return, while &lt;code&gt;C8&lt;/code&gt; is the same as &lt;code&gt;CA&lt;/code&gt;, far return.&lt;/p&gt;
&lt;p&gt;The microcode below is executed for the instruction bits &lt;code&gt;1100?0?0&lt;/code&gt;, so it is executed for &lt;code&gt;C0&lt;/code&gt;, &lt;code&gt;C2&lt;/code&gt;, &lt;code&gt;C8&lt;/code&gt;, and &lt;code&gt;CA&lt;/code&gt;.
It gets two bytes from the instruction prefetch queue (&lt;code&gt;Q&lt;/code&gt;) and puts them in the &lt;code&gt;tmpA&lt;/code&gt; register.
Next, it calls &lt;code&gt;FARRET&lt;/code&gt;, which performs either a near return (popping &lt;code&gt;PC&lt;/code&gt; from the stack) or a far return (popping &lt;code&gt;PC&lt;/code&gt; and &lt;code&gt;CS&lt;/code&gt;
from the stack). Finally, it adds the original argument to the &lt;code&gt;SP&lt;/code&gt;, equivalent to popping that many bytes.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
Q  tmpAL    ADD tmpA    &lt;span&gt;&lt;b&gt;RET/RETF iw:&lt;/b&gt; Get word from prefetch, set up ADD&lt;/span&gt;
Q  tmpAH    CALL FARRET &lt;span&gt;Call Far Return micro-subroutine&lt;/span&gt;
IND  tmpB               &lt;span&gt;Move SP (in IND) to tmpB for ADD&lt;/span&gt;
  SP       RNI         &lt;span&gt;Put sum in Stack Pointer, end&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;One tricky part is that the &lt;code&gt;FARRET&lt;/code&gt; micro-subroutine examines bit 3 of the instruction to determine whether it does a near
return or a far return.
This is why documented instruction &lt;code&gt;C2&lt;/code&gt; is a near return and &lt;code&gt;CA&lt;/code&gt; is a far return.
Since &lt;code&gt;C0&lt;/code&gt; and &lt;code&gt;C8&lt;/code&gt; run the same microcode, they will perform the same actions, a near return and a far return respectively.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;C1&lt;/code&gt;: &lt;code&gt;RET&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The undocumented &lt;code&gt;C1&lt;/code&gt; opcode is identical to the documented &lt;code&gt;C3&lt;/code&gt;, near return instruction.
The microcode below is executed for instruction bits &lt;code&gt;110000?1&lt;/code&gt;, i.e. &lt;code&gt;C1&lt;/code&gt; and &lt;code&gt;C3&lt;/code&gt;.
The first micro-instruction reads from the Stack Pointer, incrementing &lt;code&gt;IND&lt;/code&gt; by 2.
Prefetching is suspended and the prefetch queue is flushed, since execution will continue at a new location.
The Program Counter is updated with the value from the stack, read into the &lt;code&gt;OPR&lt;/code&gt; register.
Finally, the updated address is put in the Stack Pointer and execution ends.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
SP  IND  R SS,P2  &lt;span&gt;&lt;b&gt;RET: &lt;/b&gt; Read from stack, increment by 2&lt;/span&gt;
          SUSP     &lt;span&gt;Suspend prefetching&lt;/span&gt;
OPR  PC  FLUSH    &lt;span&gt;Update PC from stack, flush prefetch queue&lt;/span&gt;
IND  SP  RNI      &lt;span&gt;Update SP, run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;C9&lt;/code&gt;: &lt;code&gt;RET&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The undocumented &lt;code&gt;C9&lt;/code&gt; opcode is identical to the documented &lt;code&gt;CB&lt;/code&gt;, far return instruction.
This microcode is executed for instruction bits &lt;code&gt;110010?1&lt;/code&gt;, i.e. &lt;code&gt;C9&lt;/code&gt; and &lt;code&gt;CB&lt;/code&gt;, so &lt;code&gt;C9&lt;/code&gt; is identical to &lt;code&gt;CB&lt;/code&gt;.
The microcode below simply calls the &lt;code&gt;FARRET&lt;/code&gt; micro-subroutine to pop the Program Counter and CS register.
Then the new value is stored into the Stack Pointer.
One subtlety is that &lt;code&gt;FARRET&lt;/code&gt; looks at bit 3 of the instruction to switch between a near return and a far return, as
described earlier.
Since &lt;code&gt;C9&lt;/code&gt; and &lt;code&gt;CB&lt;/code&gt; both have bit 3 set, they both perform a far return.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
          CALL FARRET  &lt;span&gt;&lt;b&gt;RETF:&lt;/b&gt; call FARRET routine&lt;/span&gt;
IND  SP  RNI          &lt;span&gt;Update stack pointer, run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;F1&lt;/code&gt;: &lt;code&gt;LOCK&lt;/code&gt; prefix&lt;/h3&gt;
&lt;p&gt;The final hole in the opcode table is &lt;code&gt;F1&lt;/code&gt;.
This opcode is different because it is implemented in logic rather than microcode.
The Group Decode ROM indicates that &lt;code&gt;F1&lt;/code&gt; is a prefix, one-byte logic, and LOCK.
The Group Decode outputs are the same as &lt;code&gt;F0&lt;/code&gt;, so &lt;code&gt;F1&lt;/code&gt; also acts as a &lt;code&gt;LOCK&lt;/code&gt; prefix.&lt;/p&gt;
&lt;h2&gt;Holes in two-byte opcodes&lt;/h2&gt;
&lt;p&gt;For most of the 8086 instructions, the first byte specifies the instruction.
However, the 8086 has a few instructions where the second byte specifies the instruction: the &lt;code&gt;reg&lt;/code&gt; field of the ModR/M byte provides an opcode extension that selects the instruction.&lt;span id=&quot;fnref:extension&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:extension&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
These fall into four categories which Intel labeled &quot;Immed&quot;, &quot;Shift&quot;, &quot;Group 1&quot;, and &quot;Group 2&quot;, corresponding to opcodes &lt;code&gt;80&lt;/code&gt;-&lt;code&gt;83&lt;/code&gt;, &lt;code&gt;D0&lt;/code&gt;-&lt;code&gt;D3&lt;/code&gt;,
&lt;code&gt;F6&lt;/code&gt;-&lt;code&gt;F7&lt;/code&gt;, and &lt;code&gt;FE&lt;/code&gt;-&lt;code&gt;FF&lt;/code&gt;.
The table below shows how the second byte selects the instruction.
Note that &quot;Shift&quot;, &quot;Group 1&quot;, and &quot;Group 2&quot; all have gaps, resulting in undocumented values.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-undoc/groups.jpg&quot;&gt;&lt;img alt=&quot;Meaning of the reg field in two-byte opcodes. From MCS-86 Assembly Language Reference Guide.&quot; class=&quot;hilite&quot; height=&quot;129&quot; src=&quot;https://static.righto.com/images/8086-ad-undoc/groups-w600.jpg&quot; title=&quot;Meaning of the reg field in two-byte opcodes. From MCS-86 Assembly Language Reference Guide.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Meaning of the reg field in two-byte opcodes. From &lt;a href=&quot;http://bitsavers.org/components/intel/8086/9800749-1_MCS-86_Assembly_Language_Reference_Guide_Oct78.pdf&quot;&gt;MCS-86 Assembly Language Reference Guide&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;These sets of instructions are implemented in two completely different ways.
The &quot;Immed&quot; and &quot;Shift&quot; instructions run microcode in the standard way, selected by the first byte.
For a typical arithmetic/logic instruction such as &lt;code&gt;ADD&lt;/code&gt;, bits 5-3 of the first instruction byte are latched into the &lt;code&gt;X&lt;/code&gt; register to indicate
which ALU operation to perform.
The microcode specifies a generic ALU operation, while the &lt;code&gt;X&lt;/code&gt; register controls whether the operation is an &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;SUB&lt;/code&gt;, &lt;code&gt;XOR&lt;/code&gt;, or
so forth.
However, the Group Decode ROM indicates that for the special &quot;Immed&quot; and &quot;Shift&quot; instructions, the &lt;code&gt;X&lt;/code&gt; register latches the bits
from the &lt;em&gt;second&lt;/em&gt; byte.
Thus, when the microcode executes a generic ALU operation, it ends up with the one specified in the second byte.&lt;span id=&quot;fnref:alu&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:alu&quot;&gt;6&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The &quot;Group 1&quot; and &quot;Group 2&quot; instructions (&lt;code&gt;F0&lt;/code&gt;-&lt;code&gt;F1&lt;/code&gt;, &lt;code&gt;FE&lt;/code&gt;-&lt;code&gt;FF&lt;/code&gt;), however, run different microcode for each instruction.
Bits 5-3 of the second byte replace bits 2-0 of the instruction before executing the microcode.
Thus, &lt;code&gt;F0&lt;/code&gt; and &lt;code&gt;F1&lt;/code&gt; act as if they are opcodes in the range &lt;code&gt;F0&lt;/code&gt;-&lt;code&gt;F7&lt;/code&gt;, while &lt;code&gt;FE&lt;/code&gt; and &lt;code&gt;FF&lt;/code&gt; act as if they are opcodes in the range &lt;code&gt;F8&lt;/code&gt;-&lt;code&gt;FF&lt;/code&gt;.
Thus, each instruction specified by the second byte can have its own microcode, unlike the &quot;Immed&quot; and &quot;Shift&quot; instructions.
The trick that makes this work is that all the &quot;real&quot; opcodes in the range &lt;code&gt;F0&lt;/code&gt;-&lt;code&gt;FF&lt;/code&gt; are implemented in logic, not microcode,
so there are no collisions.&lt;/p&gt;
&lt;h3&gt;The hole in &quot;Shift&quot;: &lt;code&gt;SETMO&lt;/code&gt;, &lt;code&gt;D0&lt;/code&gt;..&lt;code&gt;D3/6&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;There is a &quot;hole&quot; in the list of shift operations when the second byte has the bits &lt;code&gt;110&lt;/code&gt; (6).
(This is typically expressed as &lt;code&gt;D0/6&lt;/code&gt; and so forth; the value after the slash is the opcode-selection bits in the ModR/M byte.)
Internally, this value selects the ALU&#39;s &lt;code&gt;SETMO&lt;/code&gt; (Set Minus One) operation, which simply returns &lt;code&gt;FF&lt;/code&gt; or &lt;code&gt;FFFF&lt;/code&gt;, for a byte or word operation respectively.&lt;span id=&quot;fnref:setmo&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:setmo&quot;&gt;7&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The microcode below is executed for 1101000? bit patterns patterns (D0 and D1).
The first instruction gets the value from the &lt;code&gt;M&lt;/code&gt; register and sets up the ALU to do whatever operation was
specified in the instruction (indicated by &lt;code&gt;XI&lt;/code&gt;).
Thus, the same microcode is used for all the &quot;Shift&quot; instructions, including &lt;code&gt;SETMO&lt;/code&gt;.
The result is written back to &lt;code&gt;M&lt;/code&gt;. If no writeback to memory is required (&lt;code&gt;NWB&lt;/code&gt;), then &lt;code&gt;RNI&lt;/code&gt; runs the next instruction, ending
the microcode sequence.
However, if the result is going to memory, then the last line writes the value to memory.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
M  tmpB  XI tmpB, NXT  &lt;span&gt;&lt;b&gt;rot rm, 1&lt;/b&gt;: get argument, set up ALU&lt;/span&gt;
  M     NWB,RNI F     &lt;span&gt;Store result, maybe run next instruction&lt;/span&gt;
          W DS,P0 RNI   &lt;span&gt;Write result to memory&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;The D2 and D3 instructions (1101001?) perform a variable number of shifts, specified by the &lt;code&gt;CL&lt;/code&gt; register, so they use different microcode (below).
This microcode loops the number of times specified by &lt;code&gt;CL&lt;/code&gt;, but the control flow is a bit tricky to avoid shifting if
the intial counter value is 0.
The code sets up the ALU to pass the counter (in &lt;code&gt;tmpA&lt;/code&gt;) unmodified the first time (&lt;code&gt;PASS&lt;/code&gt;) and jumps to &lt;b&gt;4&lt;/b&gt;, which
updates the counter and sets up the ALU for the shift operation (&lt;code&gt;XI&lt;/code&gt;).
If the counter is not zero, it jumps back to &lt;b&gt;3&lt;/b&gt;, which performs the previously-specified shift and sets up
the ALU to decrement the counter (&lt;code&gt;DEC&lt;/code&gt;).
This time, the code at &lt;b&gt;4&lt;/b&gt; decrements the counter.
The loop continues until the counter reaches zero. The microcode stores the result as in the previous microcode.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
ZERO  tmpA               &lt;span&gt;&lt;b&gt;rot rm,CL&lt;/b&gt;: 0 to tmpA&lt;/span&gt;
CX  tmpAL   PASS tmpA    &lt;span&gt;Get count to tmpAL, set up ALU to pass through&lt;/span&gt;
M  tmpB     JMPS 4       &lt;span&gt;Get value, jump to loop (4)&lt;/span&gt;
  tmpB     DEC tmpA F   &lt;span&gt;&lt;b&gt;3&lt;/b&gt;: Update result, set up decrement of count&lt;/span&gt;
  tmpA     XI tmpB      &lt;span&gt;&lt;b&gt;4&lt;/b&gt;: update count in tmpA, set up ALU&lt;/span&gt;
             JMPS NZ 3    &lt;span&gt;Loop if count not zero&lt;/span&gt;
tmpB  M     NWB,RNI      &lt;span&gt;Store result, maybe run next instruction&lt;/span&gt;
             W DS,P0 RNI  &lt;span&gt;Write result to memory&lt;/span&gt;
&lt;/pre&gt;

&lt;h3&gt;The hole in &quot;group 1&quot;: &lt;code&gt;TEST&lt;/code&gt;, &lt;code&gt;F6/1&lt;/code&gt; and &lt;code&gt;F7/1&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;F6&lt;/code&gt; and &lt;code&gt;F7&lt;/code&gt; opcodes are in &quot;group 1&quot;, with the specific instruction specified by bits 5-3 of the second byte.
The second-byte table showed a hole for the &lt;code&gt;001&lt;/code&gt; bit sequence.
As explained earlier, these bits replace the low-order bits of the instruction, so &lt;code&gt;F6&lt;/code&gt; with 001 is processed as if it were
the opcode &lt;code&gt;F1&lt;/code&gt;.
The microcode below matches against instruction bits &lt;code&gt;1111000?&lt;/code&gt;, so &lt;code&gt;F6/1&lt;/code&gt; and &lt;code&gt;F7/1&lt;/code&gt; have the same effect as &lt;code&gt;F6/0&lt;/code&gt; and &lt;code&gt;F7/1&lt;/code&gt; respectively,
that is, the byte and word &lt;code&gt;TEST&lt;/code&gt; instructions.&lt;/p&gt;
&lt;p&gt;The microcode below gets one or two bytes from the prefetch queue (&lt;code&gt;Q&lt;/code&gt;); the &lt;code&gt;L8&lt;/code&gt; condition tests if the operation is
an 8-bit (i.e. byte) operation and skips the second micro-instruction.
The third micro-instruction ANDs the argument and the fetched value.
The condition flags (&lt;code&gt;F&lt;/code&gt;) are set based on the result, but the result itself is discarded.
Thus, the &lt;code&gt;TEST&lt;/code&gt; instruction tests a value against a mask, seeing if any bits are set.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
Q  tmpBL    JMPS L8 2     &lt;span&gt;&lt;b&gt;TEST rm,i:&lt;/b&gt; Get byte, jump if operation length = 8&lt;/span&gt;
Q  tmpBH                  &lt;span&gt;Get second byte from the prefetch queue&lt;/span&gt;
M  tmpA     AND tmpA, NXT &lt;span&gt;&lt;b&gt;2:&lt;/b&gt; Get argument, AND with fetched value&lt;/span&gt;
  no dest  RNI F         &lt;span&gt;Discard result but set flags.&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;I explained the processing of these &quot;Group 3&quot; instructions in more detail in my &lt;a href=&quot;https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html&quot;&gt;microcode article&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;The hole in &quot;group 2&quot;: &lt;code&gt;PUSH&lt;/code&gt;, &lt;code&gt;FE/7&lt;/code&gt; and &lt;code&gt;FF/7&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;FE&lt;/code&gt; and &lt;code&gt;FF&lt;/code&gt; opcodes are in &quot;group 2&quot;, which has a hole for the &lt;code&gt;111&lt;/code&gt; bit sequence in the second byte.
After replacement, this will be processed as the &lt;code&gt;FF&lt;/code&gt; opcode, which matches the pattern &lt;code&gt;1111111?&lt;/code&gt;.
In other words, the instruction will be processed the same as the &lt;code&gt;110&lt;/code&gt; bit pattern, which is &lt;code&gt;PUSH&lt;/code&gt;.
The microcode gets the Stack Pointer, sets up the ALU to decrement it by 2.
The new value is written to &lt;code&gt;SP&lt;/code&gt; and &lt;code&gt;IND&lt;/code&gt;. Finally, the register value is written to stack memory.&lt;/p&gt;
&lt;!--
For some reason, the [8086 undocumented instructions](https://en.wikipedia.org/wiki/X86_instruction_listings#Undocumented_x86_instructions) page on Wikipedia doesn&#39;t list FE-FF.
--&gt;

&lt;pre class=&quot;microcode&quot;&gt;
SP  tmpA  DEC2 tmpA   &lt;span&gt;&lt;b&gt;PUSH rm&lt;/b&gt;: set up decrement SP by 2&lt;/span&gt;
  IND                &lt;span&gt;Decremented SP to IND&lt;/span&gt;
  SP                 &lt;span&gt;Decremented SP to SP&lt;/span&gt;
M  OPR    W SS,P0 RNI &lt;span&gt;Write the value to memory, done&lt;/span&gt;
&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;82&lt;/code&gt; and &lt;code&gt;83&lt;/code&gt; &quot;Immed&quot; group&lt;/h3&gt;
&lt;p&gt;Opcodes &lt;code&gt;80&lt;/code&gt;-&lt;code&gt;83&lt;/code&gt; are the &quot;Immed&quot; group, performing one of eight arithmetic operations, specified in the ModR/M byte.
The four opcodes differ in the size of the values: opcode &lt;code&gt;80&lt;/code&gt; applies an 8-bit immediate value to an 8-bit register, &lt;code&gt;81&lt;/code&gt; applies a 16-bit
value to a 16-bit register, &lt;code&gt;82&lt;/code&gt; applies an 8-bit value to an 8-bit register, and &lt;code&gt;83&lt;/code&gt; applies an 8-bit value to a 16-bit register.
The opcode 82 has the strange situation that &lt;a href=&quot;https://en.wikipedia.org/wiki/X86_instruction_listings#Undocumented_instructions_that_are_widely_available_across_many_x86_CPUs_include&quot;&gt;some sources&lt;/a&gt; say it is undocumented, but it shows up in some Intel documentation as a valid bit combination (e.g. below).
Note that &lt;code&gt;80&lt;/code&gt; and &lt;code&gt;82&lt;/code&gt; have the  8-bit to 8-bit action, so the &lt;code&gt;82&lt;/code&gt; opcode is redundant.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-undoc/adc.png&quot;&gt;&lt;img alt=&quot;ADC is one of the instructions with opcode 80-83. From the 8086 datasheet, page 27.&quot; class=&quot;hilite&quot; height=&quot;34&quot; src=&quot;https://static.righto.com/images/8086-ad-undoc/adc-w600.png&quot; title=&quot;ADC is one of the instructions with opcode 80-83. From the 8086 datasheet, page 27.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;ADC is one of the instructions with opcode 80-83. From the &lt;a href=&quot;https://www.electro-tech-online.com/datasheets/8086_intel.pdf&quot;&gt;8086 datasheet&lt;/a&gt;, page 27.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The microcode below is used for all four opcodes.
If the ModR/M byte specifies memory, the appropriate micro-subroutine is called to compute the effective address in &lt;code&gt;IND&lt;/code&gt;,
and fetch the byte or word into &lt;code&gt;OPR&lt;/code&gt;.
The first two instructions below get the two immediate data bytes from the prefetch queue; for an 8-bit operation, the second byte
is skipped.
Next, the second argument &lt;code&gt;M&lt;/code&gt; is loaded into tmpA and the desired ALU operation (&lt;code&gt;XI&lt;/code&gt;) is configured.
The result &lt;code&gt;&lt;/code&gt; is stored into the specified register &lt;code&gt;M&lt;/code&gt; and the operation may terminate with &lt;code&gt;RNI&lt;/code&gt;.
But if the ModR/M byte specified memory, the following write micro-operation saves the value to memory.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
Q  tmpBL  JMPS L8 2    &lt;span&gt;&lt;b&gt;alu rm,i&lt;/b&gt;: get byte, test if 8-bit op&lt;/span&gt;
Q  tmpBH               &lt;span&gt;Maybe get second byte&lt;/span&gt;
M  tmpA   XI tmpA, NXT &lt;span&gt;&lt;b&gt;2&lt;/b&gt;: &lt;/span&gt;
  M      NWB,RNI F    &lt;span&gt;Save result, update flags, done if no memory writeback&lt;/span&gt;
           W DS,P0 RNI  &lt;span&gt;Write result to memory if needed&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;The tricky part of this is the &lt;code&gt;L8&lt;/code&gt; condition, which tests if the operation is 8-bit.
You might think that bit 0 acts as the byte/word bit in a nice, orthogonal way, but the 8086 has a bunch of special cases.
Bit 0 of the instruction typically selects between a byte and a word operation, but there are a bunch of special cases.
The Group Decode ROM creates a signal indicating if bit 0 should be used as the byte/word bit.
But it generates a second signal indicating that an instruction should be forced to operate on bytes, for instructions
such as &lt;code&gt;DAA&lt;/code&gt; and &lt;code&gt;XLAT&lt;/code&gt;.
Another Group Decode ROM signal indicates that bit 3 of the instruction should select byte or word; this
is used for the &lt;code&gt;MOV&lt;/code&gt; instructions with opcodes Bx.
Yet another Group Decode ROM signal indicates that inverted bit 1 of the instruction should select byte or word;
this is used for a few opcodes, including &lt;code&gt;80&lt;/code&gt;-&lt;code&gt;87&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The important thing here is that for the opcodes under discussion (&lt;code&gt;80&lt;/code&gt;-&lt;code&gt;83&lt;/code&gt;), the &lt;code&gt;L8&lt;/code&gt; micro-condition uses &lt;em&gt;both&lt;/em&gt; bits 0 and 1
to determine if the instruction is 8 bits or not.
The result is that only opcode &lt;code&gt;81&lt;/code&gt; is considered 16-bit by the &lt;code&gt;L8&lt;/code&gt; test, so it is the only one that uses two immediate bytes
from the instruction.
However, the register operations use only bit 0 to select a byte or word transfer.
The result is that opcode &lt;code&gt;83&lt;/code&gt; has the unusual behavior of using an 8-bit immediate operand with a 16-bit register.
In this case, the 8-bit value is sign-extended to form a 16-bit value. That is, the top bit of the 8-bit value fills
the entire upper half of the 16-bit value,
converting an 8-bit signed value to a 16-bit signed value (e.g. -1 is &lt;code&gt;FF&lt;/code&gt;, which becomes &lt;code&gt;FFFF&lt;/code&gt;).
This makes sense for arithmetic operations, but not much sense for logical operations.&lt;/p&gt;
&lt;p&gt;Intel documentation is inconsistent about which opcodes are listed for which instructions.
Intel opcode maps generally define opcodes &lt;code&gt;80&lt;/code&gt;-&lt;code&gt;83&lt;/code&gt;.
However, lists of specific instructions show opcodes &lt;code&gt;80&lt;/code&gt;, &lt;code&gt;81&lt;/code&gt;, and &lt;code&gt;83&lt;/code&gt; for arithmetic operations but only &lt;code&gt;80&lt;/code&gt; and &lt;code&gt;81&lt;/code&gt; for logical operations.&lt;span id=&quot;fnref:immed&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:immed&quot;&gt;8&lt;/a&gt;&lt;/span&gt;
That is, Intel omits the redundant &lt;code&gt;82&lt;/code&gt; opcode as well as omitting logic operations that perform sign-extension (&lt;code&gt;83&lt;/code&gt;).&lt;/p&gt;
&lt;h3&gt;More &lt;code&gt;FE&lt;/code&gt; holes&lt;/h3&gt;
&lt;p&gt;For the &quot;group 2&quot; instructions, the &lt;code&gt;FE&lt;/code&gt; opcode performs a byte operation while &lt;code&gt;FF&lt;/code&gt; performs a word operation.
Many of these operations don&#39;t make sense for bytes: &lt;code&gt;CALL&lt;/code&gt;, &lt;code&gt;JMP&lt;/code&gt;, and &lt;code&gt;PUSH&lt;/code&gt;.
(The only instructions supported for &lt;code&gt;FE&lt;/code&gt; are &lt;code&gt;INC&lt;/code&gt; and &lt;code&gt;DEC&lt;/code&gt;.) But what happens if you use the unsupported instructions?
The remainder of this section examines those cases and shows that the results are not useful.&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;CALL&lt;/code&gt;: &lt;code&gt;FE/2&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;This instruction performs an indirect subroutine call within a segment, reading the target address from the memory location specified by the ModR/M byte.&lt;/p&gt;
&lt;p&gt;The microcode below is a bit convoluted because the code falls through into the shared &lt;code&gt;NEARCALL&lt;/code&gt; routine, so there is
some unnecessary register movement.
Before this microcode executes, the appropriate ModR/M micro-subroutine will read the target address from memory.
The code below copies the destination address from &lt;code&gt;M&lt;/code&gt; to &lt;code&gt;tmpB&lt;/code&gt; and stores it into the PC later in the code
to transfer execution.
The code suspends prefetching, corrects the PC to cancel the offset from prefetching, and flushes the prefetch queue.
Finally, it decrements the SP by two and writes the old PC to the stack.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
M  tmpB    SUSP        &lt;span&gt;&lt;b&gt;CALL rm&lt;/b&gt;: read value, suspend prefetch&lt;/span&gt;
SP  IND    CORR        &lt;span&gt;Get SP, correct PC&lt;/span&gt;
PC  OPR    DEC2 tmpC   &lt;span&gt;Get PC to write, set up decrement&lt;/span&gt;
tmpB  PC   FLUSH       &lt;span&gt;&lt;b&gt;NEARCALL&lt;/b&gt;: Update PC, flush prefetch&lt;/span&gt;
IND  tmpC              &lt;span&gt;Get SP to decrement&lt;/span&gt;
  IND                 &lt;span&gt;Decremented SP to IND&lt;/span&gt;
  SP      W SS,P0 RNI &lt;span&gt;Update SP, write old PC to stack&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;This code will mess up in two ways when executed as a byte instruction.
First, when the destination address is read from memory, only a byte will be read, so the destination address will be corrupted.
(I think that the behavior here depends on the bus hardware. The 8086 will ask for a byte from memory but will
read the word that is placed on the bus.
Thus, if memory returns a word, this part may operate correctly.
The 8088&#39;s behavior will be different because of its 8-bit bus.)
The second issue is writing the old PC to the stack because only a byte of the PC will be written.
Thus, when the code returns from the subroutine call, the return address will be corrupt.&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;CALL&lt;/code&gt;: &lt;code&gt;FE/3&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;This instruction performs an indirect subroutine call between segments, reading the target address from the memory location specified by the ModR/M byte.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
IND  tmpC  INC2 tmpC    &lt;span&gt;&lt;b&gt;CALL FAR rm&lt;/b&gt;: set up IND+2&lt;/span&gt;
  IND     R DS,P0      &lt;span&gt;Read new CS, update IND&lt;/span&gt;
OPR  tmpA  DEC2 tmpC    &lt;span&gt;New CS to tmpA, set up SP-2&lt;/span&gt;
SP  tmpC   SUSP         &lt;span&gt;&lt;b&gt;FARCALL&lt;/b&gt;: Suspend prefetch&lt;/span&gt;
  IND     CORR         &lt;span&gt;&lt;b&gt;FARCALL2&lt;/b&gt;: Update IND, correct PC&lt;/span&gt;
CS  OPR    W SS,M2      &lt;span&gt;Push old CS, decrement IND by 2&lt;/span&gt;
tmpA  CS   PASS tmpC    &lt;span&gt;Update CS, set up for NEARCALL&lt;/span&gt;
PC  OPR    JMP NEARCALL &lt;span&gt;Continue with NEARCALL&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;As in the previous &lt;code&gt;CALL&lt;/code&gt;, this microcode will fail in multiple ways when executed in byte mode.
The new CS and PC addresses will be read from memory as bytes, which may or may not work.
Only a byte of the old CS and PC will be pushed to the stack.&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;JMP&lt;/code&gt;: &lt;code&gt;FE/4&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;This instruction performs an indirect jump within a segment, reading the target address from the memory location specified by the ModR/M byte.
The microcode is short, since the ModR/M micro-subroutine does most of the work.
I believe this will have the same problem as the previous &lt;code&gt;CALL&lt;/code&gt; instructions, that it will attempt to read a byte from
memory instead of a word.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
        SUSP       &lt;span&gt;&lt;b&gt;JMP rm&lt;/b&gt;: Suspend prefetch&lt;/span&gt;
M  PC  FLUSH RNI  &lt;span&gt;Update PC with new address, flush prefetch, done&lt;/span&gt;
&lt;/pre&gt;

&lt;h4&gt;&lt;code&gt;JMP&lt;/code&gt;: &lt;code&gt;FE/5&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;This instruction performs an indirect jump between segments, reading the new PC and CS values from the memory location specified by the ModR/M byte.
The ModR/M micro-subroutine reads the new PC address. This microcode increments &lt;code&gt;IND&lt;/code&gt; and suspends prefetching.
It updates the PC, reads the new CS value from memory, and updates the CS.
As before, the reads from memory will read bytes instead of words, so this code will not meaningfully work in byte mode.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
IND  tmpC  INC2 tmpC   &lt;span&gt;&lt;b&gt;JMP FAR rm&lt;/b&gt;: set up IND+2&lt;/span&gt;
  IND     SUSP        &lt;span&gt;Update IND, suspend prefetch&lt;/span&gt;
tmpB  PC   R DS,P0     &lt;span&gt;Update PC, read new CS from memory&lt;/span&gt;
OPR  CS    FLUSH RNI   &lt;span&gt;Update CS, flush prefetch, done&lt;/span&gt;
&lt;/pre&gt;

&lt;h4&gt;&lt;code&gt;PUSH&lt;/code&gt;: &lt;code&gt;FE/6&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;This instruction pushes the register or memory value specified by the ModR/M byte.
It decrements the SP by 2 and then writes the value to the stack.
It will write one byte to the stack but decrements the SP by 2,
so one byte of old stack data will be on the stack along with the data byte.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
SP  tmpA  DEC2 tmpA    &lt;span&gt;&lt;b&gt;PUSH rm&lt;/b&gt;: Set up SP decrement &lt;/span&gt;
  IND                 &lt;span&gt;Decremented value to IND&lt;/span&gt;
  SP                  &lt;span&gt;Decremented value to SP&lt;/span&gt;
M  OPR    W SS,P0 RNI  &lt;span&gt;Write the data to the stack&lt;/span&gt;
&lt;/pre&gt;

&lt;h2&gt;Undocumented instruction values&lt;/h2&gt;
&lt;p&gt;The next category of undocumented instructions is where the first byte indicates a valid instruction, but
there is something wrong with the second byte.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;AAM&lt;/code&gt;: ASCII Adjust after Multiply&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;AAM&lt;/code&gt; instruction is a fairly obscure one, designed to support binary-coded decimal
arithmetic (BCD).
After multiplying two BCD digits, you end up with a binary value between 0 and &lt;code&gt;81&lt;/code&gt; (0&amp;times;0 to 9&amp;times;9).
If you want a BCD result, the &lt;code&gt;AAM&lt;/code&gt; instruction converts this binary value to BCD, for instance splitting &lt;code&gt;81&lt;/code&gt; into the
decimal digits 8 and 1, where the upper digit is &lt;code&gt;81&lt;/code&gt; divided by &lt;code&gt;10&lt;/code&gt;, and the lower digit is &lt;code&gt;81&lt;/code&gt; modulo &lt;code&gt;10&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The interesting thing about &lt;code&gt;AAM&lt;/code&gt; is that the 2-byte instruction is &lt;code&gt;D4&lt;/code&gt; &lt;code&gt;0A&lt;/code&gt;. You might notice that hex &lt;code&gt;0A&lt;/code&gt; is &lt;code&gt;10&lt;/code&gt;, and this
is not a coincidence.
There wasn&#39;t an easy way to get the value &lt;code&gt;10&lt;/code&gt; in the microcode, so instead they made the instruction
provide that value in the second byte.
The undocumented (but well-known) part is that if you provide a value other than &lt;code&gt;10&lt;/code&gt;, the instruction will convert the binary input into
digits in that base. For example, if you provide 8 as the second byte, the instruction returns the value divided by 8
and the value modulo 8.&lt;/p&gt;
&lt;p&gt;The microcode for &lt;code&gt;AAM&lt;/code&gt;, below, sets up the registers.  calls
the &lt;code&gt;CORD&lt;/code&gt; (Core Division) micro-subroutine to perform the division,
and then puts the results into &lt;code&gt;AH&lt;/code&gt; and &lt;code&gt;AL&lt;/code&gt;.
In more detail, the &lt;code&gt;CORD&lt;/code&gt; routine divides &lt;code&gt;tmpA/tmpC&lt;/code&gt; by &lt;code&gt;tmpB&lt;/code&gt;, putting the &lt;em&gt;complement&lt;/em&gt; of the quotient in &lt;code&gt;tmpC&lt;/code&gt; and leaving the remainder in &lt;code&gt;tmpA&lt;/code&gt;.
(If you want to know how CORD works internally, see my &lt;a href=&quot;https://www.righto.com/2023/04/reverse-engineering-8086-divide-microcode.html&quot;&gt;division post&lt;/a&gt;.)
The important step is that the &lt;code&gt;AAM&lt;/code&gt; microcode gets the divisor from the prefetch queue (&lt;code&gt;Q&lt;/code&gt;).
After calling &lt;code&gt;CORD&lt;/code&gt;, it sets up the ALU to perform a 1&#39;s complement of &lt;code&gt;tmpC&lt;/code&gt; and puts the result (&lt;code&gt;&lt;/code&gt;) into &lt;code&gt;AH&lt;/code&gt;.
It sets up the ALU to pass &lt;code&gt;tmpA&lt;/code&gt; through unchanged, puts the result (&lt;code&gt;&lt;/code&gt;) into &lt;code&gt;AL&lt;/code&gt;, and updates the flags accordingly (&lt;code&gt;F&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
Q  tmpB                    &lt;span&gt;&lt;b&gt;AAM:&lt;/b&gt; Move byte from prefetch to tmpB&lt;/span&gt;
ZERO  tmpA                 &lt;span&gt;Move 0 to tmpA&lt;/span&gt;
AL  tmpC    CALL CORD      &lt;span&gt;Move AL to tmpC, call CORD.&lt;/span&gt;
             COM1 tmpC      &lt;span&gt;Set ALU to complement&lt;/span&gt;
  AH       PASS tmpA, NXT &lt;span&gt;Complement AL to AH&lt;/span&gt;
  AL       RNI F          &lt;span&gt;Pass tmpA through ALU to set flags&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;The interesting thing is why this code has undocumented behavior.
The 8086&#39;s microcode only has support for the constants 0 and all-1&#39;s (&lt;code&gt;FF&lt;/code&gt; or &lt;code&gt;FFFF&lt;/code&gt;), but the microcode needs to divide by &lt;code&gt;10&lt;/code&gt;.
One solution would be to implement an additional micro-instruction and more circuitry to provide the constant &lt;code&gt;10&lt;/code&gt;, but every
transistor was precious back then.
Instead, the designers took the approach of simply putting the number &lt;code&gt;10&lt;/code&gt; as the second byte of the instruction and loading the
constant from there.
Since the &lt;code&gt;AAM&lt;/code&gt; instruction is not used very much, making the instruction two bytes long wasn&#39;t much of a drawback.
But if you put a different number in the second byte, that&#39;s the divisor the microcode will use.
(Of course you could add circuitry to verify that the number is &lt;code&gt;10&lt;/code&gt;, but then the implementation is no longer simple.)&lt;/p&gt;
&lt;p&gt;Intel could have documented the full behavior, but that creates several problems.
First, Intel would be stuck supporting the full behavior into the future.
Second, there are corner cases to deal with, such as divide-by-zero.
Third, testing the chip would become harder because all these cases would need to be tested.
Fourth, the documentation would become long and confusing.
It&#39;s not surprising that Intel left the full behavior undocumented.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;AAD&lt;/code&gt;: ASCII Adjust before Division&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;AAD&lt;/code&gt; instruction is analogous to &lt;code&gt;AAM&lt;/code&gt; but used for BCD division.
In this case, you want to divide a two-digit BCD number by something, where the BCD digits are in &lt;code&gt;AH&lt;/code&gt; and &lt;code&gt;AL&lt;/code&gt;.
The &lt;code&gt;AAD&lt;/code&gt; instruction converts the two-digit BCD number to binary by computing &lt;code&gt;AH&lt;/code&gt;&amp;times;&lt;code&gt;10+AL&lt;/code&gt;, before you perform
the division.&lt;/p&gt;
&lt;p&gt;The microcode for &lt;code&gt;AAD&lt;/code&gt; is shown below. The microcode sets up the registers, calls the multiplication micro-subroutine
&lt;code&gt;CORX&lt;/code&gt; (Core Times), and
then puts the results in &lt;code&gt;AH&lt;/code&gt; and &lt;code&gt;AL&lt;/code&gt;.
In more detail, the multiplier comes from the instruction prefetch queue &lt;code&gt;Q&lt;/code&gt;.
The &lt;code&gt;CORX&lt;/code&gt; routine multiples &lt;code&gt;tmpC&lt;/code&gt; by &lt;code&gt;tmpB&lt;/code&gt;, putting the result in &lt;code&gt;tmpA/tmpC&lt;/code&gt;.
Then the microcode adds the low BCD digit (&lt;code&gt;AL&lt;/code&gt;) to the product (&lt;code&gt;tmpB + tmpC&lt;/code&gt;), putting the sum (&lt;code&gt;&lt;/code&gt;) into &lt;code&gt;AL&lt;/code&gt;,
clearing &lt;code&gt;AH&lt;/code&gt; and setting the status flags &lt;code&gt;F&lt;/code&gt; appropriately.&lt;/p&gt;
&lt;p&gt;One interesting thing is that the second-last micro-instruction jumps to &lt;code&gt;AAEND&lt;/code&gt;, which is the last
micro-instruction of the &lt;code&gt;AAM&lt;/code&gt; microcode above.
By reusing the micro-instruction from &lt;code&gt;AAM&lt;/code&gt;, the microcode is one micro-instruction shorter, but
the jump adds one cycle to the execution time.
(The CORX routine is used for integer multiplication; I discuss the internals in &lt;a href=&quot;https://www.righto.com/2023/03/8086-multiplication-microcode.html&quot;&gt;this post&lt;/a&gt;.)&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
Q  tmpC              &lt;span&gt;&lt;b&gt;AAD:&lt;/b&gt; Get byte from prefetch queue.&lt;/span&gt;
AH  tmpB   CALL CORX &lt;span&gt;Call CORX&lt;/span&gt;
AL  tmpB   ADD tmpC  &lt;span&gt;Set ALU for ADD&lt;/span&gt;
ZERO  AH   JMP AAEND &lt;span&gt;Zero AH, jump to AAEND&lt;/span&gt;
i
...
  AL      RNI F     &lt;span&gt;&lt;b&gt;AAEND:&lt;/b&gt; Sum to AL, done.&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;As with &lt;code&gt;AAM&lt;/code&gt;, the constant &lt;code&gt;10&lt;/code&gt; is provided in the second byte of the instruction.
The microcode accepts any value here, but values other than &lt;code&gt;10&lt;/code&gt; are undocumented.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;8C&lt;/code&gt;, &lt;code&gt;8E&lt;/code&gt;: MOV sr&lt;/h3&gt;
&lt;p&gt;The opcodes &lt;code&gt;8C&lt;/code&gt; and &lt;code&gt;8E&lt;/code&gt; perform a &lt;code&gt;MOV&lt;/code&gt; register to or from the specified segment register, using the register specification
field in the ModR/M byte.
There are four segment registers and three selection bits, so an invalid segment register can be specified.
However, the hardware that decodes the register number ignores instruction bit 5 for a segment register. Thus,
specifying a segment register 4 to 7 is the same as specifying a segment register 0 to 3.
For more details, see my article on &lt;a href=&quot;https://www.righto.com/2023/03/8086-register-codes.html&quot;&gt;8086 register codes&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Unexpected &lt;code&gt;REP&lt;/code&gt; prefix&lt;/h2&gt;
&lt;h3&gt;&lt;code&gt;REP IMUL&lt;/code&gt; / &lt;code&gt;IDIV&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;REP&lt;/code&gt; prefix is used with string operations to cause the operation to be repeated across a block of memory.
However, if you use this prefix with an &lt;code&gt;IMUL&lt;/code&gt; or &lt;code&gt;IDIV&lt;/code&gt; instruction, it has the unexpected behavior
of negating the product or the quotient (&lt;a href=&quot;https://www.reenigne.org/blog/8086-microcode-disassembled/&quot;&gt;source&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The reason for this behavior is that the string operations use an internal flag called &lt;code&gt;F1&lt;/code&gt; to indicate that a &lt;code&gt;REP&lt;/code&gt;
prefix has been applied.
The multiply and divide code reuses this flag to track the sign of the input values, toggling &lt;code&gt;F1&lt;/code&gt; for each negative value.
If &lt;code&gt;F1&lt;/code&gt; is set, the value at the end is negated. (This handles &quot;two negatives make a positive.&quot;)
The consequence is that the &lt;code&gt;REP&lt;/code&gt; prefix puts the flag in the 1 state when the multiply/divide starts, so the computed sign
will be wrong at the end and the result is the negative of the expected result.
The microcode is fairly complex, so I won&#39;t show it here; I explain it in detail in &lt;a href=&quot;https://www.righto.com/2023/03/8086-multiplication-microcode.html&quot;&gt;this blog post&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;REP RET&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/X86_instruction_listings#Undocumented_x86_instructions&quot;&gt;Wikipedia&lt;/a&gt; lists
&lt;code&gt;REP RET&lt;/code&gt; (i.e. &lt;code&gt;RET&lt;/code&gt; with a &lt;code&gt;REP&lt;/code&gt; prefix) as a way to implement a two-byte return instruction.
This is kind of trivial; the &lt;code&gt;RET&lt;/code&gt; microcode (like almost every instruction) doesn&#39;t use the &lt;code&gt;F1&lt;/code&gt; internal flag,
so the &lt;code&gt;REP&lt;/code&gt; prefix has no effect.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;REPNZ MOVS/STOS&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/X86_instruction_listings#Undocumented_x86_instructions&quot;&gt;Wikipedia&lt;/a&gt; mentions that
the use of the &lt;code&gt;REPNZ&lt;/code&gt; prefix (as opposed to &lt;code&gt;REPZ&lt;/code&gt;) is undefined with string operations other than &lt;code&gt;CMPS/SCAS&lt;/code&gt;.
An internal flag called &lt;code&gt;F1Z&lt;/code&gt; distinguishes between the &lt;code&gt;REPZ&lt;/code&gt; and &lt;code&gt;REPNZ&lt;/code&gt; prefixes.
This flag is only used by &lt;code&gt;CMPS/SCAS&lt;/code&gt;. Since the other string instructions ignore this flag, they will ignore the
difference between &lt;code&gt;REPZ&lt;/code&gt; and &lt;code&gt;REPNZ&lt;/code&gt;.
I wrote about string operations in more detail in &lt;a href=&quot;https://www.righto.com/2023/04/8086-microcode-string-operations.html&quot;&gt;this post&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Using a register instead of memory.&lt;/h2&gt;
&lt;p&gt;Some instructions are documented as requiring a memory operand. However, the ModR/M byte can specify a register.
The behavior in these cases can be highly unusual, providing access to hidden registers.
Examining the microcode shows how this happens.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;LEA reg&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Many instructions have a ModR/M byte that indicates the memory address that the instruction should use, perhaps through
a complicated addressing mode.
The &lt;code&gt;LEA&lt;/code&gt; (Load Effective Address) instruction is different: it doesn&#39;t access the memory location but returns the address itself.
The undocumented part is that the ModR/M byte can specify a register instead of a memory location. In that case,
what does the &lt;code&gt;LEA&lt;/code&gt; instruction do? Obviously it can&#39;t return the address of a register, but it needs to return something.&lt;/p&gt;
&lt;p&gt;The behavior of &lt;code&gt;LEA&lt;/code&gt; is explained by how the 8086 handles the ModR/M byte.
Before running the microcode corresponding to the instruction, the microcode engine calls a short micro-subroutine
for the particular addressing mode.
This micro-subroutine puts the desired memory address (the effective address) into the &lt;code&gt;tmpA&lt;/code&gt; register.
The effective address is copied to the &lt;code&gt;IND&lt;/code&gt; (Indirect) register and the value is loaded from memory if needed.
On the other hand, if the ModR/M byte specified a register instead of memory, no micro-subroutine is called.
(I explain ModR/M handling in more detail in &lt;a href=&quot;https://www.righto.com/2023/02/8086-modrm-addressing.html&quot;&gt;this article&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;The microcode for &lt;code&gt;LEA&lt;/code&gt; itself is just one line. It stores the effective address in the &lt;code&gt;IND&lt;/code&gt; register into the specified destination register, indicated by &lt;code&gt;N&lt;/code&gt;.
This assumes that the appropriate ModR/M micro-subroutine was called before this code, putting the effective address into &lt;code&gt;IND&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
IND  N   RNI  &lt;span&gt;&lt;b&gt;LEA&lt;/b&gt;: store IND register in destination, done&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;But if a register was specified instead of a memory location, no ModR/M micro-subroutine gets called.
Instead, the &lt;code&gt;LEA&lt;/code&gt; instruction will return whatever value was left
in &lt;code&gt;IND&lt;/code&gt; from before, typically the previous memory location that was accessed.
Thus, &lt;code&gt;LEA&lt;/code&gt; can be used to read the value of the &lt;code&gt;IND&lt;/code&gt; register, which is normally hidden from the programmer.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;LDS reg&lt;/code&gt;, &lt;code&gt;LES reg&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;LDS&lt;/code&gt; and &lt;code&gt;LES&lt;/code&gt; instructions load a far pointer from memory into the specified segment register and general-purpose register.
The microcode below assumes that the appropriate ModR/M micro-subroutine has set up &lt;code&gt;IND&lt;/code&gt; and read the first value into &lt;code&gt;OPR&lt;/code&gt;.
The microcode updates the destination register, increments &lt;code&gt;IND&lt;/code&gt; by 2, reads the next value, and updates &lt;code&gt;DS&lt;/code&gt;.
(The microcode for &lt;code&gt;LES&lt;/code&gt; is a copy of this, but updates &lt;code&gt;ES&lt;/code&gt;.)&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
OPR  N               &lt;span&gt;&lt;b&gt;LDS&lt;/b&gt;: Copy OPR to dest register&lt;/span&gt;
IND  tmpC  INC2 tmpC &lt;span&gt;Set up incrementing IND by 2&lt;/span&gt;
  IND     R DS,P0   &lt;span&gt;Update IND, read next location&lt;/span&gt;
OPR  DS    RNI       &lt;span&gt;Update DS&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;If the &lt;code&gt;LDS&lt;/code&gt; instruction specifies a register instead of memory, a micro-subroutine will not be called, so &lt;code&gt;IND&lt;/code&gt; and &lt;code&gt;OPR&lt;/code&gt;
will have values from a previous instruction.
&lt;code&gt;OPR&lt;/code&gt; will be stored in the destination register, while the &lt;code&gt;DS&lt;/code&gt; value will be read from the address &lt;code&gt;IND+2&lt;/code&gt;.
Thus, these instructions provide a mechanism to access the hidden &lt;code&gt;OPR&lt;/code&gt; register.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;JMP FAR rm&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;JMP FAR rm&lt;/code&gt; instruction normally jumps to the far address stored in memory at the location indicated by the ModR/M byte.
(That is, the ModR/M byte indicates where the new PC and CS values are stored.)
But, as with &lt;code&gt;LEA&lt;/code&gt;, the behavior is undocumented if the ModR/M byte specifies a register, since a register doesn&#39;t hold
a four-byte value.&lt;/p&gt;
&lt;p&gt;The microcode explains what happens.
As with &lt;code&gt;LEA&lt;/code&gt;, the code expects a micro-subroutine to put the address into the &lt;code&gt;IND&lt;/code&gt; register.
In this case, the micro-subroutine also loads the value at that address (i.e. the destination &lt;code&gt;PC&lt;/code&gt;) into tmpB.
The microcode increments &lt;code&gt;IND&lt;/code&gt; by 2 to point to the &lt;code&gt;CS&lt;/code&gt; word in memory and reads that into &lt;code&gt;CS&lt;/code&gt;.
Meanwhile, it updates the &lt;code&gt;PC&lt;/code&gt; with &lt;code&gt;tmpB&lt;/code&gt;.
It suspends prefetching and flushes the queue, so instruction fetching will restart at the new address.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
IND  tmpC  INC2 tmpC   &lt;span&gt;&lt;b&gt;JMP FAR rm&lt;/b&gt;: set up to add 2 to IND&lt;/span&gt;
  IND     SUSP        &lt;span&gt;Update IND, suspend prefetching&lt;/span&gt;
tmpB  PC   R DS,P0     &lt;span&gt;Update PC with tmpB. Read new CS from specified address&lt;/span&gt;
OPR  CS    FLUSH RNI   &lt;span&gt;Update CS, flush queue, done&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;If you specify a register instead of memory, the micro-subroutine won&#39;t get called.
Instead, the program counter will be loaded with whatever value was in &lt;code&gt;tmpB&lt;/code&gt; and the &lt;code&gt;CS&lt;/code&gt; segment register will
be loaded from the memory location two bytes after the location that &lt;code&gt;IND&lt;/code&gt; was referencing.
Thus, this undocumented use of the instruction gives access to the otherwise-hidden &lt;code&gt;tmpB&lt;/code&gt; register.&lt;/p&gt;
&lt;h2&gt;The end of undocumented instructions&lt;/h2&gt;
&lt;p&gt;Microprocessor manufacturers soon realized that undocumented instructions were a problem, since
programmers find them and often use them.
This creates an issue for future processors, or even revisions of the current processor:
if you eliminate an undocumented instruction, previously-working code that used the instruction will break,
and it will seem like the new processor is faulty.&lt;/p&gt;
&lt;p&gt;The solution was for processors to detect undocumented instructions and prevent them from executing.
By the early 1980s, processors had enough transistors (thanks to Moore&#39;s law) that they could include
the circuitry to block unsupported instructions.
In particular, the 80186/80188 and the 80286 generated a trap of type 6 when an unused opcode was executed,
blocking use of the instruction.&lt;span id=&quot;fnref:186&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:186&quot;&gt;9&lt;/a&gt;&lt;/span&gt;
This trap is also known as #UD (Undefined instruction trap).&lt;span id=&quot;fnref:fault&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:fault&quot;&gt;10&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The 8086, like many early microprocessors, has undocumented instructions but no traps to stop them from executing.&lt;span id=&quot;fnref:references&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:references&quot;&gt;11&lt;/a&gt;&lt;/span&gt;
For the 8086, these fall into several categories.
Many undocumented instructions simply mirror existing instructions.
Some instructions are implemented but not documented for one reason or another, such as &lt;code&gt;SALC&lt;/code&gt; and &lt;code&gt;POP CS&lt;/code&gt;.
Other instructions can be used outside their normal range, such as &lt;code&gt;AAM&lt;/code&gt; and &lt;code&gt;AAD&lt;/code&gt;.
Some instructions are intended to work only with a memory address, so specifying a register can have
strange effects such as revealing the values of the hidden &lt;code&gt;IND&lt;/code&gt; and &lt;code&gt;OPR&lt;/code&gt; registers.&lt;/p&gt;
&lt;p&gt;Keep in mind that my analysis is based on transistor-level simulation and examining the microcode; I haven&#39;t verified the behavior on a
physical 8086 processor. Please let me know if you see any errors in my analysis or undocumented instructions that I have
overlooked.
Also note that the behavior could change between different versions of the 8086; in particular, some versions by different manufacturers
(such as the NEC V20 and V30) are known to be different.&lt;/p&gt;
&lt;p&gt;I plan to write more about the 8086, so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@kenshirriff@oldbytes.space&lt;/a&gt;
and Bluesky as &lt;a href=&quot;https://staging.bsky.app/profile/righto.com&quot;&gt;@righto.com&lt;/a&gt; so you can follow me there too.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:6502&quot;&gt;
&lt;p&gt;The 6502 processor, for instance, has illegal instructions with various effects, including causing the processor to hang.
The article &lt;a href=&quot;https://www.pagetable.com/?p=39&quot;&gt;How MOS 6502 illegal opcodes really work&lt;/a&gt; describes in detail
how the instruction decoding results in various illegal opcodes. Some of these opcodes put the internal bus into a floating
state, so the behavior is electrically unpredictable.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:6502&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:prefixes&quot;&gt;
&lt;p&gt;The 8086 used up almost all the single-byte opcodes, which made it difficult to extend the instruction set.
   Most of the new instructions for the 386 or later are multi-byte opcodes, either using &lt;code&gt;0F&lt;/code&gt; as a prefix or
   reusing the earlier REP prefix (&lt;code&gt;F3&lt;/code&gt;).
   Thus, the x86 instruction set is less efficient than it could be, since many single-byte opcodes were &quot;wasted&quot;
   on hardly-used instructions such as BCD arithmetic, forcing newer instructions to be multi-byte.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:prefixes&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:magic-instruction&quot;&gt;
&lt;p&gt;For details on the &quot;magic instruction&quot; hidden in the 8086 microcode, see &lt;a href=&quot;https://digitalcommons.law.scu.edu/cgi/viewcontent.cgi?referer=&amp;amp;httpsredir=1&amp;amp;article=1031&amp;amp;context=chtlj&quot;&gt;NEC v. Intel: Will Hardware Be Drawn into the
Black Hole of Copyright Editors&lt;/a&gt; page 49.
I haven&#39;t found anything stating that &lt;code&gt;SALC&lt;/code&gt; was the hidden instruction, but this is the only undocumented instruction that
makes sense as something deliberately put into the microcode.
The court case is complicated since NEC had a licensing agreement with Intel, so I&#39;m skipping lots of details.
See &lt;a href=&quot;http://jolt.law.harvard.edu/articles/pdf/v03/03HarvJLTech209.pdf&quot;&gt;NEC v. Intel: Breaking new ground in the law of copyright&lt;/a&gt; for more.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:magic-instruction&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:microcode&quot;&gt;
&lt;p&gt;The microcode listings are based on Andrew Jenner&#39;s &lt;a href=&quot;https://www.reenigne.org/blog/8086-microcode-disassembled/&quot;&gt;disassembly&lt;/a&gt;.
I have made some modifications to (hopefully) make it easier to understand.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:microcode&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:extension&quot;&gt;
&lt;p&gt;Specifying the instruction through the ModR/M reg field may seem a bit random, but there&#39;s a reason for this.
A typical instruction such as &lt;code&gt;ADD&lt;/code&gt; has two arguments specified by the ModR/M byte.
But other instructions such as shift instructions or &lt;code&gt;NOT&lt;/code&gt; only take one argument.
For these instructions, the ModR/M &lt;code&gt;reg&lt;/code&gt; field would be wasted if it specified a register.
Thus, using the &lt;code&gt;reg&lt;/code&gt; field to specify instructions that only use one argument makes the instruction set more efficient.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:extension&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:alu&quot;&gt;
&lt;p&gt;Note that &quot;normal&quot; ALU operations are specified by bits 5-3 of the instruction; in order these are &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, &lt;code&gt;ADC&lt;/code&gt;, &lt;code&gt;SBB&lt;/code&gt;, &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;SUB&lt;/code&gt;, &lt;code&gt;XOR&lt;/code&gt;,
and &lt;code&gt;CMP&lt;/code&gt;.
These are exactly the same ALU operations that the &quot;Immed&quot; group performs, specified by bits 5-3 of the second byte.
This illustrates how the same operation selection mechanism (the &lt;code&gt;X&lt;/code&gt; register) is used in both cases.
Bit 6 of the instruction switches between the set of arithmetic/logic instructions and the set of shift/rotate instructions.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:alu&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:setmo&quot;&gt;
&lt;p&gt;As far as I can tell, SETMO isn&#39;t used by the microcode.
Thus, I think that SETMO wasn&#39;t deliberately implemented in the ALU,
but is a consequence of how the ALU&#39;s control logic is implemented.
That is, all the even entries are left shifts and the odd entries are right shifts, so operation 6 activates the
left-shift circuitry. But it doesn&#39;t match a specific left shift operation, so the ALU doesn&#39;t get configured for a
&quot;real&quot; left shift.
In other words, the behavior of this instruction is due to how the ALU handles a case that it wasn&#39;t specifically designed
to handle.&lt;/p&gt;
&lt;p&gt;This function is implemented in the ALU somewhat similar to a shift left.
However, instead of passing each input bit to the left, the bit from the right is passed to the left.
That is, the input to bit 0 is shifted left to all of the bits of the result.
By setting this bit to 1, all bits of the result are set, yielding the minus 1 result.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:setmo&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:immed&quot;&gt;
&lt;p&gt;This footnote provides some references for the &quot;Immed&quot; opcodes.
The &lt;a href=&quot;https://www.electro-tech-online.com/datasheets/8086_intel.pdf&quot;&gt;8086 datasheet&lt;/a&gt;
has an opcode map showing opcodes &lt;code&gt;80&lt;/code&gt; through &lt;code&gt;83&lt;/code&gt; as valid.
However, in the listings of individual instructions it only shows &lt;code&gt;80&lt;/code&gt; and &lt;code&gt;81&lt;/code&gt; for logical instructions (i.e. bit 1 must be 0),
while it shows &lt;code&gt;80&lt;/code&gt;-&lt;code&gt;83&lt;/code&gt; for arithmetic instructions.
The modern &lt;a href=&quot;https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html&quot;&gt;Intel 64 and IA-32 Architectures Software Developer&#39;s Manual&lt;/a&gt; is also contradictory.
Looking at the instruction reference for &lt;code&gt;AND&lt;/code&gt; (Vol &lt;code&gt;2A&lt;/code&gt; 3-&lt;code&gt;78&lt;/code&gt;), for instance,
shows opcodes &lt;code&gt;80&lt;/code&gt;, &lt;code&gt;81&lt;/code&gt;, and &lt;code&gt;83&lt;/code&gt;, explicitly labeling &lt;code&gt;83&lt;/code&gt; as sign-extended.
But the opcode map (Table A-2 Vol &lt;code&gt;2D&lt;/code&gt; A-7) shows &lt;code&gt;80&lt;/code&gt;-&lt;code&gt;83&lt;/code&gt; as defined except for &lt;code&gt;82&lt;/code&gt; in &lt;code&gt;64&lt;/code&gt;-bit mode.
The instruction bit diagram (Table B-&lt;code&gt;13&lt;/code&gt; Vol &lt;code&gt;2D&lt;/code&gt; B-7) shows &lt;code&gt;80&lt;/code&gt;-&lt;code&gt;83&lt;/code&gt; valid for the arithmetic and logical instructions.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:immed&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:186&quot;&gt;
&lt;p&gt;The 80286 was more thorough about detecting undefined opcodes than the 80186, even taking into account the 
differences in instruction set.
The 80186 generates a trap when &lt;code&gt;0F&lt;/code&gt;, &lt;code&gt;63&lt;/code&gt;-&lt;code&gt;67&lt;/code&gt;, &lt;code&gt;F1&lt;/code&gt;, or &lt;code&gt;FFFF&lt;/code&gt; is executed.
The 80286 generates invalid opcode exception number 6 (#UD) on any undefined opcode, handling the following cases:
&lt;ul&gt;
&lt;li&gt; The first byte of an instruction is completely invalid (e.g., 64H).
&lt;li&gt; The first byte indicates a 2-byte opcode and the second byte is invalid (e.g., 0F followed by
0FFH).
&lt;li&gt; An invalid register is used with an otherwise valid opcode (e.g., MOV CS,AX).
&lt;li&gt; An invalid opcode extension is given in the REG field of the ModR/M byte (e.g., 0F6H /1).
&lt;li&gt; A register operand is given in an instruction that requires a memory operand (e.g., LGDT AX).
&lt;/ul&gt;
&lt;!-- http://www.bitsavers.org/components/intel/80186/210911-001_iAPX86_88_186_188_Programmers_Reference_1983.pdf page 5-3 --&gt;
&lt;!-- page B-11 of http://bitsavers.trailing-edge.com/components/intel/80286/210498-005_80286_and_80287_Programmers_Reference_Manual_1987.pdf --&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:186&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:fault&quot;&gt;
&lt;p&gt;In modern x86 processors, most undocumented instructions cause faults. However, there are still a few undocumented instructions
that don&#39;t fault.
These may be for internal use or corner cases of documented instructions.
For details, see &lt;a href=&quot;https://www.youtube.com/watch?v=KrksBdWcZgQ&quot;&gt;Breaking the x86 Instruction Set&lt;/a&gt;, a video from Black Hat 2017.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:fault&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:references&quot;&gt;
&lt;p&gt;Several sources have discussed undocumented 8086 opcodes before.
The article &lt;a href=&quot;https://www.os2museum.com/wp/undocumented-8086-opcodes-part-i/&quot;&gt;Undocumented 8086 Opcodes&lt;/a&gt; describes undocumented opcodes in detail.
&lt;a href=&quot;https://en.wikipedia.org/wiki/X86_instruction_listings#Undocumented_x86_instructions&quot;&gt;Wikipedia&lt;/a&gt; has a list of
undocumented x86 instructions.
The book &lt;a href=&quot;https://archive.org/details/undocumentedpc0000vang/page/58/mode/2up?view=theater&quot;&gt;Undocumented PC&lt;/a&gt; discusses
undocumented instructions in the 8086 and later processors.
This &lt;a href=&quot;https://retrocomputing.stackexchange.com/questions/20031/undocumented-instructions-in-x86-cpu-prior-to-80386&quot;&gt;StackExchange Retrocomputing&lt;/a&gt; post describes undocumented instructions.
These &lt;a href=&quot;https://news.ycombinator.com/item?id=34960243&quot;&gt;Hacker News comments&lt;/a&gt; discuss some undocumented instructions.
There are other sources with more myth than fact, claiming that the 8086 treats undocumented instructions as NOPs, for instance.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:references&quot; title=&quot;Jump back to footnote 11 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/5516205124640022120/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=5516205124640022120' title='15 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/5516205124640022120'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/5516205124640022120'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/07/undocumented-8086-instructions.html' title='Undocumented 8086 instructions, explained by the microcode'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>15</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-2795813864611579036</id><published>2023-07-08T09:14:00.002-07:00</published><updated>2023-07-08T11:57:20.328-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="electronics"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>Reverse-engineering the 8086 processor&#39;s address and data pin circuits</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;

&lt;p&gt;The Intel 8086 microprocessor (1978) started the x86 architecture that continues to this day.
In this blog post, I&#39;m focusing on a small part of the chip: the address and data pins that connect the chip to
external memory and I/O devices.
In many processors, this circuitry is straightforward, but it is complicated in the 8086 for two reasons.
First, Intel decided to package the 8086 as a 40-pin DIP, which didn&#39;t provide enough pins for all the functionality.
Instead, the 8086 multiplexes address, data, and status.
In other words, a pin can have multiple roles, providing an address bit at one time and a data bit at another time.&lt;/p&gt;
&lt;p&gt;The second complication is that the 8086 has a 20-bit address space (due to its infamous segment registers), while the
data bus is 16 bits wide.
As will be seen, the &quot;extra&quot; four address bits have more impact than you might expect.
To summarize, 16 pins, called AD0-AD15, provide 16 bits of address and data.
The four remaining address pins (A16-A19) are multiplexed for use as status pins,
providing information about what the processor is doing for use by other parts of the system.
You might expect that the 8086 would thus have two types of pin circuits, but it turns out that there are four
distinct circuits, which I will discuss below.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under the microscope, with the main functional blocks and address pins labeled. Click this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;623&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/die-labeled-w700.jpg&quot; title=&quot;The 8086 die under the microscope, with the main functional blocks and address pins labeled. Click this image (or any other) for a larger version.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under the microscope, with the main functional blocks and address pins labeled. Click this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The microscope image above shows the silicon die of the 8086.
In this image, the metal layer on top of the chip is visible, while the silicon and polysilicon underneath are obscured.
The square pads around the edge of the die are connected by tiny bond wires to the chip&#39;s 40 external pins.
The 20 address pins are labeled: Pins AD0 through AD15 function as
address and data pins. Pins A16 through A19 function as address pins and status pins.&lt;span id=&quot;fnref:ad&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:ad&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
The circuitry that controls the pins is highlighted in red.
Two internal busses are important for this discussion: the 20-bit AD bus (green) connects the AD pins to the rest of the CPU,
while the 16-bit C bus (blue) communicates with the registers.
These buses are connected through a circuit that can swap the byte order or shift the value.
(The lines on the diagram are simplified; the real wiring twists and turns to fit the layout.
Moreover, the C bus (blue) has its bits spread across the width of the register file.)&lt;/p&gt;
&lt;h2&gt;Segment addressing in the 8086&lt;/h2&gt;
&lt;p&gt;One goal of the 8086 design was to maintain backward compatibility with the earlier 8080 processor.&lt;span id=&quot;fnref:compatibility&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:compatibility&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
This had a major impact on the 8086&#39;s memory design, resulting in the much-hated segment registers.
The 8080 (like most of the 8-bit processors of the early 1970s) had a 16-bit address space, able to access 64K (65,536 bytes) of memory,
which was plenty at the time.
But due to the exponential growth in memory capacity described by Moore&#39;s Law, it was clear that the 8086 needed to
support much more. Intel decided on a 1-megabyte address space, requiring 20 address bits.
But Intel wanted to keep the 16-bit memory addresses used by the 8080.&lt;/p&gt;
&lt;p&gt;The solution was to break memory into segments. Each segment was 64K long, so a 16-bit offset was sufficient to access memory
in a segment.
The segments were allocated in a 1-megabyte address space, with the result that you could access a megabyte of memory, but
only in 64K chunks.&lt;span id=&quot;fnref:pointers&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:pointers&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
Segment addresses were also 16 bits, but were shifted left by 4 bits (multiplied by 16) to support the 20-bit address space.&lt;/p&gt;
&lt;p&gt;Thus, every memory access in the 8086 required a computation of the physical address.
The diagram below illustrates this process: the logical address consists of the segment base address and the offset within the segment.
The 16-bit segment register was shifted 4 bits and added to the 16-bit offset to yield the 20-bit physical memory address.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/physical-address-generation.jpg&quot;&gt;&lt;img alt=&quot;The segment register and the offset are added to create a 20-bit physical address.  From iAPX 86,88 User&#39;s Manual, page 2-13.&quot; class=&quot;hilite&quot; height=&quot;260&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/physical-address-generation-w500.jpg&quot; title=&quot;The segment register and the offset are added to create a 20-bit physical address.  From iAPX 86,88 User&#39;s Manual, page 2-13.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The segment register and the offset are added to create a 20-bit physical address.  From &lt;a href=&quot;http://www.bitsavers.org/components/intel/_dataBooks/1981_iAPX_86_88_Users_Manual.pdf&quot;&gt;iAPX 86,88 User&#39;s Manual&lt;/a&gt;, page 2-13.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;This address computation was not performed by the regular ALU (Arithmetic/Logic Unit), but by a separate adder that
was devoted to address computation.
The address adder is visible in the upper-left corner of the die photo.
I will discuss the address adder in more detail below.&lt;/p&gt;
&lt;h2&gt;The AD bus and the C Bus&lt;/h2&gt;
&lt;p&gt;The 8086 has multiple internal buses to move bits internally, but the relevant ones are the AD bus and the C bus.
The AD bus is a 20-bit bus that connects the 20 address/data pins to the internal circuitry.&lt;span id=&quot;fnref:patent&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:patent&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
A 16-bit bus called the C bus provides the connection between
the AD bus, the address adder and some of the registers.&lt;span id=&quot;fnref:registers&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:registers&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
The diagram below shows the connections.
The AD bus can be connected to the 20 address pins through latches. The low 16 pins can also be used for data input, while the upper 4 pins
can also be used for status output.
The address adder performs the 16-bit addition necessary for segment arithmetic. Its output is shifted left by four bits
(i.e. it has four 0 bits appended), producing the 20-bit result.
The inputs to the adder are provided by registers, a constant ROM that holds small constants such as +1 or -2, or the C bus.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/buses.jpg&quot;&gt;&lt;img alt=&quot;My reverse-engineered diagram showing how the AD bus and the C bus interact with the address pins.&quot; class=&quot;hilite&quot; height=&quot;311&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/buses-w350.jpg&quot; title=&quot;My reverse-engineered diagram showing how the AD bus and the C bus interact with the address pins.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;My reverse-engineered diagram showing how the AD bus and the C bus interact with the address pins.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The shift/crossover circuit provides the interface between these two buses, handling the 20-bit to 16-bit conversion. The busses can be connected in three ways: direct, crossover, or shifted.&lt;span id=&quot;fnref:swapping&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:swapping&quot;&gt;6&lt;/a&gt;&lt;/span&gt;
The direct mode connects the 16 bits of the C bus to the lower 16 bits of the address/data pins.
This is the standard mode for transferring data between the 8086&#39;s internal circuitry and the data pins.
The crossover mode performs the same connection but swaps the bytes. This is typically used for unaligned memory accesses, where the low memory byte corresponds to
the high register byte, or vice versa.
The shifted mode shifts the 20-bit AD bus value four positions to the right.
In this mode, the 16-bit output from the address adder goes to the 16-bit C bus.
(The shift is necessary to counteract the 4-bit shift applied to the address adder&#39;s output.)
Control circuitry selects the right operation for the shift/crossover circuit at the right time.&lt;span id=&quot;fnref:shift&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:shift&quot;&gt;7&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Two of the registers are invisible to the programmer but play an important role in memory accesses.
The &lt;code&gt;IND&lt;/code&gt; (Indirect) register specifies the memory address; it holds the 16-bit memory offset in a segment.
The &lt;code&gt;OPR&lt;/code&gt; (Operand) register holds the data value.&lt;span id=&quot;fnref:prefetch&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:prefetch&quot;&gt;9&lt;/a&gt;&lt;/span&gt;
The &lt;code&gt;IND&lt;/code&gt; and &lt;code&gt;OPR&lt;/code&gt; registers are not accessed directly by the programmer; the microcode for a machine instruction moves the appropriate
values to these registers prior to the write.&lt;/p&gt;
&lt;h2&gt;Overview of a write cycle&lt;/h2&gt;
&lt;p&gt;I hesitate to present a timing diagram, since I may scare off of my readers,
but the 8086&#39;s communication is designed around a four-step bus cycle.
The diagram below shows simplified timing for a write cycle, when the 8086 writes to memory or an I/O device.&lt;span id=&quot;fnref:timing&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:timing&quot;&gt;8&lt;/a&gt;&lt;/span&gt;
The external bus activity is organized as four states, each one clock cycle long: T1, T2, T3, T4.
These T states are very important since they control what happens on the bus.
During T1, the 8086 outputs the address on the pins. During the T2, T3, and T4 states, the 8086 outputs the data word on the pins.
The important part for this discussion is that the pins are multiplexed depending on the T-state: the pins provide the address during T1 and data during
T2 through T4.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/write-cycle.jpg&quot;&gt;&lt;img alt=&quot;A typical write bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16.&quot; class=&quot;hilite&quot; height=&quot;130&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/write-cycle-w700.jpg&quot; title=&quot;A typical write bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A typical write bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;There two undocumented T states that are important to the bus cycle.
The physical address is computed in the two clock cycles before T1 so the address will be available in T1.
I give these &quot;invisible&quot; T states the names TS (start) and T0.&lt;/p&gt;
&lt;h2&gt;The address adder&lt;/h2&gt;
&lt;!--
This computation is a bit tricky because the input buses and the adder are 16 bits, but the physical address is 20 bits.
--&gt;
&lt;p&gt;The operation of the address adder is a bit tricky since the 16-bit adder must generate a 20-bit physical address.
The adder has two 16-bit inputs: the B input is connected to the upper registers via the B bus, while the C input is connected to the C bus.
The segment register value is transferred over the B bus to the adder during the second half
of the TS state (that is, two clock cycles before the bus cycle becomes externally visible during T1).
Meanwhile, the address offset is transferred over the C bus to the adder, but the adder&#39;s C input shifts the value four bits to the right,
discarding the four low bits. (As will be explained later, the pin driver circuits latch these bits.)
The adder&#39;s output is shifted left four bits and transferred to the AD bus during the second half of T0. 
This produces the upper 16 bits of the 20-bit physical memory address.
This value is latched into the address output flip-flops at the start of T1, putting the computed address on the pins.
To summarize, the 20-bit address is generated by storing the 4 low-order bits during T0 and then the 16 high-order sum bits
during T1.&lt;/p&gt;
&lt;p&gt;The address adder is not needed for segment arithmetic during T1 and T2.
To improve performance, the 8086 uses the adder during this idle time to increment or decrement memory addresses.
For instance, after popping a word from the stack, the stack pointer needs to be incremented by 2.
The address adder can do this increment &quot;for free&quot; during T1 and T2, leaving the ALU available for other operations.&lt;span id=&quot;fnref:pipelining&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:pipelining&quot;&gt;10&lt;/a&gt;&lt;/span&gt;
Specifically, the adder updates the memory address in &lt;code&gt;IND&lt;/code&gt;, incrementing it or decrementing it as appropriate.
First, the &lt;code&gt;IND&lt;/code&gt; value is transferred over the B bus to the adder during the second half of T1.
Meanwhile, a constant (-3 to +2) is loaded from the Constant ROM and transferred to the adder&#39;s C input.
The output from the adder is transferred to the AD bus during the second half of T2.
As before, the output is shifted four bits to the left. However, the shift/crossover circuit between the AD bus and the C bus
is configured to shift four bits to the right, canceling the adder&#39;s shift.
The result is that the C bus gets the 16-bit sum from the adder, and this value is stored in the &lt;code&gt;IND&lt;/code&gt; register.&lt;span id=&quot;fnref:predecrement&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:predecrement&quot;&gt;11&lt;/a&gt;&lt;/span&gt;
For more information on the implemenation of the address adder, see my &lt;a href=&quot;https://www.righto.com/2020/08/reverse-engineering-adder-inside-intel.html&quot;&gt;previous blog post&lt;/a&gt;.&lt;/p&gt;
&lt;!-- 
The use of the address pins is closely tied to the 8086&#39;s external timing.
The diagram below shows how a typical bus cycle is divided into four &quot;T&quot; states, each one corresponding to one clock cycle.
During T1, the CPU puts the memory address on the bus using the address pins.
During T3 and T4, the CPU writes to memory by putting the data value on the data pins.
Alternatively, the CPU reads from memory by reading the data value during T3 and T4.
State T2 acts a buffer period to ensure that memory and the CPU don&#39;t try to write to the bus at the same time.

![A typical bus cycle consists of four T states. Diagram from The 8086 Family Users Manual, figure 4-5.](bus-cycle.jpg &quot;w500&quot;)
--&gt;

&lt;h2&gt;The pin driver circuit&lt;/h2&gt;
&lt;p&gt;Now I&#39;ll dive down to the hardware implementation of an output pin.
When the 8086 chip communicates with the outside world, it needs to provide relatively high currents.
The tiny logic transistors can&#39;t provide enough current, so the chip needs to use large output transistors.
To fit the large output transistors on the die, they are constructed of multiple wide transistors in parallel.&lt;span id=&quot;fnref:ratio&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:ratio&quot;&gt;12&lt;/a&gt;&lt;/span&gt;
Moreover, the drivers use a somewhat unusual &quot;superbuffer&quot; circuit with two transistors: one to pull the output high, and one to pull the output low.&lt;span id=&quot;fnref:superbuffer&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:superbuffer&quot;&gt;13&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The diagram below shows the transistor structure for one of the output pins (AD10), consisting of three
parallel transistors between the output and +5V, and five parallel transistors between the output and ground.
The die photo on the
left shows the metal layer on top of the die. This shows the power and ground wiring and the connections to
the transistors.
The photo on the right shows the die with the metal layer removed, showing the underlying silicon and the
polysilicon wiring on top.
A transistor gate is formed where a polysilicon wire crosses the doped silicon region. 
Combined, the +5V transistors are equivalent to about 60 typical transistors, while the ground transistors are
equivalent to about 100 typical transistors.
Thus, these transistors provide substantially more current to the output pin.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/output-transistor.jpg&quot;&gt;&lt;img alt=&quot;Two views of the output transistors for a pin. The first shows the metal layer, while the second shows the polysilicon and silicon.&quot; class=&quot;hilite&quot; height=&quot;402&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/output-transistor-w800.jpg&quot; title=&quot;Two views of the output transistors for a pin. The first shows the metal layer, while the second shows the polysilicon and silicon.&quot; width=&quot;800&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Two views of the output transistors for a pin. The first shows the metal layer, while the second shows the polysilicon and silicon.&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;Tri-state output driver&lt;/h3&gt;
&lt;p&gt;The output circuit for an address pin uses a tri-state buffer, which allows the output to be disabled
by putting it into a high-impedance &quot;tri-state&quot; configuration.
In this state, the output is not pulled high or low but is left floating.
This capability allows the pin to be used for data input.
It also allows external devices to device can take control of the bus, for instance, to perform
DMA (direct memory access).&lt;/p&gt;
&lt;p&gt;The pin is driven by two large MOSFETs, one to pull the output high and one to pull it low.
(As described earlier, each large MOSFET is physically multiple transistors in parallel, but I&#39;ll ignore that for now.)
If both MOSFETs are off, the output floats, neither on nor off.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/output-circuit.jpg&quot;&gt;&lt;img alt=&quot;Schematic diagram of a &amp;quot;typical&amp;quot; address output pin.&quot; class=&quot;hilite&quot; height=&quot;230&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/output-circuit-w400.jpg&quot; title=&quot;Schematic diagram of a &amp;quot;typical&amp;quot; address output pin.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Schematic diagram of a &quot;typical&quot; address output pin.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The tri-state output is implemented by driving the MOSFETs with two &quot;superbuffer&quot;&lt;span id=&quot;fnref:and&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:and&quot;&gt;15&lt;/a&gt;&lt;/span&gt; AND gates.
If the &lt;code&gt;enable&lt;/code&gt; input is low, both AND gates produce a low output and both output transistors are off.
On the other hand, if &lt;code&gt;enable&lt;/code&gt; is high, one AND gate will be on and one will be off.
The desired output value is loaded into a flip-flop to hold it,&lt;span id=&quot;fnref:clock&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:clock&quot;&gt;14&lt;/a&gt;&lt;/span&gt;
and the flip-flop turns one of the output transistors on, driving the output pin high or low as appropriate.
(Conveniently, the flip-flop provides the data output Q and the inverted data output &lt;span style=&quot;text-decoration:overline&quot;&gt;Q&lt;/span&gt;.)
Generally, the address pin outputs are enabled for T1-T4 of a write but only during T1 for a read.&lt;span id=&quot;fnref:enable&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:enable&quot;&gt;16&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In the remainder of the discussion, I&#39;ll use the tri-state buffer symbol below, rather than showing the implementation of the buffer.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/output-simplified.jpg&quot;&gt;&lt;img alt=&quot;The output circuit, expressed with a tri-state buffer symbol.&quot; class=&quot;hilite&quot; height=&quot;137&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/output-simplified-w350.jpg&quot; title=&quot;The output circuit, expressed with a tri-state buffer symbol.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The output circuit, expressed with a tri-state buffer symbol.&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;AD4-AD15&lt;/h3&gt;
&lt;p&gt;Pins AD4-AD15 are &quot;typical&quot; pins, avoiding the special behavior of the top and bottom pins, so I&#39;ll discuss them first.
The behavior of these pins is that the value on the AD bus is latched by the circuit and then put on the output pin
under the control of the &lt;code&gt;enaable&lt;/code&gt; signal.
The circuit has three parts: a multiplexer to select the output value, a flip-flop to hold the output value, and a tri-state driver to
provide the high-current output to the pin.
In more detail, the multiplexer selects either the value on the AD bus or the current output from the flip-flop.
That is, the multiplexer can either load a new value into the flip-flop or hold the existing value.&lt;span id=&quot;fnref:implementation&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:implementation&quot;&gt;17&lt;/a&gt;&lt;/span&gt;
The flip-flop latches the input value on the falling edge of the clock, passing it to the output driver.
If the enable line is high, the output driver puts this value on the corresponding address pin.&lt;/p&gt;
&lt;!-- datasheet: output low tested at 2.0mA, output high tested at -400 microamps --&gt;

&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/ad415.jpg&quot;&gt;&lt;img alt=&quot;The output circuit for AD4-AD15 has a latch to hold the desired output value, an address or data bit.&quot; class=&quot;hilite&quot; height=&quot;129&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/ad415-w400.jpg&quot; title=&quot;The output circuit for AD4-AD15 has a latch to hold the desired output value, an address or data bit.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The output circuit for AD4-AD15 has a latch to hold the desired output value, an address or data bit.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;For a write, the circuit latches the address value on the bus during the second half of T0 and puts it on the pins during T1.
During the second half of the T1 state, the data word is transferred from the &lt;code&gt;OPR&lt;/code&gt; register over the C bus to the AD bus and loaded
into the AD pin latches.
The word is transferred from the latches to the pins during T2 and held for the remainder of the bus cycle.&lt;/p&gt;
&lt;h3&gt;AD0-AD3&lt;/h3&gt;
&lt;p&gt;The four low address bits have a more complex circuit because these address bits are latched from the bus before the address adder computes its sum, as described earlier.
The memory offset (before the segment addition) will be on the C bus during the second half of TS and is loaded into the lower
flip-flop. This flip-flop delays these bits for one clock cycle and then they are loaded into the upper flip-flop.
Thus, these four pins pick up the offset prior to the addition, while the other pins get the result of the segment addition.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/ad03.jpg&quot;&gt;&lt;img alt=&quot;The output circuit for AD0-AD3 has a second latch to hold the low address bits before the address adder computes the sum.&quot; class=&quot;hilite&quot; height=&quot;174&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/ad03-w500.jpg&quot; title=&quot;The output circuit for AD0-AD3 has a second latch to hold the low address bits before the address adder computes the sum.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The output circuit for AD0-AD3 has a second latch to hold the low address bits before the address adder computes the sum.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;For data, the AD0-AD3 pins transfer data directly from the AD bus to the pin latch, bypassing the delay that was used to get the address bits.
That is, the AD0-AD3 pins have two paths: the delayed path used for addresses during T0 and the direct path otherwise used for data.
Thus, the multiplexer has three inputs: two for these two paths and a third loop-back input to hold the flip-flop value.&lt;/p&gt;
&lt;!--
ad-latch-load loads the  AD0-15 latches.
--&gt;

&lt;!--
If the memory access was an instruction fetch,
the address adder is immediately reused to update the instruction pointer (program counter).
In the second half of T1, one input of the address adder is loaded with the instruction pointer increment from the constant ROM (2 if a word was fetched).
This value is added to the instruction pointer value and
the updated instruction pointer value is written back in the second half of T2.
A similar process is used for other memory accesses that update a pointer, such as stack operations or string operations.

If another bus cycle follows, the T3 and T4 states act like the T0 and T1 states described above, preparing the next memory address.
Thus, address calculation is pipelined in the 8086: the address adder performs the segment computation during the last half of the previous bus cycle, so the physical memory address will be ready at the start of the bus cycle.

For a memory write, the address latches are reloaded during T1, loading them with the `OPR` register???
--&gt;

&lt;h3&gt;A16-A19: status outputs&lt;/h3&gt;
&lt;p&gt;The top four pins (A16-A19) are treated specially, since they are not used for data.
Instead, they provide processor status during T2-T4.&lt;span id=&quot;fnref:status&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:status&quot;&gt;18&lt;/a&gt;&lt;/span&gt; The pin latches for these
pins are loaded with the address during T0 like the other pins, but loaded with status instead of data during T1.
The multiplexer at the input to the latch selects the address bit during T0 and the status bit during T1, and
holds the value otherwise.
The schematic below shows how this is implemented for A16, A17, and A19.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/ad1619.jpg&quot;&gt;&lt;img alt=&quot;The output circuit for AD16, AD17, and AD19 selects either an address output or a status output.&quot; class=&quot;hilite&quot; height=&quot;115&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/ad1619-w400.jpg&quot; title=&quot;The output circuit for AD16, AD17, and AD19 selects either an address output or a status output.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The output circuit for AD16, AD17, and AD19 selects either an address output or a status output.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Address pin A18 is different because it indicates the current status of the interrupt enable flag bit.
This status is updated every clock cycle, unlike the other pins.
To implement this, the pin has a different circuit that isn&#39;t latched,
so the status can be updated continuously.
The clocked transistors act as &quot;pass transistors&quot;, passing the signal through when active.
When a pass transistor is turned off, the following logic gate holds the previous value due to the capacitance of the
wiring.
Thus, the pass transistors provide a way of holding the value through the clock cycle.
The flip-flops are implemented with pass transistors internally, so in a sense the circuit below is a flip-flop
that has been &quot;exploded&quot; to provide a second path for the interrupt status.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/ad18.jpg&quot;&gt;&lt;img alt=&quot;The output circuit for AD18 is different from the rest so the I flag status can be updated every clock cycle.&quot; class=&quot;hilite&quot; height=&quot;162&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/ad18-w540.jpg&quot; title=&quot;The output circuit for AD18 is different from the rest so the I flag status can be updated every clock cycle.&quot; width=&quot;540&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The output circuit for AD18 is different from the rest so the I flag status can be updated every clock cycle.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Reads&lt;/h2&gt;
&lt;p&gt;A memory or I/O read also uses a 4-state bus cycle, slightly different from the write cycle.
During T1, the address is provided on the pins, the same as for a write.
After that, however, the output circuits are tri-stated so they float, allowing the external memory to put data on the bus.
The read data on the pin is put on the AD bus at the start of the T4 state.
From there, the data passes through the crossover circuit to the C bus. Normally the 16 data bits pass straight through to
the C bus, but the bytes will be swapped if the memory access is unaligned.
From the C bus, the data is written to the &lt;code&gt;OPR&lt;/code&gt; register, a byte or a word as appropriate.
(For an instruction prefetch, the word is written to a prefetch queue register instead.)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/read-cycle.jpg&quot;&gt;&lt;img alt=&quot;A typical read bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16.&quot; class=&quot;hilite&quot; height=&quot;139&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/read-cycle-w600.jpg&quot; title=&quot;A typical read bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A typical read bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;To support data input on the AD0-AD15 pins, they have a circuit to buffer the input data and transfer it to the AD bus.
The incoming data bit is buffered by the two inverters and sampled when the clock is high.
If the enable&#39; signal is low, the data bit is transferred to the AD bus when the clock is low.&lt;span id=&quot;fnref:read-enable&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:read-enable&quot;&gt;19&lt;/a&gt;&lt;/span&gt;
The two MOSFETs act as a &quot;superbuffer&quot;, providing enough current for the fairly long AD bus.
I&#39;m not sure what the capacitor accomplishes, maybe avoiding a race condition if the data pin changes just as the clock goes low.&lt;span id=&quot;fnref:race&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:race&quot;&gt;20&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/read-circuit.jpg&quot;&gt;&lt;img alt=&quot;Schematic of the input circuit for the data pins.&quot; class=&quot;hilite&quot; height=&quot;134&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/read-circuit-w500.jpg&quot; title=&quot;Schematic of the input circuit for the data pins.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Schematic of the input circuit for the data pins.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;This circuit has a second role, precharging the AD bus high when the clock is low, if there&#39;s no data.
Precharging a bus is fairly common in the 8086 (and other NMOS processors) because NMOS transistors are better at pulling a
line low than pulling it high. Thus, it&#39;s often faster to precharge a line high before it&#39;s needed and then pull it low for a 0.&lt;span id=&quot;fnref:adder&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:adder&quot;&gt;21&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Since pins A16-A19 are not used for data, they operate the same for reads as for writes: providing address bits and then status.&lt;/p&gt;
&lt;h2&gt;The pin circuit on the die&lt;/h2&gt;
&lt;p&gt;The diagram below shows how the pin circuitry appears on the die. The metal wiring has been removed to show the silicon and polysilicon.
The top half of the image is the input circuitry, reading a data bit from the pin and feeding it to the AD bus.
The lower half of the image is the output circuitry, reading an address or data bit from the AD bus and amplifying it for output
via the pad.
The light gray regions are doped, conductive silicon. The thin tan lines are polysilicon, which forms transistor gates where it crosses doped silicon.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/pin-labeled.jpg&quot;&gt;&lt;img alt=&quot;The input/output circuitry for an address/data pin. The metal layer has been removed to show the underlying silicon and polysilicon. Some crystals have formed where the bond pad was.&quot; class=&quot;hilite&quot; height=&quot;482&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/pin-labeled-w600.jpg&quot; title=&quot;The input/output circuitry for an address/data pin. The metal layer has been removed to show the underlying silicon and polysilicon. Some crystals have formed where the bond pad was.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The input/output circuitry for an address/data pin. The metal layer has been removed to show the underlying silicon and polysilicon. Some crystals have formed where the bond pad was.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;A historical look at pins and timing&lt;/h2&gt;
&lt;p&gt;The number of pins on Intel chips has grown exponentially, more than a factor of 100 in 50 years.
In the early days, Intel management was convinced that a 16-pin package was large enough for any integrated circuit.
As a result, the Intel 4004 processor (1971) was crammed into a 16-pin package.
Intel chip designer Federico Faggin&lt;span id=&quot;fnref:faggin&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:faggin&quot;&gt;22&lt;/a&gt;&lt;/span&gt; describes 16-pin packages as a completely silly requirement that was throwing away
performance,
but the &quot;God-given 16 pins&quot; was like a religion at Intel.
When Intel was forced to use 18 pins by the 1103 memory chip, it &quot;was like the sky had dropped from heaven&quot;
and he had &quot;never seen so many long faces at Intel.&quot;
Although the 8008 processor (1972) was able to use 18 pins, this low pin count still harmed performance by forcing pins to be used for multiple
purposes.&lt;/p&gt;
&lt;p&gt;The Intel 8080 (1974) had a larger, 40-pin package that allowed it to have 16 address pins and 8 data pins.
Intel stuck with this size for the 8086, even though competitors used larger packages with more pins.&lt;span id=&quot;fnref:ti&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:ti&quot;&gt;23&lt;/a&gt;&lt;/span&gt;
As processors became more complex, the 40-pin package became infeasible and the pin count rapidly expanded;
The 80286 processor (1982) had a 68-pin package, while the
i386 (1985) had 132 pins; the i386 needed many more pins because it had a 32-bit data bus and a 24- or 32-bit address bus.
The i486 (1989) went to 196 pins while the original Pentium had 273 pins.
Nowadays, a modern &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/sku/232167/intel-core-i913900ks-processor-36m-cache-up-to-6-00-ghz/specifications.html&quot;&gt;Core I9 processor&lt;/a&gt; uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/LGA_1700&quot;&gt;FCLGA1700&lt;/a&gt; socket with a whopping 1700 contacts.&lt;/p&gt;
&lt;p&gt;Looking at the history of Intel&#39;s bus timing, the 8086&#39;s complicated memory timing goes back to the Intel 8008 processor (1972). Instruction execution in the 8008 went through
a specific sequence of timing states; each clock cycle was assigned a particular state number.
Memory accesses took three cycles:
the address was sent to memory during states T1 and T2, half of the address at a time since there were only 8 address pins.
During state T3, a data byte was either transmitted to memory or read from memory.
Instruction execution took place during T4 and T5.
State signals from the 8008 chip indicated which state it was in.&lt;/p&gt;
&lt;!-- http://www.bitsavers.org/components/intel/MCS8/Intel_8008_8-Bit_Parallel_Central_Processing_Unit_Rev1_Apr72.pdf --&gt;

&lt;p&gt;The 8080 used an even more complicated timing system.
An instruction consisted of one to five &quot;machine cycles&quot;, numbered M1 through M5, where each machine cycle corresponded to
a memory or I/O access. Each machine cycle consisted of three to five states, T1 through T5, similar to the 8008 states.
The 8080 had 10 different types of machine cycle such as instruction fetch, memory read, memory write, stack read or write,
or I/O read or write. The status bits indicated the type of machine cycle.
The 8086 kept the T1 through T4 memory cycle. Because the 8086 decoupled instruction prefetching from execution, it no
longer had explicit M machine cycles. Instead, it used status bits to indicate 8 types of bus activity such as instruction
fetch, read data, or write I/O.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Well, address pins is another subject that I thought would be straightforward to explain but turned out to be surprisingly
complicated.
Many of the 8086&#39;s design decisions combine in the address pins: segmented addressing, backward compatibility, and the small 40-pin package.
Moreover, because memory accesses are critical to performance, Intel put a lot of effort into this circuitry.
Thus, the pin circuitry is tuned for particular purposes, especially pin A18 which is different from all the rest.&lt;/p&gt;
&lt;p&gt;There is a lot more to say about memory accesses and how the 8086&#39;s Bus Interface Unit performs them.
The process is very complicated, with interacting state machines for memory operation and instruction prefetches, as well
as handling unaligned memory accesses.
I plan to write more, so 
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@kenshirriff@oldbytes.space&lt;/a&gt;
and Bluesky as &lt;a href=&quot;https://staging.bsky.app/profile/righto.com&quot;&gt;@righto.com&lt;/a&gt; so you can follow me there too.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:ad&quot;&gt;
&lt;p&gt;In the discussion, I&#39;ll often call all the address pins &quot;AD&quot; pins for simplicity, even though pins 16-19 are not
used for data.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:ad&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:compatibility&quot;&gt;
&lt;p&gt;The 8086&#39;s compatibility with the 8080 was somewhat limited since the 8086 had a different instruction set.
   However, Intel provided a conversion program called &lt;a href=&quot;http://www.bitsavers.org/pdf/intel/ISIS_II/9800642-02_MCS-86_Assembly_Language_Converter_Feb80.pdf&quot;&gt;CONV86&lt;/a&gt;
   that could convert 8080/8085 assembly code into 8086 assembly code that would usually work after minor editing.
   The 8086 was designed to make this process straightforward, with a mapping from the 8080&#39;s registers onto the
   8086&#39;s registers, along with a mostly-compatible instruction set. (There were a few 8080 instructions that would
   be expanded into multiple 8086 instructions.)
   The conversion worked for straightforward code, but didn&#39;t work well with tricky, self-modifying code, for instance.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:compatibility&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:pointers&quot;&gt;
&lt;p&gt;To support the 8086&#39;s segment architecture, programmers needed to deal with &quot;near&quot; and &quot;far&quot; pointers.
A near pointer consisted of a 16-bit offset and could access 64K in a segment.
A far pointer consisted of a 16-bit offset along with a 16-bit segment address. By modifying the segment register on each access,
the full megabyte of memory could be accessed. The drawbacks were that far pointers were twice as big and were slower.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:pointers&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:patent&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;https://patents.google.com/patent/US4449184A&quot;&gt;8086 patent&lt;/a&gt; provides a detailed architectural diagram of the 8086.
I&#39;ve extracted part of the diagram below.
In most cases the diagram is accurate, but its description of the C bus doesn&#39;t match the real chip.
There are some curious differences between the patent diagram and the actual implementation of the 8086,
suggesting that the data pins were reorganized between the patent and the completion of the 8086.
The diagram
shows the address adder (called the Upper Adder) connected to the C bus, which is connected to the address/data
pins.
In particular, the patent shows the data pins multiplexed with the high address pins, while the low
address pins A3-A0 are multiplexed with three status signals.
The actual implementation of the 8086 is the other way around, with the data pins multiplexed with the low address
pins while the high address pins A19-A16 are multiplexed with the status signals.
Moreover, the patent doesn&#39;t show anything corresponding to what I call the AD bus; I made up that name.
The moral is that while patents can be very informative, they can also be misleading.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-ad-pins/patent-diagram.png&quot;&gt;&lt;img alt=&quot;A diagram from patent US4449184 showing the connections to the address pins. This diagram does not match the actual chip. The diagram also shows the old segment register names: RC, RD, RS, and RA became CS, DS, SS, and ES.&quot; class=&quot;hilite&quot; height=&quot;530&quot; src=&quot;https://static.righto.com/images/8086-ad-pins/patent-diagram-w400.png&quot; title=&quot;A diagram from patent US4449184 showing the connections to the address pins. This diagram does not match the actual chip. The diagram also shows the old segment register names: RC, RD, RS, and RA became CS, DS, SS, and ES.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A diagram from patent US4449184 showing the connections to the address pins. This diagram does not match the actual chip. The diagram also shows the old segment register names: RC, RD, RS, and RA became CS, DS, SS, and ES.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- --&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:patent&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:registers&quot;&gt;
&lt;p&gt;The C bus is connected to the PC, OPR, and IND registers, as well as the prefetch queue, but is not
connected to the segment registers.
Two other buses (the ALU bus and the B bus) provide access to the segment registers.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:registers&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:swapping&quot;&gt;
&lt;p&gt;Swapping the bytes on the data pins is required in a few cases.
The 8086 has a 16-bit data bus, so transfers are usually a 16-bit word, copied directly between memory and a register.
However, the 8086 also allows 8-bit operations, in which case either the top half or bottom half of the word is
accessed. Loading an 8-bit value from the top half of a memory word into the bottom half of a register uses the crossover
circuit.
Another case is performing a 16-bit access to an &quot;unaligned&quot; address, that is, an odd address so the word crosses
the normal word boundaries.
From the programmer&#39;s perspective, an unaligned access is permitted (unlike many RISC processors), but the hardware
converts this access into two 8-bit accesses, so the bus itself never handles an unaligned access.&lt;/p&gt;
&lt;p&gt;The 8086 has the ability to access a single memory byte out of a word, either for a byte operation or for
an unaligned word operation.
This behavior has some important consequences on the address pins.
In particular, the low address pin AD0 doesn&#39;t behave like the rest of the address pins due to the special handling
of odd addresses.
Instead, this pin indicates which half of the word to transfer.
The AD0 line is low (0) when the lower portion of the bus transfers a byte.
Another pin, &lt;span style=&quot;text-decoration: overline&quot;&gt;BHE&lt;/span&gt; (Bus High Enable) has a similar role for the upper
half of the bus: it is low (0) if a byte is transferred over D15-D8.
(Keep in mind that the 8086 is little-endian, so the low byte of the word is first in memory, at the even address.)&lt;/p&gt;
&lt;p&gt;&lt;style type=&quot;text/css&quot;&gt;
  table.a0 { border-collapse: collapse}
  table.a0 .overline { text-decoration: overline;}
  table.a0 th,td {padding: 5px;}
  table.a0 th:nth-child(1) {border-right: 1px solid #ccc;}
  table.a0 td:nth-child(1) {border-right: 1px solid #ccc;}
&lt;/style&gt;&lt;/p&gt;
&lt;p&gt;The following table summarizes how &lt;span style=&quot;text-decoration:overline&quot;&gt;BHE&lt;/span&gt; and A0 work together to select a byte or word.
When accessing a byte at an odd address, A0 is odd as you might expect.&lt;/p&gt;
&lt;p&gt;&lt;table class=&quot;a0&quot;&gt;
&lt;tr style=&quot;border-bottom: 1px solid #ccc;&quot;&gt;&lt;th&gt;Access type&lt;/th&gt;&lt;th class=&quot;overline&quot;&gt;BHE&lt;/th&gt;&lt;th&gt;A0&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Word&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Low byte&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;High byte&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:swapping&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:shift&quot;&gt;
&lt;p&gt;The &lt;code&gt;cbus-adbus-shift&lt;/code&gt; signal is activated during &lt;code&gt;T2&lt;/code&gt;, when a memory index is being updated, either the instruction pointer or the &lt;code&gt;IND&lt;/code&gt; register. The address adder is used to update the register and the shift undoes the 4-bit left shift applied to the adder&#39;s output.
The shift is also used for the &lt;code&gt;CORR&lt;/code&gt; micro-instruction, which corrects the instruction pointer to account for prefetching.
The &lt;code&gt;CORR&lt;/code&gt; micro-instruction generates a &quot;fake&quot; short bus cycle in which the constant ROM and the address adder are used during T0.
I discuss the &lt;code&gt;CORR&lt;/code&gt; micro-instruction in more detail in &lt;a href=&quot;https://www.righto.com/2023/01/inside-8086-processors-instruction.html&quot;&gt;this post&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:shift&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:timing&quot;&gt;
&lt;p&gt;I&#39;ve made the timing diagram somewhat idealized so actions line up with the clock.
In the real datasheet, all the signals are skewed by various amounts so the timing is more complicated.
Moreover, if the memory device is slow, it can insert &quot;wait&quot; states between
T3 and T4. (Cheap memory was slower and would need wait states.)
Moreover, actions don&#39;t exactly line up with the clock.
I&#39;m also omitting various control signals.
The datasheet has pages of timing constraints on exactly when
signals can change.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:timing&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:prefetch&quot;&gt;
&lt;p&gt;Instruction prefetches don&#39;t use the &lt;code&gt;IND&lt;/code&gt; and &lt;code&gt;OPR&lt;/code&gt; registers.
Instead, the address is specified by the Instruction Pointer (or Program Counter), and the data is stored directly into
one of the instruction prefetch registers.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:prefetch&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:pipelining&quot;&gt;
&lt;p&gt;A single memory operation takes six clock cycles: two preparatory cycles to compute the address before the four visible cycles.
However, if multiple memory operations are performed, the operations are overlapped to achieve a degree of pipelining.
Specifically, the address calculation for the next memory operation takes place during the last two clock cycles of the current
memory operation, saving two clock cycles.
That is, for consecutive bus cycles, T3 and T4 overlap with TS and T0 of the next cycle.
In other words, during T3 and T4 of one bus cycle, the memory address gets computed for the next bus cycle.
This pipelining improves performance, compared to taking 6 clock cycles for each bus cycle.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:pipelining&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:predecrement&quot;&gt;
&lt;p&gt;The &lt;code&gt;POP&lt;/code&gt; operation is an example of how the address adder updates a memory pointer.
In this case, the stack address is moved from the Stack Pointer to the &lt;code&gt;IND&lt;/code&gt; register in order to perform the memory read.
As part of the read operation, the &lt;code&gt;IND&lt;/code&gt; register is incremented by 2. The address is then moved from the &lt;code&gt;IND&lt;/code&gt; register to
the Stack Pointer.
Thus, the address adder not only performs the segment arithmetic, but also computes the new value for the &lt;code&gt;SP&lt;/code&gt; register.&lt;/p&gt;
&lt;p&gt;Note that the increment/decrement of the &lt;code&gt;IND&lt;/code&gt; register happens after the memory operation.
For stack operations, the SP must be decremented before a &lt;code&gt;PUSH&lt;/code&gt; and incremented after a &lt;code&gt;POP&lt;/code&gt;.
The adder cannot perform a predecrement, so the &lt;code&gt;PUSH&lt;/code&gt; instruction uses the ALU (Arithmetic/Logic Unit) to perform the decrement.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:predecrement&quot; title=&quot;Jump back to footnote 11 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:ratio&quot;&gt;
&lt;p&gt;The current from an MOS transistor is proportional to the width of the gate divided by the length (the W/L ratio).
Since the minimum gate width is set by the manufacturing process, increasing the width of the gate
(and thus the overall size of the transistor) is how the transistor&#39;s current is increased.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:ratio&quot; title=&quot;Jump back to footnote 12 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:superbuffer&quot;&gt;
&lt;p&gt;Using one transistor to pull the output high and one to pull the output low is normal for CMOS gates, but it is unusual for
NMOS chips like the 8086.
A normal NMOS gate only has active transistor to pull the output low and uses a &lt;a href=&quot;https://en.wikipedia.org/wiki/Depletion-load_NMOS_logic&quot;&gt;depletion-mode&lt;/a&gt; transistor to provide a weak pull-up current, similar to a pull-up resistor.
I discuss superbuffers in more detail &lt;a href=&quot;https://www.righto.com/2022/11/the-unusual-bootstrap-drivers-inside.html#:~:text=Basic%20NMOS%20circuits&quot;&gt;here&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:superbuffer&quot; title=&quot;Jump back to footnote 13 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:clock&quot;&gt;
&lt;p&gt;The flip-flop is controlled by the inverted clock signal, so the output will change when the clock goes low.
Meanwhile, the &lt;code&gt;enable&lt;/code&gt; signal is dynamically latched by a MOSFET, also controlled by the inverted clock.
(When the clock goes high, the previous value will be retained by the gate capacitance of the inverter.)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:clock&quot; title=&quot;Jump back to footnote 14 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:and&quot;&gt;
&lt;p&gt;The superbuffer AND gates are constructed on the same principle as the regular superbuffer, except with two
inputs.
Two transistors in series pull the output high if both inputs are high.
Two transistors in parallel pull the output low if either input is low.
The low-side transistors are driven by inverted signals. I haven&#39;t drawn these signals on the schematic to
simplify it.&lt;/p&gt;
&lt;p&gt;The superbuffer AND gates use large transistors, but not as large as the output transistors, providing
an intermediate amplification stage between the small internal signals and the large external signals.
Because of the high capacitance of the large output transistors, they need to be driven with larger signals.
There&#39;s a lot of theory behind how transistor sizes should be scaled for maximum performance, described in
the book &lt;a href=&quot;https://amzn.to/42BHeTz&quot;&gt;Logical Effort&lt;/a&gt;.
Roughly speaking, for best performance when scaling up a signal, each stage should be about 3 to 4 times as large as the previous
one, so a fairly large number of stages are used (page 21).
The 8086 simplifies this with two stages, presumably giving up a bit of performance in exchange for keeping the drivers smaller
and simpler.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:and&quot; title=&quot;Jump back to footnote 15 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:enable&quot;&gt;
&lt;p&gt;The enable circuitry has some complications. For instance, I think the address pins will be enabled if a
cycle was going to be T1 for a prefetch but then got preempted by a memory operation.
The bus control logic is fairly complicated.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:enable&quot; title=&quot;Jump back to footnote 16 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:implementation&quot;&gt;
&lt;p&gt;The multiplexer is implemented with pass transistors, rather than gates. One of the pass transistors is turned on to pass
that value through to the multiplexer&#39;s output.
The flip-flop is implemented with two pass transistors and two inverters in alternating order.
The first pass transistor is activated by the clock and the second by the complemented clock.
When a pass transistor is off, its output is held by the gate capacitance of the inverter, somewhat like dynamic RAM.
This is one reason that the 8086 has a minimum clock speed: if the clock is too slow, these capacitively-held values
will drain away.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:implementation&quot; title=&quot;Jump back to footnote 17 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:status&quot;&gt;
&lt;p&gt;The status outputs on the address pins are defined as follows:
&lt;/br&gt;
A16/S3, A17/S4: these two status lines indicate which relocation register is being used for the memory access,
i.e. the stack segment, code segment, data segment, or alternate segment.
Theoretically, a system could use a different memory bank for each segment and increase the total memory capacity to 4 megabytes.
&lt;br/&gt;
A18/S5: indicates the status of the interrupt enable bit. In order to provide the most up-to-date value, this pin has a different
circuit. It is updated
at the beginning of each clock cycle, so it can change during a bus cycle.
The motivation for this is presumably so peripherals can determine immediately if the interrupt enable status changes.
&lt;br/&gt;
A19/S6: the documentation calls this a status output, even though it always outputs a status of 0.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:status&quot; title=&quot;Jump back to footnote 18 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:read-enable&quot;&gt;
&lt;p&gt;For a read, the enable signal is activated at the end of T3 and the beginning of T4 to transfer the data value to the AD bus.
The signal is gated by the READY pin, so the read doesn&#39;t happen until the external device is ready.
The 8086 will insert Tw wait states in that case.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:read-enable&quot; title=&quot;Jump back to footnote 19 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:race&quot;&gt;
&lt;p&gt;The datasheet says that a data value must be held steady for 10 nanoseconds (TCLDX) after the clock goes low at the start of T4.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:race&quot; title=&quot;Jump back to footnote 20 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:adder&quot;&gt;
&lt;p&gt;The design of the AD bus is a bit unusual since the adder will put a value on the AD bus when the clock is high, while the data pin will put a value
on the AD bus when the clock is low (while otherwise precharging it when the clock is low).
Usually the bus is precharged during one clock phase and all users of the bus pull it low (for a 0) during the other phase.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:adder&quot; title=&quot;Jump back to footnote 21 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:faggin&quot;&gt;
&lt;p&gt;Federico Faggin&#39;s oral history is &lt;a href=&quot;http://archive.computerhistory.org/resources/text/Oral_History/Faggin_Federico/Faggin_Federico_1_2_3.oral_history.2004.102658025.pdf&quot;&gt;here&lt;/a&gt;. The relevant part is on pages 55 and 56.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:faggin&quot; title=&quot;Jump back to footnote 22 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:ti&quot;&gt;
&lt;p&gt;The Texas Instruments TMS9900 (1976) used a 64-pin package for instance, as did the Motorola 68000 (1979).&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:ti&quot; title=&quot;Jump back to footnote 23 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/2795813864611579036/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=2795813864611579036' title='4 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/2795813864611579036'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/2795813864611579036'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/07/8086-pins.html' title='Reverse-engineering the 8086 processor&#39;s address and data pin circuits'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-2731307596521436851</id><published>2023-07-01T09:32:00.007-07:00</published><updated>2023-08-03T13:43:37.836-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="chips"/><category scheme="http://www.blogger.com/atom/ns#" term="intel"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>The complex history of the Intel i960 RISC processor</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;
&lt;style&gt;
  pre.microcode {font-family: courier, fixed; padding: 10px; background-color: #f5f5f5; display:inline-block;border:none;}
  pre.microcode span {color: green; font-style:italic; font-family: sans-serif; font-size: 90%;}
&lt;/style&gt;

&lt;p&gt;The Intel i960 was a remarkable 32-bit processor of the 1990s with a confusing set of versions.
Although it is now mostly forgotten (outside the many people who used it as an embedded processor), it has a complex history.
It had a shot at being Intel&#39;s flagship processor until x86 overshadowed it.
Later, it was the world&#39;s best-selling RISC processor.
One variant was a &lt;b&gt;33&lt;/b&gt;-bit processor with a decidedly non-RISC object-oriented instruction set;
it became a military standard and was used in the F-22 fighter plane.
Another version powered Intel&#39;s short-lived Unix servers.
In this blog post, I&#39;ll take a look at the history of the i960, explain its different variants, and examine silicon dies.
This chip has a lot of mythology and confusion (especially on &lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_i960&quot;&gt;Wikipedia&lt;/a&gt;), so I&#39;ll
try to clear things up.&lt;/p&gt;
&lt;h2&gt;Roots: the iAPX 432&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/intel432.jpg&quot;&gt;&lt;img alt=&quot;&amp;quot;Intel 432&amp;quot;: Cover detail from Introduction to the iAPX 432 Architecture.&quot; class=&quot;hilite&quot; height=&quot;215&quot; src=&quot;https://static.righto.com/images/960-overview/intel432-w450.jpg&quot; title=&quot;&amp;quot;Intel 432&amp;quot;: Cover detail from Introduction to the iAPX 432 Architecture.&quot; width=&quot;450&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;&quot;Intel 432&quot;: Cover detail from &lt;a href=&quot;http://www.bitsavers.org/components/intel/iAPX_432/171821-001_Introduction_to_the_iAPX_432_Architecture_Aug81.pdf&quot;&gt;Introduction to the iAPX 432 Architecture&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The ancestry of the i960 starts in 1975, when Intel set out to design a &quot;micro-mainframe&quot;,
a revolutionary processor that would bring the power of mainframe computers to microprocessors.
This project, eventually called the iAPX 432, was a huge leap in features and complexity.
Intel had just released the popular 8080 processor in 1974, an 8-bit processor that kicked off the hobbyist computer era with computers
such as the Altair and IMSAI.
However, 8-bit microprocessors were toys compared to 16-bit minicomputers like the PDP-11, let alone mainframes like the 32-bit IBM System/370.
Most companies were gradually taking minicomputer and mainframe features and putting them into microprocessors, but
Intel wanted to leapfrog to a mainframe-class 32-bit processor.
The processor would make programmers much more productive by bridging the &quot;semantic gap&quot; between high-level languages and simple processors, implementing many features directly into the processor.&lt;/p&gt;
&lt;!-- https://www.google.com/books/edition/Journal_of_Pascal_and_Ada/d0UsAQAAIAAJ?hl=en&amp;gbpv=1&amp;bsq=ada+dominant+programming+language&amp;dq=ada+dominant+programming+language&amp;printsec=frontcover --&gt;
&lt;!-- https://books.google.com/books?id=1mQDa_UuMbYC&amp;pg=PA51&amp;dq=ada+dominant+programming+language&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwjkx535sLX_AhUfFlkFHemmCtoQ6AF6BAgFEAI#v=onepage&amp;q=ada%20dominant%20programming%20language&amp;f=false --&gt;

&lt;!--
The [June 1981](https://www.computer.org/csdl/magazine/co/1981/06) issue of IEEE Computer was devoted to highly positive coverage of the Ada language.
--&gt;

&lt;p&gt;The &lt;a href=&quot;https://homes.cs.washington.edu/~levy/capabook/Chapter9.pdf&quot;&gt;432 processor&lt;/a&gt; included memory management, process management, and interprocess communication.
These features were traditionally part of the operating system, but Intel built them in the processor,
calling this the &quot;&lt;a href=&quot;http://www.bitsavers.org/components/intel/iAPX_432/171821-001_Introduction_to_the_iAPX_432_Architecture_Aug81.pdf&quot;&gt;Silicon Operating System&lt;/a&gt;&quot;.
The processor was also one of the first to implement the new IEEE 754 floating-point standard, still in use by most processors.
The 432 also had support for fault tolerance and multi-processor systems.
One of the most unusual features of the 432 was that instructions weren&#39;t byte aligned. Instead, instructions were between 6 and 321 bits long,
and you could jump into the middle of a byte.
Another unusual feature was that the 432 was a stack-based machine, pushing and popping values on an in-memory stack, rather than
using general-purpose registers.&lt;/p&gt;
&lt;p&gt;The 432 provided hardware support for object-oriented programming, built around
an unforgeable object pointer called an Access Descriptor.
Almost every structure in a 432 program and in the system itself is a separate object.
The processor provided fine-grain security and access control by
checking every object access to ensure that the user had permission and was not exceeding the bounds of the object.
This made buffer overruns and related classes of bugs impossible, unlike modern processors.&lt;/p&gt;
&lt;!-- Ada and iAPX 432 developed in parallel https://books.google.com/books?id=DT4EAAAAMBAJ&amp;pg=PA39&amp;dq=iapx+432+ada&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwiV2citlqr_AhXWlWoFHfE9AyUQuwV6BAgKEAY#v=onepage&amp;q=iapx%20432%20ada&amp;f=false --&gt;

&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/iapx432.jpg&quot;&gt;&lt;img alt=&quot;This photo from the Intel 1981 annual report shows Intel&#39;s 432-based development computer and three of the engineers.&quot; class=&quot;hilite&quot; height=&quot;469&quot; src=&quot;https://static.righto.com/images/960-overview/iapx432-w350.jpg&quot; title=&quot;This photo from the Intel 1981 annual report shows Intel&#39;s 432-based development computer and three of the engineers.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This photo from the Intel 1981 annual report shows Intel&#39;s 432-based development computer and three of the engineers.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The new, object-oriented Ada language was the primary programming language for the 432.
The US Department of Defense developed the Ada language in the late 1970s and early 1980s to provide a common language for
embedded systems, using the latest ideas from object-oriented programming.
Proponents expected Ada to become the dominant computer language for the 1980s and beyond.
In 1979, Intel realized that Ada was a good target for the iAPX 432, since they had similar object and task models.
Intel &lt;a href=&quot;https://www.computer.org/csdl/magazine/co/1981/06/01667402/13rRUB7a19L&quot;&gt;decided to&lt;/a&gt;
&quot;establish itself as an early center of Ada technology by using the language as the
primary development and application language for the
new iAPX 432 architecture.&quot;
The iAPX 432&#39;s operating system (&lt;a href=&quot;http://www.bitsavers.org/components/intel/iAPX_432/172103-002_iMAX_432_Reference_Manual_May82.pdf&quot;&gt;iMAX 432&lt;/a&gt;) and other software were written in Ada, using one of the first Ada compilers.&lt;/p&gt;
&lt;p&gt;Unfortunately, iAPX 432 project was way too ambitious for its time.
After a couple of years of slow progress, Intel realized that they needed a stopgap processor to counter competitors such as Zilog and Motorola.
Intel quickly designed a 16-bit processor that they could sell until the 432 was ready.
This processor was the Intel 8086 (1978), which lives on in the x86 architecture used by most computers today.
Critically, the importance of the 8086 was not recognized at the time.
In 1981, IBM selected Intel&#39;s 8088 processor (a version of the 8086 with an 8-bit bus) for the IBM PC.
In time, the success of the IBM PC and compatible systems led to Intel&#39;s dominance of the microprocessor market, but in 1981
Intel viewed the IBM PC as just another design win.
As Intel VP Bill Davidow later said, &quot;We knew it was an important win. We didn&#39;t realize it was the only win.&quot;&lt;/p&gt;
&lt;!-- Creating the Digital Future, p27 --&gt;

&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/ibm-pc.jpg&quot;&gt;&lt;img alt=&quot;Caption: IBM chose Intel&#39;s high performance 8088 microprocessor as the central processing unit for the IBM Personal Computer, introduced in 1981. Seven Intel peripheral components are also integrated into the IBM Personal Computer.  From Intel&#39;s 1981 annual report.&quot; class=&quot;hilite&quot; height=&quot;328&quot; src=&quot;https://static.righto.com/images/960-overview/ibm-pc-w350.jpg&quot; title=&quot;Caption: IBM chose Intel&#39;s high performance 8088 microprocessor as the central processing unit for the IBM Personal Computer, introduced in 1981. Seven Intel peripheral components are also integrated into the IBM Personal Computer.  From Intel&#39;s 1981 annual report.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Caption: IBM chose Intel&#39;s high performance 8088 microprocessor as the central processing unit for the IBM Personal Computer, introduced in 1981. Seven Intel peripheral components are also integrated into the IBM Personal Computer.  From &lt;a href=&quot;https://www.intel.com/content/www/us/en/history/history-1981-annual-report.html&quot;&gt;Intel&#39;s 1981 annual report&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Intel finally released the iAPX 432 in 1981.
Intel&#39;s &lt;a href=&quot;https://www.intel.com/content/www/us/en/history/history-1981-annual-report.html&quot;&gt;1981 annual report&lt;/a&gt; shows the
importance of the 432 to Intel.
A section titled &quot;The Micromainframe Arrives&quot; enthusiastically described the iAPX 432 and how it would &quot;open the door to applications not previously feasible&quot;.
To Intel&#39;s surprise, the iAPX 432 ended up as &quot;one of the great disaster stories of modern computing&quot; as
the New York Times &lt;a href=&quot;https://archive.nytimes.com/www.nytimes.com/library/tech/98/04/biztech/articles/05merced.html&quot;&gt;put it&lt;/a&gt;.
The processor was so complicated that it was split across two very large chips:&lt;span id=&quot;fnref:size&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:size&quot;&gt;1&lt;/a&gt;&lt;/span&gt; one
to decode instructions and a second to execute them
Delivered years behind schedule, the micro-mainframe&#39;s performance was dismal, much worse than competitors and even the stopgap 8086.&lt;span id=&quot;fnref:432&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:432&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
Sales were minimal and the 432 quietly dropped out of sight.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/432-dies.jpg&quot;&gt;&lt;img alt=&quot;My die photos of the two chips that make up the iAPX 432 General Data Processor. Click for a larger version.&quot; class=&quot;hilite&quot; height=&quot;289&quot; src=&quot;https://static.righto.com/images/960-overview/432-dies-w600.jpg&quot; title=&quot;My die photos of the two chips that make up the iAPX 432 General Data Processor. Click for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;My die photos of the two chips that make up the iAPX 432 General Data Processor. Click for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Intel picks a 32-bit architecture (or two, or three)&lt;/h2&gt;
&lt;p&gt;In 1982, Intel still didn&#39;t realize the importance of the x86 architecture.
The follow-on 186 and 286 processors were released but without much success at first.&lt;span id=&quot;fnref:286&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:286&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
Intel was working on the 386, a 32-bit successor to the 286, but their main customer IBM was very unenthusiastic.&lt;span id=&quot;fnref:ibm286&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:ibm286&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
Support for the 386 was so weak that the 386 team worried that the project might be dead.&lt;span id=&quot;fnref:386-oral-history&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:386-oral-history&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
Meanwhile, the 432 team continued their work.
Intel also had a third processor design in the works, a 32-bit VAX-like processor codenamed P4.&lt;span id=&quot;fnref:processor-numbers&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:processor-numbers&quot;&gt;6&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Intel recognized that developing three unrelated 32-bit processors was impractical and formed a task force to develop a
Single High-End Architecture (SHEA).
The task force didn&#39;t achieve a single architecture, but they decided to
merge the 432 and the P4 into a processor codenamed the P7, which would become the i960.
They also decided to continue the 386 project.
(Ironically, in 1986, Intel started yet another 32-bit processor, the unrelated &lt;a href=&quot;https://spectrum.ieee.org/intel-i860&quot;&gt;i860&lt;/a&gt;, bringing
the number of 32-bit architectures back to three.)&lt;/p&gt;
&lt;p&gt;At the time, the 386 team felt that they were treated as the
&quot;stepchild&quot; while the P7 project was the focus of Intel&#39;s attention.
This would change as the sales of x86-based personal computers climbed and money poured into Intel.
The 386 team would soon transform from stepchild to king.&lt;span id=&quot;fnref2:386-oral-history&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:386-oral-history&quot;&gt;5&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;The first release of the i960 processor&lt;/h2&gt;
&lt;p&gt;Meanwhile,
the 1980 paper &lt;a href=&quot;https://inst.eecs.berkeley.edu/~n252/paper/RISC-patterson.pdf&quot;&gt;The case for the Reduced Instruction Set Computer&lt;/a&gt;
proposed a revolutionary new approach for computer architecture: building Reduced Instruction Set Computers (RISC) instead of
Complex Instruction Set Computers (CISC).
The paper argued that the trend toward increasing complexity was doing more harm than good.
Instead, since &quot;every transistor is precious&quot; on a VLSI chip, the instruction set should be simplified,
only adding features that quantitatively improved performance.&lt;/p&gt;
&lt;p&gt;The RISC approach became very popular in the 1980s.
Processors that followed the RISC philosophy generally converged on an approach with
32-bit easy-to-decode instructions,
a load-store architecture (separating computation instructions from instructions that accessed memory),
straightforward instructions that executed in one clock cycle,
and implementing instructions directly rather than through microcode.&lt;/p&gt;
&lt;p&gt;The P7 project combined the RISC philosophy and the ideas from the 432 to create Intel&#39;s first RISC chip, originally called
the 80960&lt;span id=&quot;fnref:80960&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:80960&quot;&gt;7&lt;/a&gt;&lt;/span&gt; and later the i960.
The chip, announced in 1988, was significant enough for coverage in the &lt;a href=&quot;https://www.nytimes.com/1988/04/06/business/company-news-a-new-family-of-intel-chips.html&quot;&gt;New York Times&lt;/a&gt;.
Analysts said that the chip was marketed as an embedded controller to avoid stealing sales from the 80386.
However, Intel&#39;s claimed motivation was the size of the embedded market;
Intel chip designer Steve McGeady &lt;a href=&quot;https://archive.org/details/198902ByteMagazineVol1402PersonalWorkstationMacSE/page/n13/mode/2up?q=embedded+80960+29000&quot;&gt;said at the time&lt;/a&gt;, &quot;I&#39;d rather put an 80960 in every antiskid braking system than in every Sun workstation.
Nonetheless, Intel also used the i960 as a workstation processor, as will be described in the next section.&lt;/p&gt;
&lt;p&gt;The block diagram below shows the microarchitecture of the original i960 processors.
The microarchitecture of the i960 followed most (but not all) of the common RISC design:
a large register set, mostly one-cycle instructions,
a load/store architecture, simple instruction formats, and a pipelined architecture.
The Local Register Cache contains four sets of the 16 local registers. These &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Register_window&quot;&gt;register windows&lt;/a&gt;&quot; allow the registers to be switched during
function calls without the delay of saving registers to the stack.
The micro-instruction ROM and sequencer hold microcode for complex instructions; microcode is highly unusual for a RISC processor.
The chip&#39;s Floating Point Unit&lt;span id=&quot;fnref:fp-80387&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:fp-80387&quot;&gt;8&lt;/a&gt;&lt;/span&gt; and Memory Management Unit are advanced features for the time.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/arch-xa.jpg&quot;&gt;&lt;img alt=&quot;The microarchitecture of the i960 XA. FPU is Floating Point Unit. IEU is Instruction Execution Unit. MMU is Memory Management Unit. From the 80960 datasheet.&quot; class=&quot;hilite&quot; height=&quot;288&quot; src=&quot;https://static.righto.com/images/960-overview/arch-xa-w600.jpg&quot; title=&quot;The microarchitecture of the i960 XA. FPU is Floating Point Unit. IEU is Instruction Execution Unit. MMU is Memory Management Unit. From the 80960 datasheet.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The microarchitecture of the i960 XA. &lt;i&gt;FPU&lt;/i&gt; is Floating Point Unit. &lt;i&gt;IEU&lt;/i&gt; is Instruction Execution Unit. &lt;i&gt;MMU&lt;/i&gt; is Memory Management Unit. From the &lt;a href=&quot;http://www.bitsavers.org/components/intel/i960/271159-001_80960XA_Advance_Information_Oct90.pdf&quot;&gt;80960 datasheet&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;It&#39;s interesting to compare the i960 to the 432: the programmer-visible architectures are completely different, while the instruction
sets are almost identical.&lt;span id=&quot;fnref:instruction-set-note&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:instruction-set-note&quot;&gt;9&lt;/a&gt;&lt;/span&gt;
Architecturally, the 432 is a stack-based machine with no registers, while the i960 is a load-store machine with many registers.
Moreover, the 432 had complex variable-length instructions, while the i960 uses simple fixed-length load-store instructions.
At the low level, the instructions are different due to the extreme architectural differences between the processors,
but otherwise, the instructions are remarkably similar, modulo some name changes.&lt;/p&gt;
&lt;p&gt;The key to understanding the i960 family is that there are four architectures, ranging from a straightforward RISC processor to
a 33-bit processor implementing the 432&#39;s complex instruction set and object model.&lt;span id=&quot;fnref:myers&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:myers&quot;&gt;10&lt;/a&gt;&lt;/span&gt;
Each architecture adds additional functionality to the previous one:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
The Core architecture consists of a &quot;RISC-like&quot; core.
&lt;li&gt;
The Numerics architecture extends Core with floating-point.
&lt;li&gt;
The Protected architecture extends Numerics with paged memory management, Supervisor/User protection, string instructions,
process scheduling, interprocess communication for OS, and symmetric multiprocessing.
&lt;li&gt;
The Extended architecture extends Protected with object addressing/protection and interprocess communication for applications.
This architecture used an extra tag bit, so registers, the bus, and memory were 33 bits wide instead of 32.
&lt;/ul&gt;

&lt;p&gt;These four versions were sold as the KA (Core), KB (Numerics), MC (Protected), and XA (Extended).
The KA chip cost $174 and the KB version cost $333 while MC was aimed at the military market and cost a whopping $2400.
The most advanced chip (XA) was, at first, kept proprietary for use by BiiN (discussed below), but was later sold to the military.
The military versions weren&#39;t secret, but it is very hard to find documentation on them.&lt;span id=&quot;fnref:extended&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:extended&quot;&gt;11&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;!-- https://www.google.com/books/edition/Circuit_Cellar_Ink/NoBVAAAAYAAJ?hl=en&amp;gbpv=1&amp;bsq=%22mc%22 --&gt;

&lt;!-- https://books.google.com/books?id=ADoEAAAAMBAJ&amp;pg=PT43&amp;dq=intel+%2280960%22&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwjIwIzbwab_AhWjSDABHUlEBS8Q6AF6BAgBEAI#v=onepage&amp;q=intel%20%2280960%22&amp;f=false --&gt;

&lt;p&gt;The strangest thing about these four architectures is that the chips were &lt;em&gt;identical&lt;/em&gt;, using the same die.
In other words, the simple Core chip included all the circuitry for floating point, memory management, and objects; these features just weren&#39;t used.&lt;span id=&quot;fnref:features&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:features&quot;&gt;12&lt;/a&gt;&lt;/span&gt;
The die photo below shows the die, with the main functional
units labeled.
Around the edge of the die are the bond pads that connect the die to the external pins.
Note that the right half of the chip has almost no bond pads. As a result, the packaged IC had many unused pins.&lt;span id=&quot;fnref:no-connection&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:no-connection&quot;&gt;13&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/80960MC-labeled.jpg&quot;&gt;&lt;img alt=&quot;The i960 KA/KB/MC/XA with the main functional blocks labeled. Click this image (or any other) for a larger version. Die image courtesy of Antoine Bercovici.  Floorplan from The 80960 microprocessor architecture.&quot; class=&quot;hilite&quot; height=&quot;603&quot; src=&quot;https://static.righto.com/images/960-overview/80960MC-labeled-w600.jpg&quot; title=&quot;The i960 KA/KB/MC/XA with the main functional blocks labeled. Click this image (or any other) for a larger version. Die image courtesy of Antoine Bercovici.  Floorplan from The 80960 microprocessor architecture.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The i960 KA/KB/MC/XA with the main functional blocks labeled. Click this image (or any other) for a larger version. Die image courtesy of Antoine Bercovici.  Floorplan from &lt;a href=&quot;https://archive.org/details/80960microproces0000myer/page/15/mode/1up&quot;&gt;The 80960 microprocessor architecture&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;One advanced feature of the i960 is register scoreboarding, visible in the upper-left corner of the die.
The idea is that loading a register from memory is slow, so to improve performance, the processor executes the following instructions
while the load completes, rather than waiting.
Of course, an instruction can&#39;t be executed if it uses a register that is being loaded, since the value isn&#39;t there.
The solution is a &quot;scoreboard&quot; that tracks which registers are valid and which are still being loaded, and blocks an instruction
if the register isn&#39;t ready.
The i960 could handle up to three outstanding reads, providing a significant performance gain.&lt;/p&gt;
&lt;p&gt;The most complex i960 architecture is the Extended architecture, which provides the object-oriented system.
This architecture is designed around an unforgeable pointer called an Access Descriptor that provides protected access to
an object.
What makes the pointer unforgeable is that it is 33 bits long with an extra bit that indicates an Access Descriptor.
You can&#39;t set this bit with a regular 32-bit instruction. Instead, an Access Descriptor can only be created with a special
privileged instruction, &quot;Create AD&quot;.&lt;span id=&quot;fnref:objects-432&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:objects-432&quot;&gt;14&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/object-diagram.jpg&quot;&gt;&lt;img alt=&quot;An Access Descriptor is a pointer to an object table. From BiiN Object Computing.&quot; class=&quot;hilite&quot; height=&quot;249&quot; src=&quot;https://static.righto.com/images/960-overview/object-diagram-w550.jpg&quot; title=&quot;An Access Descriptor is a pointer to an object table. From BiiN Object Computing.&quot; width=&quot;550&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;An Access Descriptor is a pointer to an object table. From &lt;a href=&quot;http://www.bitsavers.org/pdf/biin/BiiN_Object_Computing.pdf&quot;&gt;BiiN Object Computing&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The diagram above shows how objects work.
The 33-bit Access Descriptor (AD) has its tag bit set to 1, indicating that it is a valid Access Descriptor.
The Rights field controls what actions can be performed by this object reference.
The AD&#39;s Object Index references the Object Table that holds information about each object.
In particular, the Base Address and Size define the object&#39;s location in memory and ensure that an access cannot exceed
the bounds of the object.
The Type Definition defines the various operations that can be performed on the object.
Since this is all implemented by the processor at the instruction level, it provides strict security.&lt;/p&gt;
&lt;h2&gt;Gemini and BiiN&lt;/h2&gt;
&lt;p&gt;The i960 was heavily influenced by a partnership called Gemini and then BiiN.
In 1983, near the start of the i960 project, Intel formed a partnership with Siemens to build high-performance fault-tolerant servers.
In this partnership, Intel would provide the hardware while Siemens developed the software.
This partnership allowed Intel to move beyond the chip market to the potentially-lucrative systems market, while adding powerful systems to
Siemens&#39; product line.
The Gemini team contained many of the people from the 432 project and wanted to continue the 432&#39;s architecture.
Gemini worked closely with the developers of the i960 to ensure the new processor would meet their needs; both teams worked
in the same building at Intel&#39;s Jones Farm site in Oregon.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/biin60.jpg&quot;&gt;&lt;img alt=&quot;The BiiN 60 system. From BiiN 60 Technical Overview.&quot; class=&quot;hilite&quot; height=&quot;440&quot; src=&quot;https://static.righto.com/images/960-overview/biin60-w400.jpg&quot; title=&quot;The BiiN 60 system. From BiiN 60 Technical Overview.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The BiiN 60 system. From &lt;a href=&quot;http://bitsavers.org/pdf/biin/BiiN_60_Technical_Overview_Oct88.pdf&quot;&gt;BiiN 60 Technical Overview&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;In 1988, shortly after the announcement of the i960 chips, the Intel/Siemens partnership was spun off into a company called BiiN.&lt;span id=&quot;fnref:biin&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:biin&quot;&gt;15&lt;/a&gt;&lt;/span&gt;
BiiN announced two high-performance, fault-tolerant, multiprocessor systems.
These systems used the i960 XA processor&lt;span id=&quot;fnref:xa&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:xa&quot;&gt;16&lt;/a&gt;&lt;/span&gt; and took full advantage of the object-oriented model
and other features provided by its Extended architecture.
The &lt;a href=&quot;https://books.google.com/books?id=pDsEAAAAMBAJ&amp;amp;pg=PA35&quot;&gt;BiiN 20&lt;/a&gt; was designed for departmental computing and cost $43,000 to $80,000. It supported 50 users (connected by terminals) on one 5.5-MIPS i960 processor.
The larger BiiN 60 handled up to 1000 terminals and cost $345,000 to $815,000.
The Unix-compatible BiiN operating system (BiiN/OS) and utilities were written in 2 million lines of Ada code.&lt;/p&gt;
&lt;p&gt;BiiN described many &lt;a href=&quot;https://books.google.com/books?id=pFcxi38ScwAC&amp;amp;pg=PP10&quot;&gt;potential markets&lt;/a&gt; for these systems: government, factory automation, financial services, on-line transaction processing,
manufacturing, and health care.
Unfortunately, as &lt;a href=&quot;https://www.cs.drexel.edu/~jjohnson/2012-13/fall/cs281/resources/Embedded_Processors_(ExtremeTech).pdf&quot;&gt;ExtremeTech put it&lt;/a&gt;, &quot;the market for fault-tolerant Unix workstations was approximately nil.&quot;
BiiN was shut down in 1989, just 15 months after its creation as profitability kept becoming more distant.
BiiN earned the nickname &quot;Billions invested in Nothing&quot;; the actual investment was 1700 person-years and $430 million.&lt;/p&gt;
&lt;!-- https://www.google.com/books/edition/Entrepreneurship_and_Innovation_in_Secon/OgUJJPuDvfQC?hl=en&amp;gbpv=1&amp;bsq=960 --&gt;

&lt;!--
![The BiiN 20 system. From &lt;a href=&quot;https://archive.org/details/bub_gb_pDsEAAAAMBAJ_2/page/n33/mode/2up&quot;&gt;InfoWorld&lt;/a&gt;.](biin20.jpg &quot;w300&quot;)
--&gt;

&lt;!-- BiiN is discussed in detail in https://ieeexplore.ieee.org/document/63665 --&gt;

&lt;!--
![The process control block. From &lt;a href=&quot;http://www.bitsavers.org/components/intel/i960/271081-001_80960MC_Programmers_Reference_Manual_Jul88.pdf&quot;&gt;80960MC Programmer&#39;s Reference Manual&lt;/a&gt;.](process-control-block.jpg &quot;w400&quot;)
--&gt;

&lt;!--
You might argue that these instructions are essentially subroutines in ROM, built up from RISC instructions.
For the most part, that&#39;s true.
However, the process scheduling operations are tied into an internal processor timer, so there is some hardware support.
--&gt;

&lt;!--
[PC Magazine](https://books.google.com/books?id=oabZ_SN3dxEC&amp;pg=PA51&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwjE5Zf31cb-AhUMkYkEHZt2C_wQ6AF6BAgBEAI#v=onepage&amp;q&amp;f=false)
states that the 386 team moved to the i960 after the 386 project (so presumably around 1985).
Wikipedia [states](https://en.wikipedia.org/wiki/Intel_i960#End_of_development) that the i960 team was moved to the Pentium Pro
team in 1990.
Glenn Hinton i960CA then Pentium Pro senior architect. https://www.anandtech.com/show/16438/new-intel-ceo-making-waves-rehiring-retired-cpu-architects
Gurbir Singh and Nitin Sarangdhar designed the i960 bus and moved to Pentium Pro team.
--&gt;

&lt;h2&gt;The superscalar i960 CA&lt;/h2&gt;
&lt;p&gt;One year after the first i960, Intel released the groundbreaking i960 CA.
This chip was the world&#39;s first superscalar microprocessor, able to execute more than one instruction per clock cycle.
The chip had three execution units that could operate in parallel:
an integer execution unit, a multiply/divide unit, and an address generation unit that could also do integer arithmetic.&lt;span id=&quot;fnref:ca&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:ca&quot;&gt;17&lt;/a&gt;&lt;/span&gt;
To keep the execution units busy, the i960 CA&#39;s instruction sequencer examined four instructions at once and determined which ones could be issued in parallel without
conflict.
It could issue two instructions and a branch each clock cycle, using branch prediction to speculatively execute branches out of order.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/80960CA-labeled.jpg&quot;&gt;&lt;img alt=&quot;The i960 CA die, with functional blocks labeled. Photo courtesy of Antoine Bercovici. Functional blocks from the datasheet.&quot; class=&quot;hilite&quot; height=&quot;457&quot; src=&quot;https://static.righto.com/images/960-overview/80960CA-labeled-w700.jpg&quot; title=&quot;The i960 CA die, with functional blocks labeled. Photo courtesy of Antoine Bercovici. Functional blocks from the datasheet.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The i960 CA die, with functional blocks labeled. Photo courtesy of Antoine Bercovici. Functional blocks from &lt;a href=&quot;http://datasheets.chipdb.org/Intel/80960/PRODBREF/272211_3.PDF&quot;&gt;the datasheet&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Following the CA, several other superscalar variants were produced:
the CF had more cache, the military MM implemented the Protected architecture (memory management and a floating point unit),
and the military MX implemented the Extended architecture (object-oriented).&lt;/p&gt;
&lt;p&gt;The image below shows the 960 MX die with the main functional blocks labeled.
(I think the MM and MX used the same die but I&#39;m not sure.&lt;span id=&quot;fnref:mm&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:mm&quot;&gt;18&lt;/a&gt;&lt;/span&gt;)
Like the i960 CA, this chip has multiple functional units that can be operated in parallel for its superscalar execution.
Note the wide buses between various blocks, allowing high internal bandwidth.
The die was too large for the optical projection of the mask, with the result that the corners of the circuitry needed to be rounded off.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The i960MX die with the main functional blocks labeled. This is a die photo I took, with labels based on my reverse engineering.&quot; class=&quot;hilite&quot; height=&quot;699&quot; src=&quot;https://static.righto.com/images/960-overview/die-labeled-w600.jpg&quot; title=&quot;The i960MX die with the main functional blocks labeled. This is a die photo I took, with labels based on my reverse engineering.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The i960MX die with the main functional blocks labeled. This is a die photo I took, with labels based on my reverse engineering.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The block diagram of the i960 MX shows the complexity of the chip and how it is designed for parallelism.
The register file is the heart of the chip. It is multi-ported so up to 6 registers can be accessed at the same time.
Note the multiple, 256-bit wide buses between the register file and the various functional units.
The chip has two buses: a high-bandwidth Backside Bus between the chip and its external cache and private memory;
and a New Local Bus, which runs at half the speed and connects the chip to main memory and I/O.
For highest performance, the chip&#39;s software would access its private memory over the high-speed bus, while using the
slower bus for I/O and shared memory accesses.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/960mx-block-diagram.jpg&quot;&gt;&lt;img alt=&quot;A functional block diagram of the i960 MX. From Intel Military and Special Projects Handbook, 1993.&quot; class=&quot;hilite&quot; height=&quot;405&quot; src=&quot;https://static.righto.com/images/960-overview/960mx-block-diagram-w700.jpg&quot; title=&quot;A functional block diagram of the i960 MX. From Intel Military and Special Projects Handbook, 1993.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A functional block diagram of the i960 MX. From Intel Military and Special Projects Handbook, 1993.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Military use and the JIAWG standard&lt;/h2&gt;
&lt;p&gt;The i960 had a special role in the US military.
In 1987 the military &lt;a href=&quot;https://people.cs.kuleuven.be/~dirk.craeynest/ada-belgium/archive/ase/ase02_01/docs/pol_hist/policy/3405-1.txt&quot;&gt;mandated&lt;/a&gt; the use of Ada as the single, common computer programming language for Defense computer resources in most cases.&lt;span id=&quot;fnref:ada&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:ada&quot;&gt;19&lt;/a&gt;&lt;/span&gt;
In 1989, the military created the JIAWG standard, which selected two 32-bit instruction set architectures for military avionics.
These architectures were the i960&#39;s Extended architecture (implemented by the i960 XA) and the MIPS architecture (based on a RISC project at Stanford).&lt;span id=&quot;fnref:standard&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:standard&quot;&gt;20&lt;/a&gt;&lt;/span&gt;
The superscalar i960 MX processor described earlier soon became a popular JIAWG-compliant processor, since it had higher performance than the XA.&lt;/p&gt;
&lt;!-- Ada seems destined to become the dominant programming language of the 1980s. --&gt;
&lt;!-- https://www.computer.org/csdl/magazine/co/1981/06/01667393/13rRUB7a13Y --&gt;

&lt;!--
I should point out that you didn&#39;t need to use an Extended architecture chip to run Ada; there were Ada compilers
available for all the i960 processors, although without the hardware enforcement that the Extended architecture processors provided.
--&gt;
&lt;!-- http://intel-vintage-developer.eu5.org/DESIGN/I960/DEVTOOLS/I960.HTM --&gt;

&lt;p&gt;Hughes designed a modular avionics processor that used the i960 XA and later the MX.
A dense module called the HAC-32 contained two i960 MX processors, 2 MB of RAM, and an I/O controller in a 2&quot;&amp;times;4&quot; multi-chip module, slightly bigger than a credit card.
This module had bare dies bonded to the substrate, maximizing the density.
In the photo below, the two largest dies are the i960 MX while the numerous gray rectangles are memory chips.
This module was used in F-22&#39;s Common Integrated Processor, the RAH-66 Comanche helicopter (which was canceled), the F/A-18&#39;s Stores Management Processor
(the computer that controls attached weapons), and the AN/ALR-67 radar computer.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/hughes.jpg&quot;&gt;&lt;img alt=&quot;The Hughes HAC-32. From Avionics Systems Design.&quot; class=&quot;hilite&quot; height=&quot;413&quot; src=&quot;https://static.righto.com/images/960-overview/hughes-w600.jpg&quot; title=&quot;The Hughes HAC-32. From Avionics Systems Design.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Hughes HAC-32. From &lt;a href=&quot;https://archive.org/details/avionicsystemsde0000newp/page/40/mode/2up?q=hughes&amp;view=theater&quot;&gt;Avionics Systems Design&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The military market is difficult due to the long timelines of military projects, unpredictable volumes, and the risk
of cancellations.
In the case of the F-22 fighter plane, the project started in 1985 when the Air Force sent out proposals for a new Advanced Tactical Fighter.
Lockheed built a YF-22 prototype, first flying it in 1990.
The Air Force selected the YF-22 over the competing YF-23 in 1991 and the project moved to full-scale development.
During this time, at least three generations of processors became obsolete.
In particular, the i960MX was out of production by the time the F-22 first flew in &lt;a href=&quot;https://www.militaryaerospace.com/computers/article/16710716/f22-avionics-designers-rely-on-obsolescent-electronics-but-plan-for-future-upgrades&quot;&gt;1997&lt;/a&gt;.
At one point, the military had to pay Intel $22 million to restart the i960 production line.
In 2001, the Air Force started a switch to the PowerPC processor, and finally the plane entered military service in 2005.
The F-22 illustrates how the fast-paced obsolescence of processors is a big problem for decades-long military projects.&lt;/p&gt;
&lt;!--
The i960 production line was permanently [shut down](https://www.gao.gov/assets/gao-04-391.pdf) in January 2004 after the Air Force made its last purchase of 820 chips.
--&gt;

&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/cip.jpg&quot;&gt;&lt;img alt=&quot;The Common Integrated Processor for the F-22, presumably with i960 MX chips inside. It is the equivalent of two Cray supercomputers and was the world&#39;s most advanced, high-speed computer system for a fighter aircraft. Source: NARA/Hughes Aircraft Co./T.W. Goosman.&quot; class=&quot;hilite&quot; height=&quot;325&quot; src=&quot;https://static.righto.com/images/960-overview/cip-w500.jpg&quot; title=&quot;The Common Integrated Processor for the F-22, presumably with i960 MX chips inside. It is the equivalent of two Cray supercomputers and was the world&#39;s most advanced, high-speed computer system for a fighter aircraft. Source: NARA/Hughes Aircraft Co./T.W. Goosman.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Common Integrated Processor for the F-22, presumably with i960 MX chips inside. It is the equivalent of two Cray supercomputers and was the world&#39;s most advanced, high-speed computer system for a fighter aircraft. Source: &lt;a href=&quot;https://nara.getarchive.net/media/a-close-up-view-of-the-common-integrated-processor-which-was-developed-for-704456&quot;&gt;NARA/Hughes Aircraft Co./T.W. Goosman&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Intel charged thousands of dollars for each i960 MX and each F-22 contained a cluster of 35 i960 MX processors, so the military
market was potentially lucrative. The Air Force originally planned to buy 750 planes, but cut this down to just 187, which must
have been a blow to Intel.
As for the Comanche helicopter, the Army planned to buy 1200 of them, but the program was canceled entirely after building two prototypes.
The point is that the military market is risky and low volume even in the best circumstances.&lt;span id=&quot;fnref:tredennick&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:tredennick&quot;&gt;21&lt;/a&gt;&lt;/span&gt;
In 1998, Intel decided to &lt;a href=&quot;https://www.militaryaerospace.com/computers/article/16710194/intel-set-to-quit-military-business&quot;&gt;leave&lt;/a&gt; the military business entirely, joining AMD and Motorola.&lt;/p&gt;
&lt;!--
The i960 MX was also used in the [MLRS rocket system](https://apps.dtic.mil/sti/pdfs/ADA295248.pdf) while its [ATACMS missile](https://archive.org/details/DTIC_ADA298330/page/n272/mode/1up) used
dual i960s.
--&gt;

&lt;p&gt;Foreign militaries also made use of the i960. In 2008 a businessman was sentenced to &lt;a href=&quot;https://www.justice.gov/archive/opa/pr/2008/June/08-ag-540.html&quot;&gt;35 months in prison&lt;/a&gt; for illegally exporting hundreds of i960 chips into India for use in the radar for the Tejas Light Combat Aircraft.&lt;/p&gt;
&lt;!-- http://archive.indianexpress.com/news/exhal-staffer-pleads-guilty-in-us-to-illegal-exports-for-indian-missile-programme/284734/0 --&gt;
&lt;!-- https://www.globalsecurity.org/military/world/india/lca-design.htm --&gt;

&lt;h2&gt;i960: the later years&lt;/h2&gt;
&lt;p&gt;By 1990, the i960 was selling well, but the landscape at Intel had changed.
The 386 processor was enormously successful, due to the Compaq Deskpro 386 and other systems, leading to Intel&#39;s first
billion-dollar quarter.
The 8086 had started as a stopgap processor to fill a temporary marketing need, but
now the x86 was Intel&#39;s moneymaking engine.
As part of a reorganization, the i960 project was transferred to Chandler, Arizona.
Much of the i960 team in Oregon moved to the newly-formed Pentium Pro team, while others ended up on the 486 DX2 processor.
This wasn&#39;t the end of the i960, but the intensity had reduced.&lt;/p&gt;
&lt;p&gt;To reduce system cost, Intel produced versions of the i960 that had a 16-bit bus, although the processor was 32 bits internally.
(This is the same approach that Intel used with the 8088 processor, a version of the 8086 processor with an 8-bit bus instead
of 16.)
The i960 SB had the &quot;Numerics&quot; architecture, that is, with a floating-point unit.
Looking at the die below, we can see that the SB design is rather &quot;lazy&quot;, simply the previous die (KA/KB/MC/XA) with a thin layer of circuitry around
the border to implement the 16-bit bus.
Even though the SB didn&#39;t support memory management or objects, Intel didn&#39;t remove that circuitry.
The process was reportedly moved from 1.5 microns to 1 micron, shrinking the die to 270 mils square.&lt;/p&gt;
&lt;!-- &quot;Intel adds low-end, high-end 960 processors&quot; from Microprocessor Reports --&gt;

&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/960SB.jpg&quot;&gt;&lt;img alt=&quot;Comparison of the original i960 die and the i960 SB. Photos courtesy of Antoine Bercovici.&quot; class=&quot;hilite&quot; height=&quot;391&quot; src=&quot;https://static.righto.com/images/960-overview/960SB-w700.jpg&quot; title=&quot;Comparison of the original i960 die and the i960 SB. Photos courtesy of Antoine Bercovici.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Comparison of the original i960 die and the i960 SB. Photos courtesy of Antoine Bercovici.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The next chip, the i960 SA, was the 16-bit-bus &quot;Core&quot; architecture, without floating point.
The SA was based on the SB but Intel finally removed unused functionality from the die, making the die about 24% smaller.
The diagram below shows how the address translation, translation lookaside buffer, and floating point unit were removed,
along with much of the microcode (yellow).
The instruction cache tags (purple), registers (orange), and execution unit (green) were moved to fit into the
available space.
The left half of the chip remained unchanged.
The driver circuitry around the edges of the chip was also tightened up, saving a bit of space.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/SB-SA.jpg&quot;&gt;&lt;img alt=&quot;This diagram compares the SB and SA chips. Photos courtesy of Antoine Bercovici.&quot; class=&quot;hilite&quot; height=&quot;383&quot; src=&quot;https://static.righto.com/images/960-overview/SB-SA-w700.jpg&quot; title=&quot;This diagram compares the SB and SA chips. Photos courtesy of Antoine Bercovici.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This diagram compares the SB and SA chips. Photos courtesy of Antoine Bercovici.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Intel introduced the high-performance Hx family around 1994.
This family was superscalar like the CA/CF, but the Hx chips also had a faster clock, had much more cache, and included additional functionality such
as timers and a guarded memory unit.
The Jx family was introduced as the midrange, cost-effective line, faster and better than the original chips but not superscalar like the Hx.
Intel attempted to move the i960 into the I/O controller market with the Rx family and the VH.&lt;span id=&quot;fnref:vh&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:vh&quot;&gt;23&lt;/a&gt;&lt;/span&gt;
This was part of Intel&#39;s Intelligent Input/Output specification (I2O), which was a failure overall.&lt;/p&gt;
&lt;p&gt;For a while, the i960 was a big success in the marketplace and was used in many products. Laser printers and graphical terminals were key applications, both taking
advantage of the i960&#39;s high speed to move pixels.
The i960 was the world&#39;s best-selling RISC chip in &lt;a href=&quot;https://www.intc.com/filings-reports/all-sec-filings/content/0000050863-95-000004/10-K.txt&quot;&gt;1994&lt;/a&gt;.
However, without focused development, the performance of the i960 fell behind the competition, and its market share rapidly dropped.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/market-share.jpg&quot;&gt;&lt;img alt=&quot;Market share of embedded RISC processors. From ExtremeTech.&quot; class=&quot;hilite&quot; height=&quot;211&quot; src=&quot;https://static.righto.com/images/960-overview/market-share-w350.jpg&quot; title=&quot;Market share of embedded RISC processors. From ExtremeTech.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Market share of embedded RISC processors. From &lt;a href=&quot;https://www.cs.drexel.edu/~jjohnson/2012-13/fall/cs281/resources/Embedded_Processors_(ExtremeTech).pdf&quot;&gt;ExtremeTech&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;By the late 1990s, the i960 was described with terms such as &quot;aging&quot;, &quot;venerable&quot;, and &quot;medieval&quot;.
In 1999, &lt;a href=&quot;https://websrv.cecs.uci.edu/~papers/mpr/MPR/19990510/130601.pdf&quot;&gt;Microprocessor Report&lt;/a&gt; described the situation:
&quot;The i960
survived on cast-off semiconductor processes two to three
generations old; the i960CA is still built in a 1.0-micron process (perhaps by little old ladies with X-Acto knives).&quot;&lt;span id=&quot;fnref:rubylith&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:rubylith&quot;&gt;22&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;One of the strongest competitors was DEC&#39;s powerful StrongARM processor design, a descendant of the ARM chip.
Even Intel&#39;s top-of-the-line i960HT
&lt;a href=&quot;https://websrv.cecs.uci.edu/~papers/mpr/MPR/ARTICLES/100201.pdf&quot;&gt;fared pitifully&lt;/a&gt;
against the StrongARM, with worse cost, performance, and power consumption.
In 1997, DEC sued Intel, claiming that the Pentium infringed ten of DEC&#39;s patents.
As part of the complex but mutually-beneficial &lt;a href=&quot;https://www.nytimes.com/1997/10/28/business/intel-and-digital-settle-lawsuit-and-make-deal.html&quot;&gt;1997 settlement&lt;/a&gt;, Intel obtained rights to the StrongARM chip.
As Intel turned its embedded focus from i960 to StrongARM,
&lt;a href=&quot;https://techmonitor.ai/technology/intel_speeds_up_the_i960_chip_by_adding_more_cache&quot;&gt;one writer&lt;/a&gt; wrote, &quot;Things are looking somewhat bleak for Intel Corp&#39;s ten-year-old i960 processor.&quot;
The i960 limped on for another decade until
Intel officially &lt;a href=&quot;https://www.theregister.com/2006/05/18/intel_cans_386_486_960_cpus/&quot;&gt;ended production&lt;/a&gt; in 2007.&lt;/p&gt;
&lt;!--
Ironically, the i960 outlasted the StrongARM, which Intel [abandoned](https://www.infoworld.com/article/2678798/intel-puts-strongarm-on-death-row.html) in 2004 for the follow-on XScale architecture.

--&gt;

&lt;!--
    [Fred Pollack](https://ieeexplore.ieee.org/author/37724570200), manager of the i960 architecture, became architecture
    manager of the Pentium Pro in 1990.
    Glenn Hinton, who led the superscalar i960 CA design, moved to the Pentium Pro team.
    Gurbir Singh and Nitin Sarangdhar, who designed the i960 bus, also moved to Pentium Pro team.
    Randy Steck, who (I think) designed the i960 MM, became project leader for the Pentium Pro.
    Bob Bentley moved from validation manager of the i960 to Director of pre-silicon validation for the Pentium Pro in 1992.
    The 486DX2 team was formed from engineeres from the i960 according to the book [Entrepreneurship and Innovation in Second Tier Regions](https://www.google.com/books/edition/Entrepreneurship_and_Innovation_in_Secon/OgUJJPuDvfQC?hl=en&amp;gbpv=1&amp;pg=PA102&amp;printsec=frontcover).
    --&gt;

&lt;!--
The i960 didn&#39;t end at that point of course; new engineers were brought in create the Hx and Hx processors, such as
Richard Brunner who joined Intel from DEC in 1992.
--&gt;
&lt;!-- https://www.linkedin.com/in/randy-steck-430821/details/experience/ --&gt;

&lt;h2&gt;RISC or CISC?&lt;/h2&gt;
&lt;p&gt;The i960 challenges the definitions of RISC and CISC processors.&lt;span id=&quot;fnref:risc&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:risc&quot;&gt;24&lt;/a&gt;&lt;/span&gt;
It is generally considered a RISC processor, but its architect
says &quot;RISC techniques were used for high performance, CISC techniques for ease of use.&quot;&lt;span id=&quot;fnref:upr&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:upr&quot;&gt;25&lt;/a&gt;&lt;/span&gt;
John Mashey of MIPS described it as on the RISC/CISC border&lt;span id=&quot;fnref:mashey&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:mashey&quot;&gt;26&lt;/a&gt;&lt;/span&gt;
while Steve Furber (co-creator of ARM) &lt;a href=&quot;https://amzn.to/3JyCoix&quot;&gt;wrote&lt;/a&gt; that it &quot;includes many RISC ideas, but it is not a simple chip&quot; with &quot;many
complex instructions which make recourse to microcode&quot; and a design that &quot;is more reminiscent of a complex,
mainframe architecture than a simple, pipelined RISC.&quot;
And they were talking about the i960 KB with the simple Numerics architecture, not the complicated Extended architecture!&lt;/p&gt;
&lt;p&gt;Even the basic Core architecture has many non-RISC-like features.
It has microcoded instructions that take multiple cycles (such as integer multiplication),
numerous addressing modes&lt;span id=&quot;fnref:addressing&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:addressing&quot;&gt;27&lt;/a&gt;&lt;/span&gt;, and unnecessary instructions (e.g. AND NOT as well as NOT AND).
It also has a large variety of datatypes, even more than the 432:
integer (8, 16, 32, or 64 bit), ordinal (8, 16, 32, or 64 bit),
decimal digits, bit fields, triple-word (96 bits), and quad-word (128 bits).
The Numerics architecture adds floating-point reals (32, 64, or 80 bit) while the Protected architecture adds byte strings
with decidedly CISC-like instructions to act on them.&lt;span id=&quot;fnref:string&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:string&quot;&gt;28&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;When you get to the Extended architecture with objects, process management, and interprocess communication instructions, the
large instruction set seems obviously CISC.&lt;span id=&quot;fnref:instruction-set&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:instruction-set&quot;&gt;29&lt;/a&gt;&lt;/span&gt; (The instruction set is essentially the same as 432 and the 432 is an extremely CISC processor.)
You could argue that the i960 Core architecture is RISC and the Extended architecture is CISC, but the problem is that they are identical chips.&lt;/p&gt;
&lt;p&gt;Of course, it doesn&#39;t really matter if the i960 is considered RISC, CISC, or CISC instructions running on a RISC core.
But the i960 shows that RISC and CISC aren&#39;t as straightforward as they might seem.&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;The i960 chips can be confusing since there are four architectures, along with scalar vs. superscalar, and multiple families over time.
I&#39;ve made the table below to summarize the i960 family and the approximate dates.
The upper entries are the scalar families while the lower entries are superscalar.
The columns indicate the four architectural variants; although the i960 started with four variants, eventually Intel
focused on only the Core.
Note that each &quot;x&quot; family represents multiple chips.&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
  table.i960 {border-collapse: collapse;}
  table.i960 th,td {padding: 0 5px;}
  table.i960 td {border-top: 1px solid #888;}
  table.i960 tr.ul td {border-top: none;}
  table.i960 th,td {border-left: 1px solid #888;}
  table.i960 th:first-child,td:first-child {border-left: none !important; border-right:none;}
  table.i960 tr.brk {border-top: 2px solid #888;}

&lt;/style&gt;

&lt;table class=&quot;i960&quot;&gt;
&lt;tr&gt;&lt;th&gt;Core&lt;/th&gt;&lt;th&gt;Numerics&lt;/th&gt;&lt;th&gt;Protected&lt;/th&gt;&lt;th&gt;Extended&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;/tr&gt;
&lt;tr class=&quot;brK&quot;&gt;&lt;td&gt;KA&lt;/td&gt;&lt;td&gt;KB&lt;/td&gt;&lt;td&gt;MC&lt;/td&gt;&lt;td&gt;XA&lt;/td&gt;&lt;td&gt;Original (1988)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;SA&lt;/td&gt;&lt;td&gt;SB&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;Entry level, 16-bit data bus (1991)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Jx&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;Midrange (1993-1998)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Rx,VH&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;I/O interface (1995-2001)&lt;/td&gt;&lt;/tr&gt;
&lt;tr class=&quot;brk&quot;&gt;&lt;td&gt;CA,CF&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;MM&lt;/td&gt;&lt;td&gt;MX&lt;/td&gt;&lt;td&gt;Superscalar (1989-1992)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Hx&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;Superscalar, higher performance (1994)&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;!--
I should point out that the Berkeley RISC paper considers one justification for an instruction to be that it is &quot;unsynthesizable&quot;,
that you can&#39;t replace it with multiple simpler instructions
This condition is met by the instructions for unforgeable object pointers, since they need to be implemented by the
processor. (That is, the instructions are needed for security and can&#39;t be replaced by other instructions, just like
a Supervisor Call instruction.)
Thus, you could argue that these instructions satisfy the RISC philosophy.
The Berkeley RISC paper also &quot;allows&quot; instructions that provide a strong performance benefit such as floating point,
although putting floating point in a RISC chip was controversial with many people.
--&gt;

&lt;p&gt;Although the i960 is now mostly forgotten, it was an innovative processor for the time.
The first generation was Intel&#39;s first RISC chip, but pushed the boundary of RISC with many CISC-like features.
The i960 XA literally set the standard for military computing, selected by the JIAWG as the military&#39;s architecture.
The i960 CA provided a performance breakthrough with its superscalar architecture.
But Moore&#39;s Law means that competitors can rapidly overtake a chip, and the i960 ended up as history.&lt;/p&gt;
&lt;p&gt;Thanks to Glen Myers, Kevin Kahn, Steven McGeady, and others from Intel for answering my questions about the i960. Thanks to Prof. Paul Lubeck for obtaining documentation for me.
I plan to write more, so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@kenshirriff@oldbytes.space&lt;/a&gt;
and Bluesky as &lt;a href=&quot;https://staging.bsky.app/profile/righto.com&quot;&gt;@righto.com&lt;/a&gt; so you can follow me there too.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:size&quot;&gt;
&lt;p&gt;The 432 used two chips for the processor and a third chip for I/O. At the time, these were said to be
&quot;three of the largest integrated circuits in history.&quot;
The first processor chip contained more than 100,000 devices, making it &quot;one of the densest VLSI circuits to have been fabricated so far.&quot;
The article also says that the 432 project &quot;was the largest investment in a single program that Intel has ever made.&quot;
See &lt;a href=&quot;https://worldradiohistory.com/Archive-Electronics/80s/81/Electronics-1981-02-24.pdf&quot;&gt;Ada determines architecture of 32-bit microprocessor&lt;/a&gt;, Electronics, Feb 24, 1981, pages 119-126, a very detailed article on the 432 written by the lead engineer and the team&#39;s manager.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:size&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:432&quot;&gt;
&lt;p&gt;The performance problems of the iAPX 432 were revealed by a student project at Berkeley, &lt;a href=&quot;https://dl.acm.org/doi/pdf/10.1145/641542.641545&quot;&gt;A performance evaluation of the Intel iAPX 432&lt;/a&gt;, which compared its performance with the VAX-11/780, Motorola 68000, and Intel 8086.
Instead of providing mainframe performance, the 432 had a fraction of the performance of the competing systems.
Another interesting paper is &lt;a href=&quot;https://dl.acm.org/doi/10.1145/45059.214411&quot;&gt;Performance effects of architectural complexity in the Intel 432&lt;/a&gt;, which examines in detail what the 432 did wrong.
It concludes that the 432 could have been significantly faster, but would still have been slower than its contemporaries.
An author of the paper was Robert Colwell, who was later hired by Intel and designed the highly-successful Pentium Pro architecture.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:432&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:286&quot;&gt;
&lt;p&gt;You might expect the 8086, 186, and 286 processors to form a nice progression, but it&#39;s a bit more complicated.
The 186 and 286 processors were released at the same time.
The 186 essentially took the 8086 and several support chips and integrated them onto a single die.
The 286, on the other hand, extended the 8086 with memory management.
However, its segment-based memory management was a bad design, using ideas from the Zilog MMU, and wasn&#39;t popular.
The 286 also had a protected mode, so multiple processes could be isolated from each other.
Unfortunately, protected mode had some serious problems.
Bill Gates famously called the 286 &quot;brain-damaged&quot;
echoing PC Magazine editor &lt;a href=&quot;https://archive.org/details/PCMAG/PC-Mag-1989-05-30/page/96/mode/2up&quot;&gt;Bill Machrone&lt;/a&gt;
and writer &lt;a href=&quot;https://books.google.com/books?id=HpsOD9ZeqScC&amp;amp;lpg=PA62&amp;amp;pg=PA62#v=onepage&amp;amp;q&amp;amp;f=false&quot;&gt;Jerry Pournelle&lt;/a&gt;,
who both wanted credit for originating the phrase.&lt;/p&gt;
&lt;p&gt;By 1984, however, the 286 was Intel&#39;s star due to growing sales of IBM PCs and compatibles that used the chip.
Intel&#39;s &lt;a href=&quot;https://www.intel.com/content/www/us/en/history/history-1984-annual-report.html&quot;&gt;1984 annual report&lt;/a&gt; featured
&quot;The Story of the 286&quot;, a glowing 14-page tribute to the 286.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:286&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:ibm286&quot;&gt;
&lt;p&gt;Given IBM&#39;s success with IBM PC, Intel was puzzled that IBM wasn&#39;t interested in the 386 processor.
It turned out that IBM had a plan to regain control of the PC so they could block out competitors that were manufacturing IBM PC compatibles.
IBM planned to reverse-engineer Intel&#39;s 286 processor and build its own version. The computers would run the OS/2
operating system instead of Windows and use the proprietary Micro Channel architecture.
However, the reverse-engineering project failed and IBM eventually moved to the Intel 386 processor.
The IBM PS/2 line of computers, released in 1987, followed the rest of the plan.
However, the PS/2 line was largely unsuccessful; rather than regaining control over the PC, IBM ended up losing control
to companies such as Compaq and Dell.
(For more, see &lt;a href=&quot;https://amzn.to/3phNbGW&quot;&gt;Creating the Digital Future&lt;/a&gt;, page 131.)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:ibm286&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:386-oral-history&quot;&gt;
&lt;p&gt;The 386 team created an &lt;a href=&quot;http://archive.computerhistory.org/resources/text/Oral_History/Intel_386_Design_and_Dev/102702019.05.01.acc.pdf&quot;&gt;oral history&lt;/a&gt;
that describes the development of the 386 in detail. Pages 5, 6, and 19 are most relevant to this post.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:386-oral-history&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref2:386-oral-history&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:processor-numbers&quot;&gt;
&lt;p&gt;You might wonder why the processor was codenamed P4, since logically P4 should indicate the 486.
Confusingly, Intel&#39;s processor codenames were not always sequential and they sometimes reused numbers.
The numbers apparently started with P0, the codename for the Optimal Terminal Kit, a processor that didn&#39;t get beyond early planning.
P5 was used for the 432, P4 for the planned follow-on, P7 for the i960, P10 for the i960 CA, and P12 for the i960 MX.
(Apparently they thought that x86 wouldn&#39;t ever get to P4.)&lt;/p&gt;
&lt;p&gt;For the x86 processors, P1 through P6 indicated the 186, 286, 386, 486, 586, Pentium, and Pentium Pro as you&#39;d expect.
(The Pentium used a &lt;a href=&quot;https://en.wikipedia.org/wiki/Pentium_(original)#Cores_and_steppings&quot;&gt;variety&lt;/a&gt; of codes for various
versions, such as P54C, P24T, and P55C; I don&#39;t understand the pattern behind these.)
For some reason, the i486SX was the &lt;a href=&quot;https://www.cpu-world.com/forum/viewtopic.php?t=26657&quot;&gt;P23&lt;/a&gt; and the i486DX2 was the P24.
The Pentium 4 Willamette was the first new microarchitecture (NetBurst) since P6 so it was going to be P7,
but Itanium took the P7 name codename so Willamette
became P68. After that, processors were named after geographic features, avoiding the issues with numeric codenames.&lt;/p&gt;
&lt;p&gt;Other types of chips used different letter prefixes.
The 387 numeric coprocessor was the N3.
The i860 RISC processor was originally the N10, a numeric co-processor.
The follow-on i860 XP was the N11.
Support chips for the 486 included the C4 cache chip and the unreleased I4 interrupt controller.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:processor-numbers&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:80960&quot;&gt;
&lt;p&gt;At the time, Intel had a family of 16-bit embedded microcontrollers called &lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_MCS-96&quot;&gt;MCS-96&lt;/a&gt; featuring the 8096.
The 80960 name was presumably chosen to imply continuity with the 8096 16-bit microcontrollers (MCS-96), even though
the 8096 and the 80960 are completely different. (I haven&#39;t been able to confirm this, though.)
Intel started calling the chip the &quot;i960&quot; around 1989.
(Intel&#39;s chip branding is inconsistent: from 1987 to 1991, Intel&#39;s annual reports called the 386 processor the
80386, the 386, the Intel386, and the i386. I suspect their trademark lawyers were dealing with the problem that numbers
couldn&#39;t be trademarked, which was the motivation for the &quot;Pentium&quot; name rather than 586.)&lt;/p&gt;
&lt;p&gt;Note that the i860 processor is completely unrelated to the i960 despite the similar numbers.
They are both 32-bit RISC processors, but are architecturally unrelated.
The i860 was targeted at high-performance workstations, while the i960 was targeted at embedded applications.
For details on the i860, see &lt;a href=&quot;https://spectrum.ieee.org/intel-i860&quot;&gt;The first million-transistor chip&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:80960&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:fp-80387&quot;&gt;
&lt;p&gt;The Intel 80387 floating-point coprocessor chip used the same floating-point unit as the i960. The diagram below shows
the 80387; compare the floating-point unit in the lower right corner with the matching floating-point unit in the i960 KA
or SB die photo.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/80387.jpg&quot;&gt;&lt;img alt=&quot;The 80837 floating-point coprocessor with the main functional blocks labeled. Die photo courtesy of Antoine Bercovici. 80387 floor plan from The 80387 and its applications.&quot; class=&quot;hilite&quot; height=&quot;533&quot; src=&quot;https://static.righto.com/images/960-overview/80387-w500.jpg&quot; title=&quot;The 80837 floating-point coprocessor with the main functional blocks labeled. Die photo courtesy of Antoine Bercovici. 80387 floor plan from The 80387 and its applications.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 80837 floating-point coprocessor with the main functional blocks labeled. Die photo courtesy of Antoine Bercovici. 80387 floor plan from &lt;a href=&quot;https://doi.org/10.1109/MM.1987.304880&quot;&gt;The 80387 and its applications&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;!--  --&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:fp-80387&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:instruction-set-note&quot;&gt;
&lt;p&gt;I compared the instruction sets of the 432 and i960 and
the i960 Extended instruction set seems about
as close as you could get to the 432 while drastically changing the underlying architecture.
If you dig into the details of the object models, there are some differences.
Some instructions also have different names but the same function.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:instruction-set-note&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:myers&quot;&gt;
&lt;p&gt;The first i960 chips were described in detail in the 1988 book &lt;a href=&quot;https://archive.org/details/80960microproces0000myer&quot;&gt;The 80960 microprocessor architecture&lt;/a&gt; by Glenford Myers (who was responsible for the 80960 architecture at Intel) and David Budde (who
managed the VLSI development of the 80960 components).
This book discussed three levels of architecture (Core, Numerics, and Protected).
The book referred to the fourth level, the Extended architecture (XA), calling it &quot;a proprietary higher level of the
architecture developed for use by Intel in system products&quot; and did not discuss it further.
These &quot;system products&quot; were the systems being developed at BiiN.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:myers&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:extended&quot;&gt;
&lt;p&gt;I could find very little documentation on the Extended architecture.
The &lt;a href=&quot;http://www.bitsavers.org/components/intel/i960/271159-001_80960XA_Advance_Information_Oct90.pdf&quot;&gt;80960XA datasheet&lt;/a&gt;
provides a summary of the instruction set.
The i960 MX datasheet provides a similar summary; it is in the Intel Military and Special Products databook, which I
found after much difficulty.
The best description I could find is in the 400-page &lt;a href=&quot;http://bitsavers.org/pdf/biin/BiiN_CPU_Architecture_Reference_Man_Jul88.pdf&quot;&gt;BiiN CPU architecture reference manual&lt;/a&gt;.
Intel has other documents that I haven&#39;t been able to find anywhere: 
i960 MM/MX Processor Hardware Reference Manual, and Military i960 MM/MX Superscalar Processor.
(If you have one lying around, let me know.)&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;http://datasheets.chipdb.org/Intel/80960/specupdt/27286802.PDF&quot;&gt;80960MX Specification Update&lt;/a&gt; mentions a few things
about the MX processor. My favorite is that if you take the arctan of a value greater than 32768, the processor may lock
up and require a hardware reset. Oops.
The update also says that the product is sold in die and wafer form only, i.e. without packaging.
Curiously, earlier documentation said the chip was packaged in a 348-pin ceramic PGA package (with 213 signal pins and 122 power/ground pins).
I guess Intel ended up only supporting the bare die, as in the Hughes HAC-32 module.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:extended&quot; title=&quot;Jump back to footnote 11 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:features&quot;&gt;
&lt;p&gt;According to people who worked on the project, there were not even any bond wire changes or blown fuses to distinguish the chips
for the four different architectures.
It&#39;s possible that Intel used &lt;a href=&quot;https://en.wikipedia.org/wiki/Product_binning&quot;&gt;binning&lt;/a&gt;, selling dies as a lower
architecture if, for example, the floating point unit failed testing.
Moreover, the military chips presumably had much more extensive testing, checking the military temperature range for instance.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:features&quot; title=&quot;Jump back to footnote 12 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:no-connection&quot;&gt;
&lt;p&gt;The original i960 chips (KA/KB/MC/XA) have a large number of pins that are not connected (marked NC on the &lt;a href=&quot;http://www.bitsavers.org/components/intel/i960/271159-001_80960XA_Advance_Information_Oct90.pdf&quot;&gt;datasheet&lt;/a&gt;). This has led to
suspicious theorizing, even on &lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_i960#80960MX,_80960MC&quot;&gt;Wikipedia&lt;/a&gt;, that these pins were left unconnected to control access to various features.
This is false for two reasons. First, checking the datasheets shows that all four chips have the same pinout; there are no
pins connected only in the more advanced versions.
Second, looking at the packaged chip (below) explains why so many pins are unconnected: much of the chip has no bond pads,
so there is nothing to connect the pins to.
In particular, the right half of the die has only four bond pads for power.
This is an unusual chip layout, but presumably
the chip&#39;s internal buses made it easier to put all the connections at the left. The downside is that the package is
more expensive due to the wasted pins, but I expect that BiiN wasn&#39;t concerned about a few extra dollars for the package.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/Intel i80960MCacav.jpg&quot;&gt;&lt;img alt=&quot;The i960 MC die, bonded in its package. Photo courtesy of Antoine Bercovici.&quot; class=&quot;hilite&quot; height=&quot;400&quot; src=&quot;https://static.righto.com/images/960-overview/Intel i80960MCacav-w400.jpg&quot; title=&quot;The i960 MC die, bonded in its package. Photo courtesy of Antoine Bercovici.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The i960 MC die, bonded in its package. Photo courtesy of Antoine Bercovici.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;But you might wonder: the simple KA uses 32 bits and the complex XA uses 33 bits, so surely there must be another pin for the 33rd bit.
It turns out that pin F3 is called CACHE on the KA and CACHE/TAG on the XA.
The pin indicates if an access is cacheable, but the XA uses the pin during a different clock cycle to indicate whether
the 32-bit word is data or an access descriptor (unforgeable pointer).&lt;/p&gt;
&lt;p&gt;So how does the processor know if it should use the 33-bit object mode or plain 32-bit mode?
There&#39;s a processor control word called Processor Controls, that includes a Tag Enable bit. If this bit is set, the processor
uses the 33rd bit (the tag bit) to distinguish Access Descriptors from data.
If the bit is clear, the distinction is disabled and the processor runs in 32-bit mode.
(See &lt;a href=&quot;http://bitsavers.org/pdf/biin/BiiN_CPU_Architecture_Reference_Man_Jul88.pdf&quot;&gt;BiiN CPU Architecture Reference Manual&lt;/a&gt;
section 16.1 for details.)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:no-connection&quot; title=&quot;Jump back to footnote 13 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:objects-432&quot;&gt;
&lt;p&gt;The 432 and the i960 both had unforgeable object references, the Access Descriptor.
However, the two processors implemented Access Descriptors in completely different ways, which is kind of interesting.
The i960 used a 33rd bit as a Tag bit to distinguish an Access Descriptor from a regular data value.
Since the user didn&#39;t have access to the Tag bit, the user couldn&#39;t create or modify Access Descriptors.
The 432, on the other hand, used standard 32-bit words.
To protect Access Descriptors, each object was divided into two parts, each protected by a length field.
One part held regular data, while the other part held Access Descriptors.
The 432 had separate instructions to access the two parts of the object, ensuring that regular instructions could
not tamper with Access Descriptors.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:objects-432&quot; title=&quot;Jump back to footnote 14 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:biin&quot;&gt;
&lt;p&gt;The name &quot;BiiN&quot;
was developed by Lippincott &amp;amp; Margulies, a top design firm.
The name was designed for a strong logo, as well as referencing binary code (so it was pronounced as &quot;bine&quot;).
Despite this pedigree, &quot;BiiN&quot; was called one of the worst-sounding names in the computer industry, see &lt;a href=&quot;https://books.google.com/books?id=w3Tf3RomuEsC&amp;amp;lpg=PP63&amp;amp;pg=PP63#v=onepage&amp;amp;q&amp;amp;f=false&quot;&gt;Losing the Name Game&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:biin&quot; title=&quot;Jump back to footnote 15 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:xa&quot;&gt;
&lt;p&gt;Some sources say that BiiN used the i960 MX, not the XA, but they are confused.
A &lt;a href=&quot;https://doi.org/10.1109/CMPCON.1990.63666&quot;&gt;paper from BiiN&lt;/a&gt; states that BiiN used the 80960 XA.
(Sadly, BiiN was so short-lived that the papers introducing the BiiN system also include its demise.)
Moreover, BiiN shut down in 1989 while the i960 MX was introduced in 1990, so the timeline doesn&#39;t work.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:xa&quot; title=&quot;Jump back to footnote 16 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:ca&quot;&gt;
&lt;p&gt;The superscalar i960 architecture is described in detail in
&lt;a href=&quot;https://doi.org/10.1109/CMPCON.1990.63681&quot;&gt;The i960CA SuperScalar implementation of the 80960 architecture&lt;/a&gt;
and
&lt;a href=&quot;https://doi.org/10.1016/0141-9331(90)90111-8&quot;&gt;Inside Intel&#39;s i960CA superscalar processor&lt;/a&gt;
while the military MM version is described in
&lt;a href=&quot;https://doi.org/10.1109/CMPCON.1991.128774&quot;&gt;Performance enhancements in the superscalar i960MM embedded microprocessor&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:ca&quot; title=&quot;Jump back to footnote 17 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:mm&quot;&gt;
&lt;p&gt;I don&#39;t have a die photo of the i960 MM, so I&#39;m not certain of the relationship
between the MM and the MX.
The published MM die size is approximately the same as the MX. The MM block diagram matches the MX, except using 32 bits
instead of 33.
Thus, I think the MM uses the MX die, ignoring the Extended features, but I can&#39;t confirm this.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:mm&quot; title=&quot;Jump back to footnote 18 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:ada&quot;&gt;
&lt;p&gt;The military&#39;s Ada mandate remained in place for a decade until it was &lt;a href=&quot;https://people.cs.kuleuven.be/~dirk.craeynest/ada-belgium/archive/ase/ase02_01/docs/pol_hist/oasd497.shtml&quot;&gt;eliminated&lt;/a&gt; in 1997.
Ada continues to be used by the military and other applications that require high reliability, but by now C++ has mostly replaced it.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:ada&quot; title=&quot;Jump back to footnote 19 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:standard&quot;&gt;
&lt;p&gt;The military standard was decided by the Joint Integrated Avionics Working Group, known as JIAWG.
Earlier, in 1980, the military formed a 16-bit computing standard, MIL-STD-1750A. The 1750A standard created a new architecture,
and numerous companies implemented 1750A-compatible processors.
Many systems used 1750A processors and overall it was more successful than the JIAWG standard.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:standard&quot; title=&quot;Jump back to footnote 20 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:tredennick&quot;&gt;
&lt;p&gt;Chip designer and curmudgeon Nick Tredennick described the market for Intel&#39;s 960MX processor:
&quot;Intel invested considerable money and effort in the design of the 80960MX processor, for which, at the time of implementation,
the only known application was the YF-22 aircraft.
When the only prototype of the YF-22 crashed, the application volume for the 906MX actually went to zero; but even if the
program had been successful, Intel could not have expected to sell more than a few thousand processors for that application.&quot;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:tredennick&quot; title=&quot;Jump back to footnote 21 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:rubylith&quot;&gt;
&lt;p&gt;In the early 1970s, chip designs were created by cutting large sheets of Rubylith film with X-Acto knives.
Of course, that technology was long gone by the time of the i960.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/rubylith.png&quot;&gt;&lt;img alt=&quot;Intel photo of two women cutting Rubylith.&quot; class=&quot;hilite&quot; height=&quot;391&quot; src=&quot;https://static.righto.com/images/960-overview/rubylith-w500.png&quot; title=&quot;Intel photo of two women cutting Rubylith.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Intel photo of two women cutting Rubylith.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- --&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:rubylith&quot; title=&quot;Jump back to footnote 22 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:vh&quot;&gt;
&lt;p&gt;The Rx I/O processor chips combined a Jx processor core with a PCI bus interface and other hardware.
The RM and RN versions were introduced in 2000 with a hardware XOR engine for RAID disk array parity calculations.
The i960 VH (1998) was similar to Rx, but had only one PCI bus, no APIC bus, and was based on the JT core.
The 80303 (&lt;a href=&quot;https://www.edn.com/intel-pushes-i960-to-the-max-with-meaty-80303-device/&quot;&gt;2000&lt;/a&gt;) was the end of the i960 I/O
processors.
The 80303 was given a numeric name instead of an i960 name because Intel was transitioning from i960 to XScale
at the time.
The numeric name makes it look like a smooth transition from the 80303 (i960) I/O processor to the XScale-based I/O processors such as the 80333.
The 803xx chips were also called IOP3xx (I/O Processor); some were chipsets with a separate XScale processor chip and an I/O companion chip.
&lt;!-- &lt;a href=&quot;https://datasheet.octopart.com/GC80303-S-L57T-Intel-datasheet-147318.pdf&quot;&gt;80303 datasheet&lt;/a&gt; --&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:vh&quot; title=&quot;Jump back to footnote 23 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:risc&quot;&gt;
&lt;p&gt;Although the technical side of RISC vs. CISC is interesting, what I find most intriguing is the &quot;social history&quot; of
RISC:
how did a computer architecture issue from the 1980s become a topic that people still vigorously argue over 40 years later?
I see several factors that keep the topic interesting:
&lt;ul&gt;
&lt;li&gt;RISC vs. CISC has a large impact on not only computer architects but also developers and users.
&lt;li&gt;The topic is simple enough that everyone can have an opinion. It&#39;s also vague enough that nobody agrees on definitions, so there&#39;s lots to argue about.
&lt;li&gt;There are winners and losers, but no resolution.
RISC sort of won in the sense that almost all new instruction set architectures have been RISC.
But CISC has won commercially with the victory of x86 over SPARC, PowerPC, Alpha, and other RISC contenders.
But ARM dominates mobile and is moving into personal computers through Apple&#39;s new processors.
If RISC had taken over in the 1980s as expected, there wouldn&#39;t be anything to debate. But x86 has prospered despite the efforts of everyone (including Intel) to move beyond it.
&lt;li&gt;RISC vs. CISC takes on a &quot;personal identity&quot; aspect.
For instance, if you&#39;re an &quot;Apple&quot; person, you&#39;re probably going to be cheering for ARM and RISC.
But nobody cares about branch prediction strategies or caching.
&lt;/ul&gt;&lt;/p&gt;
&lt;p&gt;My personal opinion is that it is a mistake to consider RISC and CISC as objective, binary categories.
(Arguing over whether ARM or the 6502 is really RISC or CISC is like arguing over whether &lt;a href=&quot;https://twitter.com/matttomic/status/859117370455060481/photo/1.&quot;&gt;a hotdog is a sandwich&lt;/a&gt;
RISC is more of a social construct, a design philosophy/ideology that leads to a general kind of instruction set architecture
that leads to various implementation techniques.&lt;/p&gt;
&lt;p&gt;Moreover, I view RISC vs. CISC as mostly irrelevant since the 1990s due to convergence between RISC and CISC architectures.
In particular, the Pentium Pro (1995) decoded CISC instructions into &quot;RISC-like&quot; micro-operations that are executed by a superscalar
core, surprising people by achieving RISC-like performance from a CISC processor.
This has been viewed as a victory for CISC, a victory for RISC, nothing to do with RISC, or an indication that RISC and CISC have converged.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:risc&quot; title=&quot;Jump back to footnote 24 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:upr&quot;&gt;
&lt;p&gt;The quote is from Microprocessor Report April 1988, &quot;Intel unveils radical new CPU family&quot;, reprinted in &quot;Understanding RISC Microprocessors&quot;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:upr&quot; title=&quot;Jump back to footnote 25 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:mashey&quot;&gt;
&lt;p&gt;John Mashey of MIPS wrote an interesting article &quot;CISCs are Not RISCs, and Not Converging Either&quot; in the
March 1992 issue of Microprocessor Report, extending a &lt;a href=&quot;https://yarchive.net/comp/risc_definition.html&quot;&gt;Usenet thread&lt;/a&gt;.
It looks at multiple quantitative factors of various processors and finds a sharp line between CISC processors and most RISC processors.
The i960, Intergraph Clipper, and (probably) ARM, however, were &quot;truly on the RISC/CISC border, and, in fact, are often described
that way.&quot;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:mashey&quot; title=&quot;Jump back to footnote 26 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:addressing&quot;&gt;
&lt;p&gt;The i960 datasheet lists an extensive set of addressing modes, more than typical for a RISC chip:&lt;ul&gt;
&lt;li&gt;12-bit offset
&lt;li&gt;32-bit offset
&lt;li&gt;Register-indirect
&lt;li&gt;Register + 12-bit offset
&lt;li&gt;Register + 32-bit offset
&lt;li&gt;Register + index-register&amp;times;scale-factor
&lt;li&gt;Register&amp;times;scale-factor + 32-bit displacement
&lt;li&gt;Register + index-register&amp;times;scale-factor + 32-bit displacement
&lt;/ul&gt;
where the scale-factor is 1, 2, 4, 8, or 16.&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://media.digikey.com/pdf/Data%20Sheets/Intel%20PDFs/80960KA.pdf&quot;&gt;80960KA embedded 32-bit microprocessor&lt;/a&gt; datasheet for more information.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:addressing&quot; title=&quot;Jump back to footnote 27 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:string&quot;&gt;
&lt;p&gt;The i960 MC has string instructions that move, scan, or fill a string of bytes with a specified length.
These are similar to the x86 string operations, but these are very unusual for a RISC processor.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:string&quot; title=&quot;Jump back to footnote 28 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:instruction-set&quot;&gt;
&lt;p&gt;The iAPX 432 instruction set is described in detail in chapter 10 of the
&lt;a href=&quot;http://www.bitsavers.org/components/intel/iAPX_432/171860-004_iAPX_432_General_Data_Processor_Architecture_Reference_Manual_Feb84.pdf&quot;&gt;iAPX 432 General Data Processor Architecture Reference Manual&lt;/a&gt;; the instructions are called &quot;operators&quot;.
The i960 Protected instruction set is listed in the &lt;a href=&quot;http://www.bitsavers.org/components/intel/i960/271081-001_80960MC_Programmers_Reference_Manual_Jul88.pdf&quot;&gt;80960MC Programmer&#39;s Reference Manual&lt;/a&gt;
while the i960 Extended instruction set is described in the
&lt;a href=&quot;http://bitsavers.org/pdf/biin/BiiN_CPU_Architecture_Reference_Man_Jul88.pdf&quot;&gt;BiiN CPU architecture reference manual&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The table below shows the instruction set for the Extended architecture, the full
set of object-oriented instructions.
The instruction set includes typical RISC instructions (data movement, arithmetic, logical, comparison, etc), floating point instructions (for the Numerics architecture),
process management instructions (for the Protected architecture), and the Extended object instructions (Access Descriptor operations).
The &quot;Mixed&quot; instructions handle 33-bit values that can be either a tag (object pointer) or regular data.
Note that many of these instructions have separate opcodes for different datatypes, so the complete instruction set is larger than
this list, with about 240 opcodes.&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:instruction-set&quot; title=&quot;Jump back to footnote 29 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;a href=&quot;https://static.righto.com/images/960-overview/instruction-set.png&quot;&gt;&lt;img alt=&quot;The Extended instruction set, from the i960 XA datasheet. Click for a larger version.&quot; class=&quot;hilite&quot; height=&quot;778&quot; src=&quot;https://static.righto.com/images/960-overview/instruction-set-w600.png&quot; title=&quot;The Extended instruction set, from the i960 XA datasheet. Click for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Extended instruction set, from the i960 XA datasheet. Click for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/2731307596521436851/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=2731307596521436851' title='22 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/2731307596521436851'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/2731307596521436851'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/07/the-complex-history-of-intel-i960-risc.html' title='The complex history of the Intel i960 RISC processor'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>22</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-7453359098571162761</id><published>2023-05-13T15:42:00.004-07:00</published><updated>2023-05-14T11:38:06.398-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="intel"/><category scheme="http://www.blogger.com/atom/ns#" term="microcode"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>The Group Decode ROM: The 8086 processor&#39;s first step of instruction decoding</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;
&lt;style&gt;
  pre.microcode {font-family: courier, fixed; padding: 10px; background-color: #f5f5f5; display:inline-block;border:none;}
  pre.microcode span {color: green; font-style:italic; font-family: sans-serif; font-size: 90%;}
&lt;/style&gt;

&lt;p&gt;A key component of any processor is instruction decoding: analyzing a numeric opcode and figuring out
what actions need to be taken.
The Intel 8086 processor (1978) has a complex instruction set, making instruction decoding a challenge.
The first step in decoding an 8086 instruction is something called the Group Decode ROM, which categorizes
instructions into about 35 types that control how the instruction is decoded and executed.
For instance, the Group Decode ROM determines if an instruction is executed in hardware or in microcode.
It also indicates how the instruction is structured: if the instruction has a bit specifying a byte or word operation,
if the instruction has a byte that specifies the addressing mode, and so forth.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-group/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;633&quot; src=&quot;https://static.righto.com/images/8086-group/die-labeled-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The diagram above shows the position of the Group Decode ROM on the silicon die, as well as other key functional blocks.
The 8086 chip is partitioned into a Bus Interface Unit that communicates with external components such as memory,
and the Execution Unit that executes instructions.
Machine instructions are fetched from memory by the Bus Interface Unit and stored in the prefetch queue registers,
which hold 6 bytes of instructions.
To execute an instruction, the queue bus transfers an instruction byte from the prefetch queue to the instruction register, under control of a state machine called the Loader.
Next, the Group Decode ROM categorizes the instruction according to its structure.
In most cases, the machine instruction is implemented in low-level microcode. The instruction byte is transferred
to the Microcode Address Register, where the Microcode Address Decoder selects the appropriate microcode routine
that implements the instruction.
The microcode provides the micro-instructions that control the Arithmetic/Logic Unit (ALU), registers, and other
components to execute the instruction.&lt;/p&gt;
&lt;p&gt;In this blog post, I will focus on a small part of this process: how the Group Decode ROM decodes instructions.
Be warned that this post gets down into the weeds, so you might want to start with one of my higher-level
posts, such as &lt;a href=&quot;https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html&quot;&gt;how the 8086&#39;s microcode engine works&lt;/a&gt;.&lt;/p&gt;
&lt;!--
According to patent [4449184](https://patents.google.com/patent/US4449184A),
&quot;A group decode ROM has its
inputs coupled to the instruction register. The group
decode ROM generates a plurality of group decode
signals which are indicative of the genera of the single
byte and multiple byte instructions being received and
decoded by the lower control means.&quot;
--&gt;

&lt;h2&gt;Microcode&lt;/h2&gt;
&lt;p&gt;Most instructions in the 8086 are implemented in microcode.
Most people think of machine instructions as the basic steps that a computer performs.
However, many processors have another layer of software underneath: microcode.
With microcode, instead of building the CPU&#39;s control circuitry from complex logic gates, the control logic is largely replaced with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.&lt;/p&gt;
&lt;p&gt;Microcode is only used if the Group Decode ROM indicates that the instruction is implemented in microcode.
In that case, the microcode address register is loaded with the instruction and the address decoder selects
the appropriate microcode routine.
However, there&#39;s a complication. If the second byte of the instruction is a Mod R/M byte, the Group Decode ROM
indicates this and causes a memory addressing micro-subroutine to be called.&lt;/p&gt;
&lt;p&gt;Some simple instructions are implemented entirely in hardware and don&#39;t use microcode.
These are known as 1-byte logic instructions (1BL) and are also indicated by the Group Decode ROM.&lt;/p&gt;
&lt;h2&gt;The Group Decode ROM&#39;s structure&lt;/h2&gt;
&lt;p&gt;The Group Decode ROM takes an 8-bit instruction as input, along with an interrupt signal.
It produces 15 outputs that control how the instruction is handled.
In this section I&#39;ll discuss the physical implementation of the Group Decode ROM; the various outputs
are discussed in a later section.&lt;/p&gt;
&lt;p&gt;Although the Group Decode ROM is called a ROM, its implementation is really a PLA (Programmable Logic Array),
two levels of highly-structured logic gates.&lt;span id=&quot;fnref:rom&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:rom&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
The idea of a PLA is to create two levels of NOR gates, each in a grid.
This structure has the advantages that it implements the logic densely and is easy to modify.
Although physically two levels of NOR gates, a PLA can be thought of as an &lt;code&gt;AND&lt;/code&gt; layer followed by an &lt;code&gt;OR&lt;/code&gt; layer.
The &lt;code&gt;AND&lt;/code&gt; layer matches particular bit patterns and then the &lt;code&gt;OR&lt;/code&gt; layer combines multiple values from the first
layer to produce arbitrary outputs.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-group/rom-labeled.jpg&quot;&gt;&lt;img alt=&quot;The Group Decode ROM. This photo shows the metal layer on top of the die.&quot; class=&quot;hilite&quot; height=&quot;443&quot; src=&quot;https://static.righto.com/images/8086-group/rom-labeled-w600.jpg&quot; title=&quot;The Group Decode ROM. This photo shows the metal layer on top of the die.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Group Decode ROM. This photo shows the metal layer on top of the die.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Since the output values are highly structured, a PLA implementation is considerably more efficient than a ROM, since in a sense
it combines multiple entries.
In the case of the Group Decode ROM, using a ROM structure would require 256 columns (one for each 8-bit instruction pattern),
while the PLA implementation requires just 36 columns, about 1/7 the size.&lt;/p&gt;
&lt;p&gt;The diagram below shows how one column of the Group Decode ROM is wired in the &quot;AND&quot; plane.
In this die photo, I removed the metal layer with acid to reveal the polysilicon and silicon underneath.
The vertical lines show where the metal line for ground and the column output had been.
The basic idea is that each column implements a NOR gate, with a subset of the input lines selected as inputs to the
gate.
The pull-up resistor at the top pulls the column line high by default. But if any of the selected inputs are high,
the corresponding transistor turns on, connecting the column line to ground and pulling it low.
Thus, this implements a NOR gate.
However, it is more useful to think of it as an AND of the complemented inputs (via &lt;a href=&quot;https://en.wikipedia.org/wiki/De_Morgan%27s_laws&quot;&gt;De Morgan&#39;s Law&lt;/a&gt;):
if all the inputs are &quot;correct&quot;, the output is high.
In this way, each column matches a particular bit pattern.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-group/column-labeled.jpg&quot;&gt;&lt;img alt=&quot;Closeup of a column in the Group Decode ROM.&quot; class=&quot;hilite&quot; height=&quot;575&quot; src=&quot;https://static.righto.com/images/8086-group/column-labeled-w280.jpg&quot; title=&quot;Closeup of a column in the Group Decode ROM.&quot; width=&quot;280&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Closeup of a column in the Group Decode ROM.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The structure of the ROM is implemented through the silicon doping pattern, which is visible above.
A transistor is formed where a polysilicon wire crosses a doped silicon region: the polysilicon forms the gate, turning the transistor on or off.
At each intersection point, a transistor can be created or not, depending on the doping pattern.
If a particular transistor is created, then the corresponding input must be 0 to produce a high output.&lt;/p&gt;
&lt;p&gt;At the top of the diagram above, the column outputs are switched from the metal layer to polysilicon wires and become the inputs to the upper &quot;OR&quot;
plane.
This plane is implemented in a similar fashion as a grid of NOR gates.
The plane is rotated 90 degrees, with the inputs vertical and each row forming an output.&lt;/p&gt;
&lt;h2&gt;Intermediate decoding in the Group Decode ROM&lt;/h2&gt;
&lt;p&gt;The first plane of the Group Decode ROM categorizes instructions into 36 types based on the instruction bit pattern.&lt;span id=&quot;fnref:36&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:36&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
The table below shows the 256 instruction values, colored according to their categorization.&lt;span id=&quot;fnref:octal&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:octal&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
For instance, the first blue block consists of the 32 ALU instructions
corresponding to the bit pattern &lt;code&gt;00XXX0XX&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; indicates that the bit can be 0 or 1.
These instructions are all decoded and executed in a similar way.
Almost all instructions have a single category, that is, they activate a single column line in the Group Decode ROM. However, a few instructions activate two lines and have two colors below.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-group/grid.png&quot;&gt;&lt;img alt=&quot;Grid of 8086 instructions, colored according to the first level of the Group Decode Rom.&quot; class=&quot;hilite&quot; height=&quot;600&quot; src=&quot;https://static.righto.com/images/8086-group/grid-w600.png&quot; title=&quot;Grid of 8086 instructions, colored according to the first level of the Group Decode Rom.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Grid of 8086 instructions, colored according to the first level of the Group Decode Rom.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Note that the instructions do not have arbitrary numeric opcodes, but are assigned in a way that makes decoding simpler.
Because these blocks correspond to bit patterns, there is little flexibility. 
One of the challenges of instruction set design for early microprocessors was to assign numeric values to the opcodes
in a way that made decoding straightforward.
It&#39;s a bit like a jigsaw puzzle, fitting the instructions into the 256 available values, while making them easy to decode. &lt;/p&gt;
&lt;h2&gt;Outputs from the Group Decode ROM&lt;/h2&gt;
&lt;p&gt;The Group Decode ROM has 15 outputs, one for each row of the upper half.
In this section, I&#39;ll briefly discuss these outputs and their roles in the 8086.
For an interactive exploration of these signals, see &lt;a href=&quot;https://righto.com/8086/groupRom.html&quot;&gt;this page&lt;/a&gt;,
which shows the outputs that are triggered by each instruction.&lt;/p&gt;
&lt;p&gt;Out 0 indicates an &lt;code&gt;IN&lt;/code&gt; or &lt;code&gt;OUT&lt;/code&gt; instruction.
This signal controls the M/IO (S2) status line, which distinguishes between a memory read/write and an I/O read/write.
Apart from this, memory and I/O accesses are basically the same.&lt;/p&gt;
&lt;p&gt;Out 1 indicates (inverted) that the instruction has a Mod R/M byte and performs a read/modify/write on its argument. This signal is used by the Translation ROM when dispatching
an address handler (&lt;a href=&quot;https://www.righto.com/2023/02/8086-modrm-addressing.html&quot;&gt;details&lt;/a&gt;).
(This signal distinguishes between, say, &lt;code&gt;ADD [AX],BX&lt;/code&gt; and &lt;code&gt;MOV [AX],BX&lt;/code&gt;.
The former both reads and writes &lt;code&gt;[AX]&lt;/code&gt;, while the latter only writes to it.)&lt;/p&gt;
&lt;p&gt;Out 2 indicates a &quot;group 3/4/5&quot; opcode, an instruction where the second byte specifies the particular instruction,
and thus decoding needs to wait for the second byte.
This controls the loading of the microcode address register.&lt;/p&gt;
&lt;p&gt;Out 3 indicates an instruction prefix (segment, &lt;code&gt;LOCK&lt;/code&gt;, or &lt;code&gt;REP&lt;/code&gt;).
This causes the next byte to be decoded as a new instruction, while blocking interrupt handling.&lt;/p&gt;
&lt;p&gt;Out 4 indicates (inverted) a two-byte ROM instruction (2BR), i.e. an instruction is handled by the microcode ROM, but
requires the second byte for decoding.
This is an instruction with a Mod R/M byte.
This signal controls the loader indicating that it needs to fetch the second byte.
This signal is almost the same as output 1 with a few differences.&lt;/p&gt;
&lt;p&gt;Out 5 specifies the top bit for an ALU operation. The 8086 uses a 5-bit field to specify an ALU operation.
If not specified explicitly by the microcode, the field uses bits 5 through 3 of the opcode.
(These bits distinguish, say, an &lt;code&gt;ADD&lt;/code&gt; instruction from &lt;code&gt;AND&lt;/code&gt; or &lt;code&gt;SUB&lt;/code&gt;.)
This control line sets the top bit of the ALU field for instructions such as &lt;code&gt;DAA&lt;/code&gt;, &lt;code&gt;DAS&lt;/code&gt;, &lt;code&gt;AAA&lt;/code&gt;, &lt;code&gt;AAS&lt;/code&gt;, &lt;code&gt;INC&lt;/code&gt;, and &lt;code&gt;DE&lt;/code&gt; that fall into a different set from the &quot;regular&quot; ALU instructions.&lt;/p&gt;
&lt;p&gt;Out 6 indicates an instruction that sets or clears a condition code directly: &lt;code&gt;CLC&lt;/code&gt;, &lt;code&gt;STC&lt;/code&gt;, &lt;code&gt;CLI&lt;/code&gt;, &lt;code&gt;STI&lt;/code&gt;, &lt;code&gt;CLD&lt;/code&gt;, or &lt;code&gt;STD&lt;/code&gt; (but not &lt;code&gt;CMC&lt;/code&gt;). This signal is used by the flag circuitry to update the condition code.&lt;/p&gt;
&lt;p&gt;Out 7 indicates an instruction that uses the &lt;code&gt;AL&lt;/code&gt; or &lt;code&gt;AX&lt;/code&gt; register, depending on the instruction&#39;s size bit.
(For instance &lt;code&gt;MOVSB&lt;/code&gt; vs &lt;code&gt;MOVSW&lt;/code&gt;.)
This signal is used by the register selection circuitry, the &lt;code&gt;M&lt;/code&gt; register specifically.&lt;/p&gt;
&lt;p&gt;Out 8 indicates a &lt;code&gt;MOV&lt;/code&gt; instruction that uses a segment register.
This signal is used by the register selection circuitry, the &lt;code&gt;N&lt;/code&gt; register specifically.&lt;/p&gt;
&lt;p&gt;Out 9 indicates the instruction has a &lt;code&gt;d&lt;/code&gt; bit, where bit 1 of the instruction swaps the source and destination.
This signal is used by the register selection circuitry, swapping the roles of the &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; registers according to the &lt;code&gt;d&lt;/code&gt; bit.&lt;/p&gt;
&lt;p&gt;Out 10 indicates a one-byte logic (1BL) instruction, a one-byte instruction that is implemented in logic, not microcode. These instructions are the prefixes, &lt;code&gt;HLT&lt;/code&gt;, and the condition-code instructions.
This signal controls the loader, causing it to move to the next instruction.&lt;/p&gt;
&lt;p&gt;Out 11 indicates instructions where bit 0 is the byte/word indicator. This signal controls the register handling
and the ALU functionality.&lt;/p&gt;
&lt;p&gt;Out 12 indicates an instruction that operates only on a byte: &lt;code&gt;DAA&lt;/code&gt;, &lt;code&gt;DAS&lt;/code&gt;, &lt;code&gt;AAA&lt;/code&gt;, &lt;code&gt;AAS&lt;/code&gt;, &lt;code&gt;AAM&lt;/code&gt;, &lt;code&gt;AAD&lt;/code&gt;, and &lt;code&gt;XLAT&lt;/code&gt;.
This signal operates in conjunction with the previous output to select a byte versus word.&lt;/p&gt;
&lt;p&gt;Out 13 forces the instruction to use a byte argument if instruction bit 1 is set, overriding the regular byte/word pattern. Specifically, it forces the &lt;code&gt;L8&lt;/code&gt; (length 8 bits) condition
for the &lt;code&gt;JMP&lt;/code&gt; direct-within-segment and the ALU instructions that are immediate with sign extension (&lt;a href=&quot;https://www.righto.com/2023/02/how-8086-processor-determines-length-of.html&quot;&gt;details&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Out 14 allows a carry update. This prevents the carry from being updated by the &lt;code&gt;INC&lt;/code&gt; and &lt;code&gt;DEC&lt;/code&gt; operations.
This signal is used by the flag circuitry.&lt;/p&gt;
&lt;h3&gt;Columns&lt;/h3&gt;
&lt;p&gt;Most of the Group Decode ROM&#39;s column signals are used to derive the outputs listed above.
However, some column outputs are also used as control signals directly. These are listed below.&lt;/p&gt;
&lt;p&gt;Column 10 indicates an immediate &lt;code&gt;MOV&lt;/code&gt; instruction. These instructions use instruction bit 3 (rather than bit 1) to select byte versus word, because the three low bits specify the register.
This signal affects the &lt;code&gt;L8&lt;/code&gt; condition described earlier and also causes the &lt;code&gt;M&lt;/code&gt; register selection to be converted from a word register to a byte register if necessary.&lt;/p&gt;
&lt;p&gt;Column 12 indicates an instruction with bits 5-3 specifying the ALU instruction.
This signal causes the &lt;code&gt;X&lt;/code&gt; register to be loaded with
the bits in the instruction that specify the ALU operation. (To be precise, this signal prevents the &lt;code&gt;X&lt;/code&gt; register
from being reloaded from the second instruction byte.)&lt;/p&gt;
&lt;p&gt;Column 13 indicates the &lt;code&gt;CMC&lt;/code&gt; (Complement Carry) instruction. This signal is used by the flags circuitry to complement the carry flag (&lt;a href=&quot;https://www.righto.com/2023/02/silicon-reverse-engineering-intel-8086.html&quot;&gt;details&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Column 14 indicates the &lt;code&gt;HLT&lt;/code&gt; (Halt) instruction. This signal stops instruction processing by blocking the instruction queue.&lt;/p&gt;
&lt;p&gt;Column 31 indicates a &lt;code&gt;REP&lt;/code&gt; prefix. This signal causes the REPZ/NZ latch to be loaded with instruction bit 0 to
indicate if the prefix is &lt;code&gt;REPNZ&lt;/code&gt; or &lt;code&gt;REPZ&lt;/code&gt;. It also sets the &lt;code&gt;REP&lt;/code&gt; latch.&lt;/p&gt;
&lt;p&gt;Column 32 indicates a segment prefix. This signal loads the segment latches with the desired segment type.&lt;/p&gt;
&lt;p&gt;Column 33 indicates a &lt;code&gt;LOCK&lt;/code&gt; prefix. It sets the &lt;code&gt;LOCK&lt;/code&gt; latch, locking the bus.&lt;/p&gt;
&lt;p&gt;Column 34 indicates a &lt;code&gt;CLI&lt;/code&gt; instruction. This signal immediately blocks interrupt handling to avoid an interrupt between the &lt;code&gt;CLI&lt;/code&gt; instruction and when the interrupt flag bit is cleared.&lt;/p&gt;
&lt;h2&gt;Timing&lt;/h2&gt;
&lt;p&gt;One important aspect of the Group Decode ROM is that its outputs are not instantaneous.
It takes a clock cycle to get the outputs from the Group Decode ROM.
In particular, when instruction decoding starts, the timing signal &lt;code&gt;FC&lt;/code&gt; (First Clock) is activated to indicate the first clock
cycle. However, the Group Decode ROM&#39;s outputs are not available until the Second Clock &lt;code&gt;SC&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;One consequence of this is that even the simplest instruction (such as a flag operation) takes two clock cycles, as does a prefix.
The problem is that even though the instruction could be performed in one clock cycle, it takes two clock cycles
for the Group Decode ROM to determine that the instruction only needs one cycle.
This illustrates how a complex instruction format impacts performance.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;FC&lt;/code&gt; and &lt;code&gt;SC&lt;/code&gt; timing signals are generated by a state machine called the Loader.
These signals may seem trivial, but there are a few complications.
First, the prefetch queue may run empty, in which case the &lt;code&gt;FC&lt;/code&gt; and/or &lt;code&gt;SC&lt;/code&gt; signal is delayed until the prefetch queue has a byte available.
Second, to increase performance, the 8086 can start decoding an instruction during the last clock cycle of the previous instruction.
Thus, if the microcode indicates that there is one cycle left, the Loader can proceed with the next instruction.
Likewise, for a one-byte instruction implemented in hardware (one-byte logic or 1BL), the loader proceeds
as soon as possible.&lt;/p&gt;
&lt;p&gt;The diagram below shows the timing of an &lt;code&gt;ADD&lt;/code&gt; instruction. Each line is half of a clock cycle.
Execution is pipelined: the instruction is fetched during the first clock cycle (First Clock).
During Second Clock, the Group Decode ROM produces its output. The microcode address register also generates
the micro-address for the instruction&#39;s microcode.
The microcode ROM supplies a micro-instruction during the third clock cycle and execution of the micro-instruction
takes place during the fourth clock cycle.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-group/diagram-labeled.jpg&quot;&gt;&lt;img alt=&quot;This diagram shows the execution of an ADD instruction and what is happening in various parts of the 8086. The arrows show the flow from step to step. The character  is short for &amp;quot;micro&amp;quot;.&quot; class=&quot;hilite&quot; height=&quot;395&quot; src=&quot;https://static.righto.com/images/8086-group/diagram-labeled-w750.jpg&quot; title=&quot;This diagram shows the execution of an ADD instruction and what is happening in various parts of the 8086. The arrows show the flow from step to step. The character  is short for &amp;quot;micro&amp;quot;.&quot; width=&quot;750&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This diagram shows the execution of an ADD instruction and what is happening in various parts of the 8086. The arrows show the flow from step to step. The character  is short for &quot;micro&quot;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The Group Decode ROM&#39;s outputs during Second Clock control the decoding.
Most importantly, the &lt;code&gt;ADD imm&lt;/code&gt; instruction used microcode; it is not a one-byte logic instruction (&lt;code&gt;1BL&lt;/code&gt;).
Moreover, it does not have a Mod R/M byte, so it does not need two bytes for decoding (&lt;code&gt;2BR&lt;/code&gt;).
For a &lt;code&gt;1BL&lt;/code&gt; instruction, microcode execution would be blocked and the next instruction would be immediately fetched.
On the other hand, for a &lt;code&gt;2BR&lt;/code&gt; instruction, the loader would tell the prefetch queue that it was done with the
second byte during the second half of Second Clock.
Microcode execution would be blocked during the third cycle and the fourth cycle would execute a microcode
subroutine to determine the memory address.&lt;/p&gt;
&lt;p&gt;For more details, see my article on the &lt;a href=&quot;https://www.righto.com/2023/01/the-8086-processors-microcode-pipeline.html&quot;&gt;8086 pipeline&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Interrupts&lt;/h2&gt;
&lt;p&gt;The Group Decode ROM takes the 8 bits of the instruction as inputs, but it has an additional input indicating that
an interrupt is being handled.
This signal blocks most of the Group Decode ROM outputs.
This prevents the current instruction&#39;s outputs from interfering with interrupt handling.
I wrote about the 8086&#39;s interrupt handling in detail &lt;a href=&quot;https://www.righto.com/2023/02/8086-interrupt.html&quot;&gt;here&lt;/a&gt;, so I won&#39;t go into more detail in this post.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The Group Decode ROM indicates one of the key differences between CISC processors (Complex Instruction Set Computer) such as the 8086 and the RISC processors (Reduced Instruction Set Computer) that became popular a few years later.
A RISC instruction set is designed to make instruction decoding very easy, with a small number of uniform instruction forms.
On the other hand, the 8086&#39;s CISC instruction set was designed for compactness and high code density.
As a result, instructions are squeezed into the available opcode space.
Although there is a lot of structure to the 8086 opcodes, this structure is full of special cases and any patterns only apply to a subset of the instructions.
The Group Decode ROM brings some order to this chaotic jumble of instructions, and the number of outputs
from the Group Decode ROM is a measure of the instruction set&#39;s complexity.&lt;/p&gt;
&lt;p&gt;The 8086&#39;s instruction set was extended over the decades to become the x86 instruction set in use today.
During that time, more layers of complexity were added to the instruction set.
Now, an x86 instruction can be up to 15 bytes long with multiple prefixes.
Some prefixes change the register encoding or indicate a completely different instruction set such as &lt;code&gt;VEX&lt;/code&gt; (Vector Extensions) or &lt;code&gt;SSE&lt;/code&gt; (Streaming SIMD Extensions).
Thus, x86 instruction decoding is very difficult, especially when trying to decode multiple instructions in parallel.
This has an impact in modern systems, where x86 processors typically have 4 complex instruction decoders while Apple&#39;s ARM processors have 8 simpler decoders; this is &lt;a href=&quot;https://debugger.medium.com/why-is-apples-m1-chip-so-fast-3262b158cba2&quot;&gt;said&lt;/a&gt; to give Apple a performance benefit.
Thus, architectural decisions from 45 years ago are still impacting the performance of modern processors.&lt;/p&gt;
&lt;p&gt;I&#39;ve written numerous &lt;a href=&quot;https://www.righto.com/search/label/8086&quot;&gt;posts on the 8086&lt;/a&gt; so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@kenshirriff@oldbytes.space&lt;/a&gt;.
Thanks to Arjan Holscher for suggesting this topic.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:rom&quot;&gt;
&lt;p&gt;You might wonder what the difference is between a ROM and a PLA.
Both of them produce arbitrary outputs for a set of inputs.
Moreover, you can replace a PLA with a ROM or vice versa.
Typically a ROM has all the input combinations decoded, so it has a separate row for each input value, i.e. 2&lt;sup&gt;N&lt;/sup&gt; rows.
So you can think of a ROM as a fully-decoded PLA.&lt;/p&gt;
&lt;p&gt;Some ROMs are partially decoded, allowing identical rows to be combined and reducing the size of the ROM.
This technique is used in the 8086 microcode, for instance.
A partially-decoded ROM is fairly similar to a PLA, but the technical distinction is that a ROM has
only one output row active at a time, while a PLA can have multiple output rows active and the results are
OR&#39;d together.
(This definition is from &lt;a href=&quot;https://amzn.to/3pzucaS&quot;&gt;The Architecture of Microprocessors&lt;/a&gt; p117.)&lt;/p&gt;
&lt;p&gt;The Group Decode ROM, however, has a few cases where multiple rows are active at the same time
(for instance the segment register &lt;code&gt;POP&lt;/code&gt; instructions).
Thus, the Group Decode ROM is technically a PLA and not a ROM.
This distinction isn&#39;t particularly important, but you might find it interesting.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:rom&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:36&quot;&gt;
&lt;p&gt;The Group Decode ROM has 38 columns, but two columns (11 and 35) are unused. Presumably, these were provided as spares
in case a bug fix or modification required additional decoding.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:36&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:octal&quot;&gt;
&lt;p&gt;Like the 8008 and 8080, the 8086&#39;s instruction set was designed around a 3-bit octal structure.
Thus, the 8086 instruction set makes much more sense if viewed in octal instead of hexadecimal.
The table below shows the instructions with an octal organization. Each 8&amp;times;8 block uses the two low
octal digits, while the four large blocks are positioned according to the top octal digit (labeled).
As you can see, the instruction set has a lot of structure that is obscured in the usual hexadecimal table.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-group/grid-octal.jpg&quot;&gt;&lt;img alt=&quot;The 8086 instruction set, put in a table according to the octal opcode value.&quot; class=&quot;hilite&quot; height=&quot;647&quot; src=&quot;https://static.righto.com/images/8086-group/grid-octal-w600.jpg&quot; title=&quot;The 8086 instruction set, put in a table according to the octal opcode value.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 instruction set, put in a table according to the octal opcode value.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;For details on the octal structure of the 8086 instruction set, see &lt;a href=&quot;https://gist.github.com/seanjensengrey/f971c20d05d4d0efc0781f2f3c0353da&quot;&gt;The 80x86 is an Octal Machine&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:octal&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/7453359098571162761/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=7453359098571162761' title='3 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/7453359098571162761'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/7453359098571162761'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/05/8086-processor-group-decode-rom.html' title='The Group Decode ROM: The 8086 processor&#39;s first step of instruction decoding'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-5693917346966509204</id><published>2023-04-08T08:01:00.000-07:00</published><updated>2023-04-08T08:01:52.481-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="chips"/><category scheme="http://www.blogger.com/atom/ns#" term="intel"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>Reverse-engineering the division microcode in the Intel 8086 processor</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;
&lt;style&gt;
  pre.microcode {font-family: courier, fixed; padding: 10px; background-color: #f5f5f5; display:inline-block;border:none;}
  pre.microcode span {color: green; font-style:italic; font-family: sans-serif; font-size: 90%;}
&lt;/style&gt;

&lt;p&gt;While programmers today take division for granted, most microprocessors in the 1970s could only add and subtract &amp;mdash; division required a slow and tedious loop implemented in assembly code.
One of the nice features of the Intel 8086 processor (1978) was
that it provided machine instructions for integer multiplication and division.
Internally, the 8086 still performed a loop, but the loop was implemented in microcode: faster and transparent to
the programmer.
Even so, division was a slow operation, about 50 times slower than addition.&lt;/p&gt;
&lt;p&gt;I recently examined &lt;a href=&quot;https://www.righto.com/2023/03/8086-multiplication-microcode.html&quot;&gt;multiplication in the 8086&lt;/a&gt;, and
now it&#39;s time to look at the division microcode.&lt;span id=&quot;fnref:microcode&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:microcode&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
(There&#39;s a lot of overlap with the multiplication post so apologies for any deja vu.)
The die photo below shows the chip under a microscope.
I&#39;ve labeled the key functional blocks; the ones that are important to this post are darker.
At the left, the ALU (Arithmetic/Logic Unit) performs the arithmetic operations at the heart of division: subtraction and shifts.
Division also uses a few special hardware features: the X register, the F1 flag, and a loop counter.
The microcode ROM at the lower right controls the process.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-div/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;592&quot; src=&quot;https://static.righto.com/images/8086-div/die-labeled-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Microcode&lt;/h2&gt;
&lt;p&gt;Like most instructions, the division routines in the 8086 are implemented in microcode.
Most people think of machine instructions as the basic steps that a computer performs.
However, many processors have another layer of software underneath: microcode.
With microcode, instead of building the CPU&#39;s control circuitry from complex logic gates, the control logic is largely replaced with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.
This is especially useful for a machine instruction such as division, which performs many steps in a loop.&lt;/p&gt;
&lt;!--
The 8086 uses a hybrid approach: although it uses microcode, much of the instruction functionality is implemented with gate logic.
This approach removed duplication from the microcode and kept the microcode small enough for 1978 technology.
In a sense, the microcode is parameterized.
For instance, the microcode can specify a generic Arithmetic/Logic Unit (ALU) operation and a generic register.
The gate logic examines the instruction to determine which specific operation to perform and the appropriate register.
--&gt;

&lt;p&gt;Each micro-instruction in the 8086 is encoded into 21 bits as shown below.
Every micro-instruction moves data from a source register to a destination register, each specified with 5 bits.
The meaning of the remaining bits depends on the type field and can be anything from an ALU operation to a memory read or write to
a change of microcode control flow.
Thus, an 8086 micro-instruction typically does two things in parallel: the move and the action.
For more about 8086 microcode, see my &lt;a href=&quot;https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html&quot;&gt;microcode blog post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-div/microcode-format.jpg&quot;&gt;&lt;img alt=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; class=&quot;hilite&quot; height=&quot;203&quot; src=&quot;https://static.righto.com/images/8086-div/microcode-format-w700.jpg&quot; title=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The encoding of a micro-instruction into 21 bits. Based on &lt;a href=&quot;https://digitalcommons.law.scu.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=1031&amp;context=chtlj&quot;&gt;NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;A few details of the ALU (Arithmetic/Logic Unit) operations are necessary to understand the division microcode.
The ALU has three temporary registers that are invisible to the programmer: tmpA, tmpB, and tmpC.
An ALU operation takes its first argument from the specified temporary register, while the second argument always comes from tmpB.
An ALU operation requires two micro-instructions.
The first micro-instruction specifies the ALU operation and source register, configuring the ALU. For instance, &lt;code&gt;ADD tmpA&lt;/code&gt; to add tmpA to the default tmpB.
In the next micro-instruction (or a later one), the ALU result can be accessed through a register called &lt;code&gt;&lt;/code&gt; (Sigma) and moved to another register.&lt;/p&gt;
&lt;p&gt;The carry flag plays a key role in division.
The carry flag is one of the programmer-visible status flags that is set by arithmetic operations, but it is also used
by the microcode.
For unsigned addition, the carry flag is set if there is a carry out of the word (or byte).
For subtraction, the carry flag indicates a borrow, and is set if the subtraction requires a borrow.
Since a borrow results if you subtract a larger number from a smaller number, the carry flag also indicates
the &quot;less than&quot; condition.
The carry flag (and other status flags) are only updated if micro-instruction contains the &lt;code&gt;F&lt;/code&gt; bit.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;RCL&lt;/code&gt; (Rotate through Carry, Left) micro-instruction is heavily used in the division microcode.&lt;span id=&quot;fnref:rcl&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:rcl&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
This operation shifts the bits in a 16-bit word, similar to the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; bit-shift operation in high-level languages, but with an additional feature.
Instead of discarding the bit on the end, that bit is moved into the carry flag. Meanwhile, the bit formerly in the carry flag moves into the word.
You can think of this as rotating the bits while treating the carry flag as a 17th bit of the word.
(The &lt;code&gt;RCL&lt;/code&gt; operation can also act on a byte.)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-div/lrcy.jpg&quot;&gt;&lt;img alt=&quot;The rotate through carry left micro-instruction.&quot; class=&quot;hilite&quot; height=&quot;51&quot; src=&quot;https://static.righto.com/images/8086-div/lrcy-w300.jpg&quot; title=&quot;The rotate through carry left micro-instruction.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The rotate through carry left micro-instruction.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;These shifts perform an important part of the division process since shifting can be viewed as multiplying or dividing by two.
&lt;code&gt;RCL&lt;/code&gt; also provides a convenient way to move the most-significant bit to the carry flag, where it can be tested for a conditional jump.
(This is important because the top bit is used as the sign bit.)
Another important property is that performing &lt;code&gt;RCL&lt;/code&gt; on a lower word and then &lt;code&gt;RCL&lt;/code&gt; on an upper word will perform a 32-bit shift, since
the high bit of the lower word will be moved into the low bit of the upper word via the carry bit.
Finally, the shift moves the quotient bit from the carry into the register.&lt;/p&gt;
&lt;h2&gt;Binary division&lt;/h2&gt;
&lt;p&gt;The division process in the 8086 is similar to grade-school long division, except in binary instead of decimal.
The diagram below shows the process: dividing 67 (the dividend) by 9 (the divisor) yields the quotient 7 at the top and the remainder 4 at the bottom.
Long division is easier in binary than decimal because you don&#39;t need to guess the right quotient digit.
Instead, at each step you either subtract the divisor (appropriately shifted)
or subtract nothing.
Note that although the divisor is 4 bits in this example, the subtractions use 5-bit values.
The need for an &quot;extra&quot; bit in division will be important in the discussion below; 16-bit division needs a 17-bit value.&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
table.divdia {border-collapse: collapse; font-family: &quot;courier-new&quot;, courier, monospace; padding: 5px;}
table.divdia tr.top {border-bottom: 1px solid #ccc;}
table.divdia tr.sum {border-top: 1px solid #ccc;}
table.divdia .dim {color: #aaa;}
table.divdia td.l {border-left: 2px solid #444;}
table.divdia td.t {border-top: 2px solid #444;}
table.divdia td.ul {border-bottom: 1px solid #888;}
&lt;/style&gt;
&lt;table class=&quot;divdia&quot;&gt;

&lt;tr&gt;&lt;td colspan=8&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td class=&quot;t l&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;t&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;t&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;t&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;t&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;t&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;t&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;t&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=4&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td class=&quot;ul dim&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;ul dim&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;ul dim&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;ul dim&quot;&gt;0&lt;/td&gt;
&lt;tr&gt;&lt;td colspan=5&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;u&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=5&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td class=&quot;ul&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;ul&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;ul&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;ul&quot;&gt;1&lt;/td&gt;
&lt;tr&gt;&lt;td colspan=6&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td class=&quot;u&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=6&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td class=&quot;ul&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;ul&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;ul&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;ul&quot;&gt;1&lt;/td&gt;
&lt;tr&gt;&lt;td colspan=7&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;u&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=7&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td class=&quot;ul&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;ul&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;ul&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;ul&quot;&gt;1&lt;/td&gt;
&lt;tr&gt;&lt;td colspan=8&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Instead of shifting the divisor to the right each step, the 8086&#39;s algorithm shifts the quotient and the current dividend
to the left each step.
This trick reduces the register space required.
Dividing a 32-bit number (the dividend) by a 16-bit number yields a 16-bit result, so it seems like you&#39;d need four 16-bit registers in
total.
The trick is that after each step, the 32-bit dividend gets one bit smaller, while the result gets one bit larger.
Thus, the dividend and the result can be packed together into 32 bits. At the end, what&#39;s left of the dividend is
the 16-bit remainder. The table below illustrates this process for a sample dividend (blue) and quotient (green).&lt;span id=&quot;fnref:table&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:table&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
At the end, the 16-bit blue value is the remainder.&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
table.div {border-collapse: collapse; border: 1px solid #888; font-family: &quot;courier-new&quot;, courier, monospace; padding: 5px;}
table.div th {border-bottom: 1px solid #444;}
table.div th:nth-child(1) {border-left: 1px solid #444;}
table.div th:nth-child(3) {border-left: 1px solid #444;}
table.div th:nth-child(4) {padding: 0 4px;}
table.div tr:nth-child(2) {border-bottom: 1px solid #444;}
table.div tr:nth-child(2) {border-bottom: 1px solid #444;}
table.div td:nth-child(8) {border-right: 1px solid #444;}
table.div td:nth-child(16) {border-right: 2px solid #444;}
table.div td:nth-child(24) {border-right: 1px solid #444;}
table.div td.a {background-color: #ddf;}
table.div td.b {background-color: #cfc;}
&lt;/style&gt;

&lt;table class=&quot;div&quot;&gt;

&lt;tr style=&quot;font-family: sans-serif; color: blue&quot;&gt;&lt;th colspan=16&gt;dividend&lt;/th&gt;&lt;th colspan=16 style=&quot;font-family:sans-serif; color: green&quot;&gt;quotient&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;h2&gt;The division microcode&lt;/h2&gt;
&lt;p&gt;The 8086 has four division instructions to handle signed and unsigned division of byte and word operands.
I&#39;ll start by describing the microcode for the unsigned word division instruction &lt;code&gt;DIV&lt;/code&gt;, which divides a 32-bit dividend by a 16-bit divisor.
The dividend is supplied in the AX and DX registers while the divisor is specified by the source operand.
The 16-bit quotient is returned in AX and the 16-bit remainder in DX.
For a divide-by-zero, or if the quotient is larger than 16 bits, a type 0 &quot;divide error&quot; interrupt is generated.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;CORD&lt;/code&gt;: The core division routine&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;CORD&lt;/code&gt; microcode subroutine below implements the long-division algorithm for all division instructions; I think &lt;code&gt;CORD&lt;/code&gt; stands for Core Divide.
At entry, the arguments are in the ALU temporary registers:
tmpA/tmpC hold the 32-bit dividend, while tmpB holds the 16-bit divisor.
(I&#39;ll explain the configuration for byte division later.)
Each cycle of the loop shifts the values and then potentially subtracts the divisor.
One bit is appended to the quotient to indicate whether the
divisor was subtracted or not.
At the end of the loop, whatever is left of the dividend is the remainder.&lt;/p&gt;
&lt;p&gt;Each micro-instruction specifies a register move on the left, and an action on the right.
The moves transfer words between the visible registers and the ALU&#39;s temporary registers, while the actions are mostly ALU operations or control flow.
As is usually the case with microcode, the details are tricky.
The first three lines below check if the division will overflow or divide by zero.
The code compares tmpA and tmpB by subtracting tmpB, discarding the result, but setting the status flags (&lt;code&gt;F&lt;/code&gt;).
If the upper word of the divisor is greater or equal to the dividend, the division will overflow, so execution jumps to &lt;code&gt;INT0&lt;/code&gt; to generate
a divide-by-zero interrupt.&lt;span id=&quot;fnref:interrupts&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:interrupts&quot;&gt;4&lt;/a&gt;&lt;/span&gt; (This handles both the case where the dividend is &quot;too large&quot; and the divide-by-0 case.)
The number of loops in the division algorithm is controlled by a special-purpose loop counter.
The &lt;code&gt;MAXC&lt;/code&gt; micro-instruction initializes the counter to 7 or 15, for a byte or word divide instruction respectively.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
   move        action
             SUBT tmpA   &lt;span&gt;&lt;b&gt;CORD:&lt;/b&gt; set up compare&lt;/span&gt;
  no dest  MAXC F       &lt;span&gt;compare, set up counter, update flags&lt;/span&gt;
             JMP NCY INT0 &lt;span&gt;generate interrupt if overflow&lt;/span&gt;
             RCL tmpC    &lt;span&gt;&lt;b&gt;3:&lt;/b&gt; main loop: left shift tmpA/tmpC&lt;/span&gt;
  tmpC     RCL tmpA     &lt;span&gt;&lt;/span&gt;
  tmpA     SUBT tmpA    &lt;span&gt;set up compare/subtract&lt;/span&gt;
             JMPS CY 13   &lt;span&gt;jump if top bit of tmpA was set&lt;/span&gt;
  no dest  F            &lt;span&gt;compare, update flags&lt;/span&gt;
             JMPS NCY 14  &lt;span&gt;jump for subtract&lt;/span&gt;
             JMPS NCZ 3   &lt;span&gt;test counter, loop back to 3&lt;/span&gt;
             RCL tmpC    &lt;span&gt;&lt;b&gt;10:&lt;/b&gt; done:&lt;/span&gt;
  tmpC                  &lt;span&gt;shift last bit into tmpC&lt;/span&gt;
  no dest  RTN          &lt;span&gt;done: get top bit, return&lt;/span&gt;

             RCY         &lt;span&gt;&lt;b&gt;13:&lt;/b&gt; reset carry&lt;/span&gt;
  tmpA     JMPS NCZ 3  &lt;span&gt;&lt;b&gt;14:&lt;/b&gt; subtract, loop&lt;/span&gt;
             JMPS 10     &lt;span&gt;done, goto 10&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;The main loop starts at &lt;em&gt;3&lt;/em&gt;.
The tmpC and tmpA registers are shifted left. This has two important side effects. First, the old carry bit (which holds the latest
quotient bit) is shifted into the bottom of tmpC. Second, the top bit of tmpA is shifted into the carry bit;
this provides the necessary &quot;extra&quot; bit for the subtraction below.
Specifically, if the carry (the &quot;extra&quot; tmpA bit) is set, tmpB can be subtracted, which is accomplished by jumping to &lt;em&gt;13&lt;/em&gt;.
Otherwise, the code compares tmpA and tmpB by
subtracting tmpB, discarding the result, and updating the flags (&lt;code&gt;F&lt;/code&gt;).
If there was no borrow/carry (tmpA  tmpB), execution jumps to &lt;em&gt;14&lt;/em&gt; to subtract.
Otherwise, the internal loop counter is decremented and control flow goes back to the top of the loop if not done
(&lt;code&gt;NCZ&lt;/code&gt;, Not Counter Zero).
If the loop is done, tmpC is rotated left to pick up the last quotient bit from the carry flag.
Then a second rotate of tmpC is performed but the result is discarded; this puts the top bit of tmpC into the carry flag for
use later in &lt;code&gt;POSTIDIV&lt;/code&gt;. Finally, the subroutine returns.&lt;/p&gt;
&lt;p&gt;The subtraction path is &lt;em&gt;13&lt;/em&gt; and &lt;em&gt;14&lt;/em&gt;, which subtract tmpB from tmpA by storing the result () in tmpA.
This path resets the carry flag for use as the quotient bit.
As in the other path, the loop counter is decremented and tested (&lt;code&gt;NCZ&lt;/code&gt;) and execution either continues back at &lt;em&gt;3&lt;/em&gt;
or finishes at &lt;em&gt;10&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;One complication is that the carry bit is the opposite of the desired quotient bit. 
Specifically, if tmpA &amp;lt; tmpB, the comparison generates a borrow so the carry flag is set to 1.
In this case, the desired quotient bit is 0 and no subtraction takes place.
But if tmpA  tmpB, the comparison does not generate a borrow (so the carry flag is set to 0), the code subtracts tmpB,
and the desired quotient bit is 1.
Thus, tmpC ends up holding the &lt;em&gt;complement&lt;/em&gt; of the desired result; this is fixed later.&lt;/p&gt;
&lt;p&gt;The microcode is carefully designed to pack the divide loop into a small number of micro-instructions.
It uses the registers and the carry flag in tricky ways, using the carry flag to hold the top bit of tmpA,
the comparison result, and the generated quotient bit.
This makes the code impressively dense but tricky to understand.&lt;/p&gt;
&lt;h3&gt;The top-level division microcode&lt;/h3&gt;
&lt;p&gt;Now I&#39;ll pop up a level and take a look at the top-level microcode (below) that implements the &lt;code&gt;DIV&lt;/code&gt; and &lt;code&gt;IDIV&lt;/code&gt; machine instructions.
The first three instructions load tmpA, tmpC, and tmpB from the specified registers.
(The &lt;code&gt;M&lt;/code&gt; register refers to the source specified in the instruction, either a register or a memory location.)
Next, the &lt;code&gt;X0&lt;/code&gt; condition tests bit 3 of the instruction, which in this case distinguishes &lt;code&gt;DIV&lt;/code&gt; from &lt;code&gt;IDIV&lt;/code&gt;.
For signed division (&lt;code&gt;IDIV&lt;/code&gt;), the microcode calls &lt;code&gt;PREIDIV&lt;/code&gt;, which I&#39;ll discuss below.
Next, the &lt;code&gt;CORD&lt;/code&gt; micro-subroutine discussed above is called to perform the division.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
DX  tmpA                      &lt;span&gt;&lt;b&gt;iDIV rmw:&lt;/b&gt; load tmpA, tmpC, tmpB &lt;/span&gt;
AX  tmpC    RCL tmpA           &lt;span&gt;set up RCL left shift operation&lt;/span&gt;
M  tmpB     CALL X0 PREIDIV    &lt;span&gt;set up integer division if IDIV&lt;/span&gt;
             CALL CORD          &lt;span&gt;call CORD to perform division &lt;/span&gt;
             COM1 tmpC          &lt;span&gt;set up to complement the quotient &lt;/span&gt;
DX  tmpB    CALL X0 POSTIDIV   &lt;span&gt;get original dividend, handle IDIV&lt;/span&gt;
  AX       NXT                &lt;span&gt;store updated quotient&lt;/span&gt;
tmpA  DX    RNI                &lt;span&gt;store remainder, run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;As discussed above, the quotient in tmpC needs to be 1&#39;s-complemented, which is done with &lt;code&gt;COM1&lt;/code&gt;.
For &lt;code&gt;IDIV&lt;/code&gt;, the micro-subroutine &lt;code&gt;POSTIDIV&lt;/code&gt; sets the signs of the results appropriately.
The results are stored in the &lt;code&gt;AX&lt;/code&gt; and &lt;code&gt;DX&lt;/code&gt; registers.
The &lt;code&gt;NXT&lt;/code&gt; micro-operation indicates the next micro-instruction is the last one, directing the microcode engine to
start the next
machine instruction. Finally, &lt;code&gt;RNI&lt;/code&gt; directs the microcode engine to run the next machine instruction.&lt;/p&gt;
&lt;h2&gt;8-bit division&lt;/h2&gt;
&lt;p&gt;The 8086 has separate opcodes for 8-bit division.
The 8086 supports many instructions with byte and word versions, using 8-bit or 16-bit arguments respectively.
In most cases, the byte and word instructions use the same microcode, with the ALU and register hardware using bytes or words based on the instruction.
In the case of division,
the shift micro-operations act on tmpA and tmpC as 8-bit registers rather than 16-bit registers.
Moreover, the &lt;code&gt;MAXC&lt;/code&gt; micro-operation initializes the internal counter to 7 rather than 15.
Thus, the same &lt;code&gt;CORD&lt;/code&gt; microcode is used for word and byte division, but the number of loops and the specific
operations are changed by the hardware.&lt;/p&gt;
&lt;p&gt;The diagram below shows the tmpA and tmpC registers during each step of dividing 0x2345 by 0x34.
Note that the registers are treated as 8-bit registers.
The divisor (blue) steadily shrinks with the quotient (green) taking its place.
At the end, the remainder is 0x41 (blue) and the quotient is 0xad, complement of the green value.&lt;/p&gt;
&lt;table class=&quot;div&quot;&gt;
&lt;tr style=&quot;font-family: sans-serif&quot;&gt;&lt;th colspan=16&gt;tmpA&lt;/th&gt;&lt;th colspan=16 style=&quot;font-family:sans-serif&quot;&gt;tmpC&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Although the &lt;code&gt;CORD&lt;/code&gt; routine is shared for byte and word division, the top-level microcode is different.
In particular, the byte and word division instructions use different registers, requiring microcode changes.
The microcode below is the top-level code for byte division. It is almost the same as the microcode above, except it
uses the top and bottom bytes of the accumulator (&lt;code&gt;AH&lt;/code&gt; and &lt;code&gt;AL&lt;/code&gt;) rather than the &lt;code&gt;AX&lt;/code&gt; and &lt;code&gt;DX&lt;/code&gt; registers.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
AH  tmpA                     &lt;span&gt;&lt;b&gt;iDIV rmb:&lt;/b&gt; get arguments&lt;/span&gt;
AL  tmpC    RCL tmpA          &lt;span&gt;set up RCL left shift operation&lt;/span&gt;
M  tmpB     CALL X0 PREIDIV   &lt;span&gt;handle signed division if IDIV&lt;/span&gt;
             CALL CORD         &lt;span&gt;call CORD to perform division&lt;/span&gt;
             COM1 tmpC         &lt;span&gt;complement the quotient&lt;/span&gt;
AH  tmpB    CALL X0 POSTIDIV  &lt;span&gt;handle signed division if IDIV&lt;/span&gt;
  AL       NXT               &lt;span&gt;store quotient&lt;/span&gt;
tmpA  AH    RNI               &lt;span&gt;store remainder, run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;h2&gt;Signed division&lt;/h2&gt;
&lt;p&gt;The 8086 (like most computers) represents signed numbers using a format called two&#39;s complement.
While a regular byte holds a number from 0 to 255, a signed byte holds a number from -128 to 127.
A negative number is formed by flipping all the bits (known as the one&#39;s complement) and then adding 1, yielding the two&#39;s complement value.
For instance, +5 is &lt;code&gt;0x05&lt;/code&gt; while -5 is &lt;code&gt;0xfb&lt;/code&gt;.
(Note that the top bit of a number is set for a negative number; this is the sign bit.)
The nice thing about two&#39;s complement numbers is that the same addition and subtraction operations work on both signed and unsigned values.
Unfortunately, this is not the case for signed multiplication and division.&lt;/p&gt;
&lt;p&gt;The 8086 has separate &lt;code&gt;IDIV&lt;/code&gt; (Integer Divide) instructions to perform signed division.
The 8086 performs signed division by converting the arguments to positive values, performing unsigned division, and then
negating the results if necessary.
As shown earlier, signed and unsigned division both use the same top-level microcode and the microcode conditionally calls some subroutines for
signed division.
These additional subroutines cause a significant performance penalty, making signed division over 20 cycles slower than unsigned division.
I will discuss those micro-subroutines below.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;PREIDIV&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The first subroutine for signed division is &lt;code&gt;PREIDIV&lt;/code&gt;, performing preliminary operations for integer division.
It converts the two arguments, stored in tmpA/tmpC and tmpB, to positive values.
It keeps track of the signs using an internal flag called &lt;code&gt;F1&lt;/code&gt;, toggling this flag for each negative argument.
This conveniently handles the rule that two negatives make a positive since complementing the &lt;code&gt;F1&lt;/code&gt; flag twice will clear it.
The point of this is that the main division code (&lt;code&gt;CORD&lt;/code&gt;) only needs to handle unsigned division.&lt;/p&gt;
&lt;p&gt;The microcode below implements &lt;code&gt;PREIDIV&lt;/code&gt;.
First it tests if tmpA is negative, but
the 8086 does not have a microcode condition to directly test the sign of a value.
Instead, the microcode determines if a value is negative by shifting the value left, which moves the top (sign) bit into the carry flag.
The conditional jump (&lt;code&gt;NCY&lt;/code&gt;) then tests if the carry is clear, jumping if the value is non-negative.
If tmpA is negative, execution falls through to negate the first argument.
This is tricky because the argument is split between the tmpA and tmpC registers.
The two&#39;s complement operation (&lt;code&gt;NEG&lt;/code&gt;) is applied to the low word, while either 2&#39;s complement or one&#39;s complement (&lt;code&gt;COM1&lt;/code&gt;) is applied to
the upper word, depending on the carry for mathematical reasons.&lt;span id=&quot;fnref:neg&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:neg&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
The &lt;code&gt;F1&lt;/code&gt; flag is complemented to keep track of the sign.
(The multiplication process reuses most of this code, starting at the &lt;code&gt;NEGATE&lt;/code&gt; entry point.)&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
  no dest             &lt;span&gt;&lt;b&gt;PREIDIV:&lt;/b&gt; shift tmpA left&lt;/span&gt;
             JMPS NCY 7  &lt;span&gt;jump if non-negative&lt;/span&gt;
             NEG tmpC   &lt;span&gt;&lt;b&gt;NEGATE:&lt;/b&gt; negate tmpC&lt;/span&gt;
  tmpC     COM1 tmpA F &lt;span&gt;maybe complement tmpA&lt;/span&gt;
             JMPS CY 6  
             NEG tmpA    &lt;span&gt;negate tmpA if there&#39;s no carry&lt;/span&gt;
  tmpA     CF1        &lt;span&gt;&lt;b&gt;6:&lt;/b&gt; toggle F1 (sign)&lt;/span&gt;

             RCL tmpB  &lt;span&gt;&lt;b&gt;7:&lt;/b&gt; test sign of tmpB&lt;/span&gt;
  no dest  NEG tmpB    &lt;span&gt;maybe negate tmpB&lt;/span&gt;
             JMPS NCY 11 &lt;span&gt;skip if tmpB positive&lt;/span&gt;
  tmpB     CF1 RTN     &lt;span&gt;else negate tmpB, toggle F1 (sign)&lt;/span&gt;
             RTN        &lt;span&gt;&lt;b&gt;11:&lt;/b&gt; return&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;The next part of the code, starting at &lt;em&gt;7&lt;/em&gt;, negates tmpB (the divisor) if it is negative. Since the divisor is a single
word, this code is simpler.
As before, the &lt;code&gt;F1&lt;/code&gt; flag is toggled if tmpB is negative.
At the end, both arguments (tmpA/tmpC and tmpB) are positive, and &lt;code&gt;F1&lt;/code&gt; indicates the sign of the result.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;POSTIDIV&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;After computing the result, the &lt;code&gt;POSTIDIV&lt;/code&gt; routine is called for signed division.
The routine first checks for a signed overflow and raises a divide-by-zero interrupt if so.
Next, the routine negates the quotient and remainder if necessary.&lt;span id=&quot;fnref:signs&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:signs&quot;&gt;6&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In more detail, the &lt;code&gt;CORD&lt;/code&gt; routine left the top bit of tmpC (the complemented quotient) in the carry flag.
Now, that bit is tested. If the carry bit is 0 (&lt;code&gt;NCY&lt;/code&gt;), then the top bit of the quotient is 1 so the quotient is too big to fit in a signed value.&lt;span id=&quot;fnref:overflow&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:overflow&quot;&gt;7&lt;/a&gt;&lt;/span&gt;
In this case, the &lt;code&gt;INT0&lt;/code&gt; routine is executed to trigger a type 0 interrupt, indicating a divide overflow.
(This is a rather roundabout way of testing the quotient, relying on a carry bit that was set in a previous subroutine.)&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
             JMP NCY INT0 &lt;span&gt;&lt;b&gt;POSTIDIV:&lt;/b&gt; if overflow, trigger interrupt&lt;/span&gt;
             RCL tmpB      &lt;span&gt;set up rotate of tmpB&lt;/span&gt;
  no dest  NEG tmpA      &lt;span&gt;get sign of tmpB, set up negate of tmpA&lt;/span&gt;
             JMPS NCY 5    &lt;span&gt;skip if tmpB non-negative&lt;/span&gt;
  tmpA                   &lt;span&gt;otherwise negate tmpA (remainder)&lt;/span&gt;
             INC tmpC     &lt;span&gt;&lt;b&gt;5:&lt;/b&gt; set up increment&lt;/span&gt;
             JMPS F1 8     &lt;span&gt;test sign flag, skip if set&lt;/span&gt;
             COM1 tmpC     &lt;span&gt;otherwise set up complement&lt;/span&gt;
             CCOF RTN     &lt;span&gt;&lt;b&gt;8:&lt;/b&gt; clear carry and overflow flags, return&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;Next, tmpB (the divisor) is rotated to see if it is negative.
(The caller loaded tmpB with the original divisor, replacing the dividend that was in tmpB previously.)
If the divisor is negative, tmpA (the remainder) is negated.
This implements the 8086 rule that the sign of the remainder matches the sign of the divisor.&lt;/p&gt;
&lt;p&gt;The quotient handling is a bit tricky. Recall that tmpC holds the complemented quotient.
the &lt;code&gt;F1&lt;/code&gt; flag is set if the result should be negative. In that case, the complemented quotient needs to be incremented
by 1 (&lt;code&gt;INC&lt;/code&gt;) to convert from 1&#39;s complement to 2&#39;s complement.
On the other hand, if the quotient should be positive, 1&#39;s-complementing tmpC (&lt;code&gt;COM1&lt;/code&gt;) will yield the desired positive
quotient.
In either case, the ALU is configured in &lt;code&gt;POSTIDIV&lt;/code&gt;, but the result will be stored back in the main routine.&lt;/p&gt;
&lt;p&gt;Finally, the &lt;code&gt;CCOF&lt;/code&gt; micro-operation clears the carry and overflow flags.
Curiously, the 8086 documentation declares that the status flags are undefined following &lt;code&gt;IDIV&lt;/code&gt;, but the microcode
explicitly clears the carry and overflow flags.
I assume that the flags were cleared in analogy with &lt;code&gt;MUL&lt;/code&gt;, but then Intel decided that this wasn&#39;t useful so they
didn&#39;t document it. (Documenting this feature would obligate them to provide the same functionality in later x86 chips.)&lt;/p&gt;
&lt;h2&gt;The hardware for division&lt;/h2&gt;
&lt;p&gt;For the most part, the 8086 uses the regular ALU addition and shifts for the division algorithm. Some special hardware
features provide assistance.
In this section, I&#39;ll look at this hardware.&lt;/p&gt;
&lt;h3&gt;Loop counter&lt;/h3&gt;
&lt;p&gt;The 8086 has a 4-bit loop counter for multiplication and division. This counter starts at 7 for byte division and 15 for word division,
based on the low bit of the opcode.
This loop counter allows the microcode to decrement the counter, test for the end, and perform a conditional branch in one micro-operation.
The counter is implemented with four flip-flops, along with logic to compute the value after decrementing by one.
The &lt;code&gt;MAXC&lt;/code&gt; (Maximum Count) micro-instruction sets the counter to 7 or 15 for byte or word operations respectively.
The &lt;code&gt;NCZ&lt;/code&gt; (Not Counter Zero) micro-instruction has two actions. First, it performs a conditional jump if the counter is nonzero.
Second, it decrements the counter.&lt;/p&gt;
&lt;h3&gt;The F1 flag&lt;/h3&gt;
&lt;p&gt;Signed multiplication and division use an internal flag called &lt;code&gt;F1&lt;/code&gt;&lt;span id=&quot;fnref:f1&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:f1&quot;&gt;8&lt;/a&gt;&lt;/span&gt; to keep track of the sign.
The &lt;code&gt;F1&lt;/code&gt; flag is toggled by microcode through the &lt;code&gt;CF1&lt;/code&gt; (Complement F1) micro-instruction.
The &lt;code&gt;F1&lt;/code&gt; flag is implemented with a flip-flop, along with a multiplexer to select the value. It is cleared when a new instruction starts,
set by a &lt;code&gt;REP&lt;/code&gt; prefix, and toggled by the &lt;code&gt;CF1&lt;/code&gt; micro-instruction.
The diagram below shows how the F1 latch and the loop counter appear on the die. In this image, the metal layer has been removed, showing the
silicon and the polysilicon wiring underneath.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-div/counter.jpg&quot;&gt;&lt;img alt=&quot;The counter and F1 latch as they appear on the die. The latch for the REP state is also here.&quot; class=&quot;hilite&quot; height=&quot;308&quot; src=&quot;https://static.righto.com/images/8086-div/counter-w600.jpg&quot; title=&quot;The counter and F1 latch as they appear on the die. The latch for the REP state is also here.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The counter and F1 latch as they appear on the die. The latch for the REP state is also here.&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;X register&lt;/h3&gt;
&lt;p&gt;The division microcode uses an internal register called the &lt;code&gt;X&lt;/code&gt; register to distinguish between the &lt;code&gt;DIV&lt;/code&gt; and &lt;code&gt;IDIV&lt;/code&gt; instructions.
The &lt;code&gt;X&lt;/code&gt; register is a 3-bit register that holds the ALU opcode, indicated by bits 5&amp;ndash;3 of the instruction.&lt;span id=&quot;fnref:x-reg&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:x-reg&quot;&gt;9&lt;/a&gt;&lt;/span&gt;
Since the instruction is held in the Instruction Register, you might wonder why a separate register is required.
The motivation is that some opcodes specify the type of ALU operation in the second byte of the instruction, the ModR/M byte, bits 5&amp;ndash;3.&lt;span id=&quot;fnref:opcode&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:opcode&quot;&gt;10&lt;/a&gt;&lt;/span&gt;
Since the ALU operation is sometimes specified in the first byte and sometimes in the second byte, the &lt;code&gt;X&lt;/code&gt; register was added to handle
both these cases.&lt;/p&gt;
&lt;p&gt;For the most part, the &lt;code&gt;X&lt;/code&gt; register indicates which of the eight standard ALU operations is selected (&lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, &lt;code&gt;ADC&lt;/code&gt;, &lt;code&gt;SBB&lt;/code&gt;, &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;SUB&lt;/code&gt;, &lt;code&gt;XOR&lt;/code&gt;, &lt;code&gt;CMP&lt;/code&gt;). 
However, a few instructions use bit 0 of the &lt;code&gt;X&lt;/code&gt; register to distinguish between other pairs of instructions.
For instance, it distinguishes between &lt;code&gt;MUL&lt;/code&gt; and &lt;code&gt;IMUL&lt;/code&gt;, &lt;code&gt;DIV&lt;/code&gt; and &lt;code&gt;IDIV&lt;/code&gt;, &lt;code&gt;CMPS&lt;/code&gt; and &lt;code&gt;SCAS&lt;/code&gt;, &lt;code&gt;MOVS&lt;/code&gt; and &lt;code&gt;LODS&lt;/code&gt;, or &lt;code&gt;AAA&lt;/code&gt; and &lt;code&gt;AAS&lt;/code&gt;.
While these instruction pairs may appear to have arbitrary opcodes, they have been carefully assigned
so the microcode can distinguish them.&lt;/p&gt;
&lt;p&gt;The implementation of the &lt;code&gt;X&lt;/code&gt; register is straightforward, consisting of three flip-flops to hold the three bits of the instruction.
The flip-flops are loaded from the prefetch queue bus during First Clock and during Second Clock for appropriate instructions, as the
instruction bytes travel over the bus.
Testing bit 0 of the &lt;code&gt;X&lt;/code&gt; register with the &lt;code&gt;X0&lt;/code&gt; condition is supported by the microcode condition evaluation circuitry, so it can be used for conditional jumps in the microcode.&lt;/p&gt;
&lt;h2&gt;Algorithmic and historical context&lt;/h2&gt;
&lt;p&gt;As you can see from the microcode, division is a complicated and relatively slow process.
On the 8086, division takes up to 184 clock cycles to perform all the microcode steps.
(In comparison, two registers can be added in 3 clock cycles.)
Multiplication and division both loop over the bits, performing repeated addition or subtraction respectively.
But division requires a decision (subtract or not?) at each step, making it even slower, about half the speed of multiplication.&lt;span id=&quot;fnref:history&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:history&quot;&gt;11&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Various algorithms have been developed to speed up division.
Rather than performing long division one bit at a time, you can do long division in, say, base 4, producing two quotient
bits in each step.
As with decimal long division, the tricky part is figuring out what digit to select. The &lt;a href=&quot;https://en.wikipedia.org/wiki/Division_algorithm#SRT_division&quot;&gt;SRT algorithm&lt;/a&gt; (1957) uses a small
lookup table to estimate the quotient digit from a few bits of the divisor and dividend.
The clever part is that the selected digit doesn&#39;t need to be exactly right at each step; the algorithm will self-correct
after a wrong &quot;guess&quot;.
The Pentium processor (1993) famously had a &lt;a href=&quot;https://math.mit.edu/~edelman/homepage/papers/pentiumbug.pdf&quot;&gt;floating point division bug&lt;/a&gt;
due to a few missing values in the SRT table. This bug cost Intel $475 million to replace the faulty processors.&lt;/p&gt;
&lt;p&gt;Intel&#39;s x86 processors steadily improved divide performance. The 80286 (1982) performed a word divide in 22 clocks, about
6 times as fast as the 8086.
In the &lt;a href=&quot;https://www.cubawiki.com.ar/images/b/b3/Orga2_paper_penyn.pdf&quot;&gt;Penryn&lt;/a&gt; architecture (2007), Intel upgraded from
Radix-4 to Radix-16 division.
Rather than having separate integer and floating-point hardware, integer divides were handled through the floating point divider.
Although modern Intel processors have greatly improved multiplication and division compared to the 8086, division is still a relatively slow operation.
While a Tiger Lake (2020) processor can perform an integer multiplication every clock cycle (with a latency of 3 cycles),
division is much slower and can only be done once every 6-10 clock cycles (&lt;a href=&quot;https://agner.org/optimize/&quot;&gt;details&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;I&#39;ve written numerous &lt;a href=&quot;https://www.righto.com/search/label/8086&quot;&gt;posts on the 8086&lt;/a&gt; so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@kenshirriff@oldbytes.space&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:microcode&quot;&gt;
&lt;p&gt;My microcode analysis is based on Andrew Jenner&#39;s &lt;a href=&quot;https://www.reenigne.org/blog/8086-microcode-disassembled/&quot;&gt;8086 microcode disassembly&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:microcode&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:rcl&quot;&gt;
&lt;p&gt;The 8086 patent and Andrew Jenner&#39;s microcode use the name &lt;code&gt;LRCY&lt;/code&gt; (Left Rotate through Carry) instead of &lt;code&gt;RCL&lt;/code&gt;.
I figure that &lt;code&gt;RCL&lt;/code&gt; will be more familiar to people because of the corresponding machine instruction.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:rcl&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:table&quot;&gt;
&lt;p&gt;In the dividend/quotient table, the tmpA register is on the left and the tmpC register is on the right.
0x0f00ff00 divided by 0x0ffc yielding the remainder 0x0030 (blue) and quotient 0xf04c (green).
(The green bits are the complement of the quotient due to implementation in the 8086.)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:table&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:interrupts&quot;&gt;
&lt;p&gt;I described the 8086&#39;s interrupt circuitry in detail in &lt;a href=&quot;https://www.righto.com/2023/02/8086-interrupt.html&quot;&gt;this post&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:interrupts&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:neg&quot;&gt;
&lt;p&gt;The negation code is a bit tricky because the result is split across two words.
In most cases, the upper word is bitwise complemented. However, if the lower word is zero, then the upper word is negated (two&#39;s complement).
I&#39;ll demonstrate with 16-bit values to keep the examples small.
The number 257 (0x0101) is negated to form -257 (0xfeff). Note that the upper byte is the one&#39;s complement (0x01 vs 0xfe) while the lower
byte is two&#39;s complement (0x01 vs 0xff).
On the other hand, the number 256 (0x0100) is negated to form -256 (0xff00). In this case, the upper byte is the two&#39;s complement (0x01 vs 0xff)
and the lower byte is also the two&#39;s complement (0x00 vs 0x00).&lt;/p&gt;
&lt;p&gt;(Mathematical explanation: the two&#39;s complement is formed by taking the one&#39;s complement and adding 1. In most cases, there won&#39;t be a carry from
the low byte to the upper byte, so the upper byte will remain the one&#39;s complement. However, if the low byte is 0, the complement is 0xff and
adding 1 will form a carry. Adding this carry to the upper byte yields the two&#39;s complement of that byte.)&lt;/p&gt;
&lt;p&gt;To support multi-word negation, the 8086&#39;s &lt;code&gt;NEG&lt;/code&gt; instruction clears the carry flag if the operand is 0, and otherwise sets the carry flag.
(This is the opposite of the above because subtractions (including &lt;code&gt;NEG&lt;/code&gt;) treat the carry flag as a borrow flag, with the opposite meaning.)
The microcode &lt;code&gt;NEG&lt;/code&gt; operation has identical behavior to the machine instruction, since it is used to implement the machine instruction.&lt;/p&gt;
&lt;p&gt;Thus to perform a two-word negation, the microcode negates the low word (tmpC) and updates the flags (&lt;code&gt;F&lt;/code&gt;).
If the carry is set, the one&#39;s complement is applied to the upper word (tmpA). But if the carry is cleared, the two&#39;s complement is applied to tmpA.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:neg&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:signs&quot;&gt;
&lt;p&gt;There is a bit of ambiguity with the quotient and remainder of negative numbers.
For instance, consider -27  7. -27 = 7 &amp;times; -3 - 6 = 7 * -4 + 1. So you could consider the
result to be a quotient of -3 and remainder of -6, or a quotient of -4 and a remainder of 1.
The 8086 uses the rule that the remainder will have the same sign as the dividend, so the first result would be used.
The advantage of this rule is that you can perform unsigned division and adjust the signs afterward:
&lt;br/&gt;27  7 = quotient 3, remainder 6.
&lt;br/&gt;-27  7 = quotient -3, remainder -6.
&lt;br/&gt;27  -7 = quotient -3, remainder 6.
&lt;br/&gt;-27  -7 = quotient 3, remainder -6.&lt;/p&gt;
&lt;p&gt;This rule is known as truncating division, but some languages use different approaches such as 
floored division, rounded division, or Euclidean division.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Modulo#Variants_of_the_definition&quot;&gt;Wikipedia&lt;/a&gt; has details.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:signs&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:overflow&quot;&gt;
&lt;p&gt;The signed overflow condition is slightly stricter than necessary.
For a word division, the 16-bit quotient is restricted to the range -32767 to 32767.
However, a 16-bit signed value can take on the values -32768 to 32767.
Thus, a quotient of -32768 fits in a 16-bit signed value even though the 8086 considers it an error.
This is a consequence of the 8086 performing unsigned division and then updating the sign if necessary.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:overflow&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:f1&quot;&gt;
&lt;p&gt;The internal &lt;code&gt;F1&lt;/code&gt; flag is also used to keep track of a &lt;code&gt;REP&lt;/code&gt; prefix for use with a string operation.
I discussed string operations and the &lt;code&gt;F1&lt;/code&gt; flag in &lt;a href=&quot;https://www.righto.com/2023/04/8086-microcode-string-operations.html&quot;&gt;this post&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:f1&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:x-reg&quot;&gt;
&lt;p&gt;Curiously, the &lt;a href=&quot;https://patents.google.com/patent/US4449184A/&quot;&gt;8086 patent&lt;/a&gt; states that the &lt;code&gt;X&lt;/code&gt; register is a 4-bit register holding bits 3&amp;ndash;6 of
the byte (col. 9, line 20). But looking at the die, it is a 3-bit register holding bits 3&amp;ndash;5 of the byte.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:x-reg&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:opcode&quot;&gt;
&lt;p&gt;Some instructions are specified by bits 5&amp;ndash;3 in the ModR/M byte rather than in the first opcode byte.
The motivation is to avoid wasting bits for instructions that use a ModR/M byte but don&#39;t need a register specification.
For instance, consider the instruction &lt;code&gt;ADD [BX],0x1234&lt;/code&gt;. This instruction uses a ModR/M byte to specify the memory address.
However, because it uses an immediate operand, it does not need the register specification normally provided by bits 5&amp;ndash;3 of the ModR/M byte.
This frees up the bits to specify the instruction.
From one perspective, this is an ugly hack, while from another perspective it is a clever optimization.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:opcode&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:history&quot;&gt;
&lt;p&gt;Even the earliest computers such as ENIAC (1945) usually supported multiplication and division.
However, early microprocessors did not provide multiplication and division instructions due to the
complexity of these instructions.
Instead, the programmer would need to write an assembly code loop, which was very slow.
Early microprocessors often had binary-coded decimal instructions that could perform additions and subtractions in decimal.
One motivation for these instructions was that converting between binary and decimal was extremely slow due to the
need for multiplication and division. Instead, it was easier and faster to keep the values as decimal if that was how
they were displayed.&lt;/p&gt;
&lt;p&gt;The Texas Instruments TMS9900 (1976) was one of the first microprocessors with multiplication and division instructions.
Multiply and divide instructions remained somewhat controversial on RISC (Reduced Instruction-Set Computer) processors due
to the complexity of these instructions.
The early ARM processors, for instance, did not support multiplication and division.
Multiplication was added to ARMv2 (1986) but most ARM processors still don&#39;t have integer division.
The popular open-source RISC-V architecture (2015) doesn&#39;t include integer multiply and divide by default, but
provides them as an optional &quot;M&quot; extension.&lt;/p&gt;
&lt;p&gt;The 8086&#39;s algorithm is designed for simplicity rather than speed.
It is a &quot;restoring&quot; algorithm that checks before subtracting to ensure that the current term is always positive.
This can require two ALU operations (comparison and subtraction) per cycle.
A slightly more complex approach is a &quot;nonrestoring&quot; algorithm that subtracts even if it yields a negative term, and then
adds during a later loop iteration.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:history&quot; title=&quot;Jump back to footnote 11 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/5693917346966509204/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=5693917346966509204' title='3 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/5693917346966509204'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/5693917346966509204'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/04/reverse-engineering-8086-divide-microcode.html' title='Reverse-engineering the division microcode in the Intel 8086 processor'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-6370120370244800510</id><published>2023-04-04T09:57:00.010-07:00</published><updated>2023-04-04T18:01:19.381-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="chips"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>The microcode and hardware in the 8086 processor that perform string operations</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;
&lt;style&gt;
  pre.microcode {font-family: courier, fixed; padding: 10px; background-color: #f5f5f5; display:inline-block;border:none;}
  pre.microcode span {color: green; font-style:italic; font-family: sans-serif; font-size: 90%;}
&lt;/style&gt;

&lt;p&gt;Intel introduced the 8086 microprocessor in 1978. This processor ended up being hugely influential, setting the path
for the x86 architecture that is extensively used today.
One interesting feature of the 8086 was instructions that can efficiently
operate on blocks of memory up to 64K bytes long.&lt;span id=&quot;fnref:history&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:history&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
These instructions rapidly copy, compare, or scan data and are known as &quot;string&quot; instructions.&lt;span id=&quot;fnref:string&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:string&quot;&gt;2&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In this blog post, I explain string operations in the 8086, analyze the microcode that it used, and discuss the hardware
circuitry that helped it out.
My analysis is based on reverse-engineering the 8086 from die photos. The photo below shows the chip under a microscope.
I&#39;ve labeled the key functional blocks; the ones that are important to this post are darker.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top
and an Execution Unit (EU) below.
The BIU handles memory accesses, while the Execution Unit (EU) executes instructions.
The microcode ROM at the lower right controls the process.&lt;/p&gt;
&lt;!--
This post is part of my [series](https://www.righto.com/search/label/8086) on the internals of the 8086.
--&gt;

&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-str/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;624&quot; src=&quot;https://static.righto.com/images/8086-str/die-labeled-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Segments and addressing&lt;/h2&gt;
&lt;p&gt;Before I get into the details of the string instructions, I need to give a bit of background on how the 8086 accesses
memory through segments.
Earlier microprocessors such as the Intel 8080 (1974) used 16 bits to specify a memory address, allowing a maximum of 64K of memory.
This memory capacity is absurdly small by modern standards, but at the time when a 4K memory board cost hundreds of dollars, this limit
was not a problem.
However, due to Moore&#39;s Law and the exponential growth in memory capacity, the follow-on 8086 processor needed to support more memory.
At the same time, the 8086 needed to use 16-bit registers for backward compatibility with the 8080.&lt;/p&gt;
&lt;p&gt;The much-reviled solution was to create a 1-megabyte (20-bit) address space consisting of 64K segments, with a 16-bit address
specifying a position within the segment.
In more detail, the memory address was specified by a 16-bit offset address along with a particular 16-bit segment register selecting a segment.
The segment register&#39;s value was shifted by 4 bits to give the segment&#39;s 20-bit base address. The 16-bit offset address was added,
yielding a 20-bit memory address.
This gave the processor a 1-megabyte address space, although only 64K could be accessed without changing a segment register.
The 8086 had four segment registers so it could use multiple segments at the same time: the Code Segment, Data Segment, Stack Segment, and Extra Segment.&lt;/p&gt;
&lt;p&gt;The 8086 chip is split into
two processing units: the Bus Interface Unit (BIU) that handles segments and memory accesses, and the Execution Unit (EU) that executes instructions.
The Execution Unit is what comes to mind when you think of a processor: it has most of the registers, the arithmetic/logic unit (ALU), and the microcode that implements instructions.
The Bus Interface Unit interacts with memory and other external systems, performing the steps necessary to read and write memory.&lt;/p&gt;
&lt;p&gt;Among other things, the Bus Interface Unit has a separate adder for address calculation; this adds the segment register to the base address to
determine the final memory address.
Every memory access uses the address adder at least once to add the segment base and offset.
The address adder is also used to increment the program counter.
Finally, the address adder increments and decrements the index registers used for block operations.
This will be discussed in more detail below.&lt;/p&gt;
&lt;h2&gt;Microcode in the 8086&lt;/h2&gt;
&lt;p&gt;Most people think of machine instructions as the basic steps that a computer performs.
However, many processors (including the 8086) have another layer of software underneath: microcode.
With microcode, instead of building the control circuitry from complex logic gates, the control logic is largely replaced with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.
This provides a considerable performance improvement for the block operations, which requires many steps in a loop.
Performing this loop in microcode is considerably faster than writing the loop in assembly code.&lt;/p&gt;
&lt;!--
The 8086 uses a hybrid approach: although it uses microcode, much of the instruction functionality is implemented with gate logic.
This approach removed duplication from the microcode and kept the microcode small enough for 1978 technology.
In a sense, the microcode is parameterized.
For instance, the microcode can specify a generic Arithmetic/Logic Unit (ALU) operation and a generic register.
The gate logic examines the instruction to determine which specific operation to perform and the appropriate register.
--&gt;

&lt;p&gt;A micro-instruction in the 8086 is encoded into 21 bits as shown below.
Every micro-instruction specifies a move operation from a source register to a destination register, each specified with 5 bits.
The meaning of the remaining bits depends on the type field and can be anything from an ALU operation to a memory read or write to
a change of microcode control flow.
Thus, an 8086 micro-instruction typically does two things in parallel: the move and the action.
For more about 8086 microcode, see my &lt;a href=&quot;https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html&quot;&gt;microcode blog post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-str/microcode-format.jpg&quot;&gt;&lt;img alt=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; class=&quot;hilite&quot; height=&quot;203&quot; src=&quot;https://static.righto.com/images/8086-str/microcode-format-w700.jpg&quot; title=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The encoding of a micro-instruction into 21 bits. Based on &lt;a href=&quot;https://digitalcommons.law.scu.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=1031&amp;context=chtlj&quot;&gt;NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;I&#39;ll explain the behavior of an ALU micro-operation since it is important for string operations.
The Arithmetic/Logic Unit (ALU) is the heart of the processor, performing addition, subtraction, and logical operations.
The ALU has three temporary input registers that are invisible to the programmer: tmpA, tmpB, and tmpC.
An ALU operation takes its first argument from any temporary register, while the second argument always comes from tmpB.
Performing an ALU operation requires two micro-instructions.
The first micro-instruction specifies the ALU operation and source register, configuring the ALU. For instance, &lt;code&gt;ADD tmpA&lt;/code&gt; configures the ALU to add the tmpA register to the default tmpB register.
In the next micro-instruction (or a later one), the ALU result can be accessed through a special register called &lt;code&gt;&lt;/code&gt; (SIGMA) and moved to another register.&lt;/p&gt;
&lt;p&gt;I&#39;ll also explain the memory read and write micro-operations.
A memory operation uses two internal registers: &lt;code&gt;IND&lt;/code&gt; (Indirect) holds the memory address, while &lt;code&gt;OPR&lt;/code&gt; (Operand) holds the word that is read or written.
A typical memory micro-instruction for a read is &lt;code&gt;R DS,BL&lt;/code&gt;.
This causes the Bus Interface Unit to compute the memory address by adding the Data Segment (&lt;code&gt;DS&lt;/code&gt;) to the &lt;code&gt;IND&lt;/code&gt; register
and then perform the read.
The Bus Interface Unit determines if the instruction is performing a byte operation or a word operation and reads a byte or
word as appropriate, going through the necessary bus cycles.
The &lt;code&gt;BL&lt;/code&gt; option&lt;span id=&quot;fnref:bl&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:bl&quot;&gt;3&lt;/a&gt;&lt;/span&gt; causes the Bus Interface Unit to update the &lt;code&gt;IND&lt;/code&gt; register as appropriate,&lt;span id=&quot;fnref2:bl&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:bl&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
incrementing or decrementing it by 1 or 2 depending on the Direction Flag and the
size of the access (byte or word).
All of this complexity happens in the hardware of the Bus Interface Unit and is invisible to the microcode.
The tradeoff is that this simplifies the microcode but makes the chip&#39;s hardware considerably more complicated.&lt;/p&gt;
&lt;h2&gt;The string move instruction&lt;/h2&gt;
&lt;p&gt;The 8086 has five types of string instructions, operating on blocks of memory:
&lt;code&gt;MOVS&lt;/code&gt; (Move String), &lt;code&gt;CMPS&lt;/code&gt; (Compare Strings), &lt;code&gt;SCAS&lt;/code&gt; (Scan String), &lt;code&gt;LODS&lt;/code&gt; (Load String), and &lt;code&gt;STOS&lt;/code&gt; (Store String).
Each instruction operates on a byte or word, but by using a &lt;code&gt;REP&lt;/code&gt; prefix, the operation can be repeated for up to 64k bytes,
controlled by a counter.
Conditional repetitions can terminate the loop on various conditions.
The string instructions provide a flexible way to operate on blocks of memory, much faster than a loop written in assembly code.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;MOVS&lt;/code&gt; (Move String) operation copies one memory region to another.
The &lt;code&gt;CMPS&lt;/code&gt; (Compare Strings) operation compares two memory blocks and sets the status flags. In particular, this indicates if
one string is greater, less, or equal to the other.
The &lt;code&gt;SCAS&lt;/code&gt; (Scan String) operation scans memory, looking for a particular value.
The &lt;code&gt;LODS&lt;/code&gt; (Load String) operation moves an element into the accumulator, generally as part of a more complex loop.
Finally, &lt;code&gt;STOS&lt;/code&gt; (Store String) stores the accumulator value, either to initialize a block of memory or as part of a more complex loop.&lt;span id=&quot;fnref:morse&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:morse&quot;&gt;4&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Like many 8086 instructions, each string instruction has two opcodes: one that operates on bytes and one that operates on words.
One of the interesting features of the 8086 is that the same microcode implements the byte and word instructions, while the
hardware takes care of the byte- or word-sized operations as needed.
Another interesting feature of the string operations is that they can go forward through memory, incrementing the pointers,
or they can go backward, decrementing the points. A special processor flag, the Direction Flag, indicates the direction: 0 for incrementing
and 1 for decrementing.
Thus, there are four possibilities for stepping through memory, part of the flexibility of the string operations.&lt;/p&gt;
&lt;p&gt;The flowchart below shows the complexity of these instructions. I&#39;m not going to explain the flowchart at this point, but
the point is that there is a lot going on. This functionality is implemented by the microcode.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-str/flowchart.png&quot;&gt;&lt;img alt=&quot;This flowchart shows the operation of a string instruction. From The 8086 Family Users Manual, fig 2-33.&quot; class=&quot;hilite&quot; height=&quot;803&quot; src=&quot;https://static.righto.com/images/8086-str/flowchart-w400.png&quot; title=&quot;This flowchart shows the operation of a string instruction. From The 8086 Family Users Manual, fig 2-33.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This flowchart shows the operation of a string instruction. From &lt;a href=&quot;http://bitsavers.org/components/intel/8086/9800722-03_The_8086_Family_Users_Manual_Oct79.pdf&quot;&gt;The 8086 Family Users Manual&lt;/a&gt;, fig 2-33.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;I&#39;ll start by explaining the &lt;code&gt;MOVS&lt;/code&gt; (Move String) instruction, which moves (copies) a block of memory.
Before executing this instruction, the registers should be configured so
the &lt;code&gt;SI&lt;/code&gt; Source Index register points to the first block, the &lt;code&gt;DI&lt;/code&gt; Destination Index register points to the second block,
and the &lt;code&gt;CX&lt;/code&gt; Count register holds the number of bytes or words to move.
The basic action of the &lt;code&gt;MOVS&lt;/code&gt; instruction reads a byte (or word) from the &lt;code&gt;SI&lt;/code&gt; address and updates &lt;code&gt;SI&lt;/code&gt;, writes the value
to the &lt;code&gt;DI&lt;/code&gt; address and updates &lt;code&gt;DI&lt;/code&gt;, and decrements the &lt;code&gt;CX&lt;/code&gt; counter.&lt;/p&gt;
&lt;p&gt;The microcode block below is executed for the &lt;code&gt;MOVS&lt;/code&gt; (and &lt;code&gt;LODS&lt;/code&gt;) instructions.
There&#39;s a lot happening in this microcode with a variety of control paths, so it&#39;s a bit tricky to
understand, but let&#39;s see how it goes.
Each micro-instruction has a register-to-register move on the left and an action on the right, happening in parallel.
The first micro-instruction handles the &lt;code&gt;REP&lt;/code&gt; prefix, if any; let&#39;s assume for now that there&#39;s no prefix so it is skipped.
Next is the read from memory, which requires the memory address to be in the &lt;code&gt;IND&lt;/code&gt; register.
Thus, the micro-instruction moves &lt;code&gt;SI&lt;/code&gt; to &lt;code&gt;IND&lt;/code&gt; and starts the read cycle (&lt;code&gt;R DS,BL&lt;/code&gt;).
When the read completes, the updated &lt;code&gt;IND&lt;/code&gt; register is moved back to &lt;code&gt;SI&lt;/code&gt;, updating that register.
Meanwhile, &lt;code&gt;X0&lt;/code&gt; tests the opcode and jumps to &quot;8&quot; for &lt;code&gt;LODS&lt;/code&gt;.
The &lt;code&gt;MOVS&lt;/code&gt; path falls through, getting the address from the &lt;code&gt;DI&lt;/code&gt; register and writing to memory the value that we just read.
The updated &lt;code&gt;IND&lt;/code&gt; register is moved to &lt;code&gt;DI&lt;/code&gt; while another conditional jump goes to &quot;7&quot; if there&#39;s no &lt;code&gt;REP&lt;/code&gt; prefix.
Micro-instruction 7 performs an &lt;code&gt;RNI&lt;/code&gt; (Run Next Instruction), which ends the microcode and causes the next
machine instruction to be decoded.
As you can see, microcode is very low-level.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
 move       action           
           CALL F1 RPTS &lt;span&gt;&lt;b&gt;MOVS/LODS:&lt;/b&gt; handle REP if active&lt;/span&gt;
SI  IND   R DS,BL      &lt;span&gt;&lt;b&gt;1:&lt;/b&gt; Read byte/word from SI&lt;/span&gt;
IND  SI   JMPS X0 8     &lt;span&gt;test instruction bit 3: jump if LODS&lt;/span&gt;
DI  IND   W DA,BL       &lt;span&gt;MOVS path: write to DI&lt;/span&gt;
IND  DI   JMPS NF1 7   &lt;span&gt;&lt;b&gt;4:&lt;/b&gt; run next instruction if not REP&lt;/span&gt;
  tmpC   JMP INT RPTI &lt;span&gt;&lt;b&gt;5:&lt;/b&gt; handle any interrupt&lt;/span&gt;
tmpC  CX  JMPS NZ 1     &lt;span&gt;update CX, loop if not zero&lt;/span&gt;
           RNI          &lt;span&gt;&lt;b&gt;7:&lt;/b&gt; run next instruction&lt;/span&gt;

OPR  M    JMPS F1 5    &lt;span&gt;&lt;b&gt;8:&lt;/b&gt; LODS path: store AL/AX, jump back if REP&lt;/span&gt;
           RNI           &lt;span&gt;run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;Now let&#39;s look at the case with a &lt;code&gt;REP&lt;/code&gt; prefix, causing the instruction to loop.
The first step is to test if the count register &lt;code&gt;CX&lt;/code&gt; is zero, and bail out of the loop if so.
In more detail, the &lt;code&gt;REP&lt;/code&gt; prefix sets an internal flag called &lt;code&gt;F1&lt;/code&gt;. The first micro-instruction for &lt;code&gt;MOVS&lt;/code&gt; above conditionally calls the &lt;code&gt;RPTS&lt;/code&gt; subroutine if &lt;code&gt;F1&lt;/code&gt; is set.
The &lt;code&gt;RPTS&lt;/code&gt; subroutine below is a bit tricky.
First, it moves the count in &lt;code&gt;CX&lt;/code&gt; to the ALU&#39;s temporary C register. It also configures the ALU to pass tmpC through unchanged.
The next move discards the ALU result , but as a side effect, sets a flag if the value is zero.
This micro-instruction also configures the ALU to perform &lt;code&gt;DEC tmpC&lt;/code&gt;, but the decrement doesn&#39;t happen yet.
Next, if the value is nonzero (&lt;code&gt;NZ&lt;/code&gt;), the microcode execution jumps to 10 and returns from the microcode subroutine,
continuing execution of the &lt;code&gt;MOVS&lt;/code&gt; code described above.
On the other hand, if &lt;code&gt;CX&lt;/code&gt; is zero, execution falls through to &lt;code&gt;RNI&lt;/code&gt; (Run Next Instruction), which terminates execution of
the &lt;code&gt;MOVS&lt;/code&gt; instruction.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
CX  tmpC     PASS tmpC   &lt;span&gt;&lt;b&gt;RPTS:&lt;/b&gt; test CX&lt;/span&gt;
  no dest   DEC tmpC     &lt;span&gt;Set up decrement for later&lt;/span&gt;
              JMPS NZ 10   &lt;span&gt;Jump to 10 if CX not zero&lt;/span&gt;
              RNI          &lt;span&gt;If 0, run next instruction&lt;/span&gt;
              RTN         &lt;span&gt;&lt;b&gt;10:&lt;/b&gt; return&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;If execution returns to the &lt;code&gt;MOVS&lt;/code&gt; microcode, it will execute as described earlier until the &lt;code&gt;NF1&lt;/code&gt; test below.
With a &lt;code&gt;REP&lt;/code&gt; prefix, the test fails and microcode execution falls through.
The next micro-instruction performs &lt;code&gt;  tmpC&lt;/code&gt;, which puts the ALU result into tmpC.
The ALU was configured back in the &lt;code&gt;RPTS&lt;/code&gt; subroutine to decrement tmpC, which holds the count from &lt;code&gt;CX&lt;/code&gt;, so the
result is that &lt;code&gt;CX&lt;/code&gt; is decremented, put into tmpC, and then put back into &lt;code&gt;CX&lt;/code&gt; in the next micro-instruction.
It seems like a roundabout way to decrement the counter, but that&#39;s microcode.
Finally, if the value is nonzero (&lt;code&gt;NZ&lt;/code&gt;), microcode execution jumps back to 1 (near the top of the &lt;code&gt;MOVS&lt;/code&gt; code earlier), repeating the whole process.
Otherwise, &lt;code&gt;RNI&lt;/code&gt; ends processing of the instruction.
Thus, the &lt;code&gt;MOVS&lt;/code&gt; instruction repeats until &lt;code&gt;CX&lt;/code&gt; is zero.
In the next section, I&#39;ll explain how &lt;code&gt;JMP INT RPTI&lt;/code&gt; handles an interrupt.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
IND  DI   JMPS NF1 7   &lt;span&gt;&lt;b&gt;4:&lt;/b&gt; run next instruction if not REP&lt;/span&gt;
  tmpC   JMP INT RPTI &lt;span&gt;&lt;b&gt;5:&lt;/b&gt; handle any interrupt&lt;/span&gt;
tmpC  CX  JMPS NZ 1     &lt;span&gt;update CX, loop if not zero&lt;/span&gt;
           RNI          &lt;span&gt;&lt;b&gt;7:&lt;/b&gt; run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;NZ&lt;/code&gt; (not zero) condition tests a special 16-bit zero flag, not the standard zero status flag.
This allows zero to be tested without messing up the zero status flag.&lt;/p&gt;
&lt;h3&gt;Interrupts&lt;/h3&gt;
&lt;p&gt;Interrupts pose a problem for the string operations.
The idea behind interrupts is that the computer can be interrupted during processing to handle a high-priority task,
such as an I/O device that needs servicing. The processor stops its current task, executes the interrupt handling code,
and then returns to the original task.
The 8086 processor normally completes the instruction that it is executing before handling the
interrupt, so it can continue from a well-defined state.
However, a string operation can perform up to 64k moves, which could take a large fraction of a second.&lt;span id=&quot;fnref:memory&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:memory&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
If the 8086 waited for the string operation to complete, interrupt handling would be way too slow and could lose network packets or disk data, for instance.&lt;/p&gt;
&lt;p&gt;The solution is that a string instruction can be interrupted in the middle of the instruction, unlike most instructions.
The string instructions are designed to use registers in a way that allows the instruction to be restarted.
The idea is that the &lt;code&gt;CX&lt;/code&gt; register holds the current count, while the &lt;code&gt;SI&lt;/code&gt; and &lt;code&gt;DI&lt;/code&gt; registers hold the current memory
pointers, and these registers are updated as the instruction progresses. If the instruction is interrupted it can simply
continue where it left off.
After the interrupt, the 8086 restarts the string operation by backing the program counter up by two bytes
(one byte for the &lt;code&gt;REP&lt;/code&gt; prefix and one byte for the string opcode.)
This causes the interrupted string operation to be re-executed, continuing where it left off.&lt;/p&gt;
&lt;p&gt;If there is an interrupt, the &lt;code&gt;RPTI&lt;/code&gt; microcode routine below is called to update the program counter.
Updating the program counter is harder than you&#39;d expect because the 8086 prefetches instructions.
The idea is that while the memory bus is idle, instructions are read from memory into a prefetch queue.
Then, when an instruction is needed, the processor can (hopefully) get the instruction immediately from the prefetch
queue instead of waiting for a memory access.
As a result, the program counter in the 8086 points to the memory address of the next instruction to &lt;em&gt;fetch&lt;/em&gt;, not the
next instruction to &lt;em&gt;execute&lt;/em&gt;.
To get the &quot;real&quot; program counter value, prefetching is first suspended (&lt;code&gt;SUSP&lt;/code&gt;). Then the &lt;code&gt;PC&lt;/code&gt; value is corrected (&lt;code&gt;CORR&lt;/code&gt;) by subtracting the
length of the prefetch queue. At this point, the &lt;code&gt;PC&lt;/code&gt; points to the next instruction to execute.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
tmpC  CX   SUSP        &lt;span&gt;&lt;b&gt;RPTI:&lt;/b&gt; store CX&lt;/span&gt;
            CORR         &lt;span&gt;correct PC&lt;/span&gt;
PC  tmpB   DEC2 tmpB  
  PC      FLUSH RNI    &lt;span&gt;PC -= 2, end instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;At last, the microcode gets to the purpose of this subroutine: the &lt;code&gt;PC&lt;/code&gt; is decremented by 2 (&lt;code&gt;DEC2&lt;/code&gt;) using the ALU.
The prefetch queue is flushed and restarted and the &lt;code&gt;RNI&lt;/code&gt; micro-operation terminates the microcode and runs the next instruction.
Normally this would execute the instruction from the new program counter value (which now points to the string operation).
However, since there is an interrupt pending, the interrupt will take place instead, and the interrupt handler will
execute.
After the interrupt handler finishes, the interrupted string operation will be re-executed, continuing where it left off.&lt;/p&gt;
&lt;p&gt;There&#39;s another complication, of course.
An 8086 instruction can have multiple prefixes attached,
for example using a segment register prefix to access a different segment.
The approach of backing up two bytes will only execute the
last prefix, ignoring any others, so if you have two prefixes, the instruction doesn&#39;t get restarted correctly.
The 8086 documentation describes this unfortunate behavior.
Apparently a comprehensive solution (e.g. counting the prefixes or providing a buffer to hold prefixes during an interrupt)
was impractical for the 8086. I think this was fixed in the 80286.&lt;/p&gt;
&lt;!-- p3-31 of the 8086/88/186/188 manual states this problem. http://www.bitsavers.org/components/intel/80186/210911-001_iAPX86_88_186_188_Programmers_Reference_1983.pdf  But the 286 manual doesn&#39;t mention it. --&gt;

&lt;h3&gt;The remaining string instructions&lt;/h3&gt;
&lt;p&gt;I&#39;ll discuss the microcode for the other string operations briefly.
The &lt;code&gt;LODS&lt;/code&gt; instruction loads from memory into the accumulator. It uses the same microcode routine as &lt;code&gt;MOVS&lt;/code&gt;; the code
below is the same code discussed earlier.
However, the path through the microcode is different for &lt;code&gt;LODS&lt;/code&gt; since the &lt;code&gt;JMPS X0 8&lt;/code&gt; conditional jump will be taken.
(This tests bit 3 of the opcode, which is set for &lt;code&gt;LODS&lt;/code&gt;.)
At step 8, a value has been read from memory and is in the &lt;code&gt;OPR&lt;/code&gt; (Operand) register. 
This micro-instruction moves the value from &lt;code&gt;OPR&lt;/code&gt; to the accumulator (represented by &lt;code&gt;M&lt;/code&gt; for complicated reasons&lt;span id=&quot;fnref:m&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:m&quot;&gt;6&lt;/a&gt;&lt;/span&gt;).
If there is a repeat prefix, the microcode jumps back to the previous flow (5). Otherwise, &lt;code&gt;RNI&lt;/code&gt; runs the next instruction.
Thus, &lt;code&gt;LODS&lt;/code&gt; shares almost all its microcode with &lt;code&gt;MOVS&lt;/code&gt;, making the microcode more compact at the cost of slowing it
down slightly due to the conditional jumps.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
 move       action           
           CALL F1 RPTS &lt;span&gt;&lt;b&gt;MOVS/LODS:&lt;/b&gt; handle REP if active&lt;/span&gt;
SI  IND   R DS,BL      &lt;span&gt;&lt;b&gt;1:&lt;/b&gt; Read byte/word from SI&lt;/span&gt;
IND  SI   JMPS X0 8     &lt;span&gt;test instruction bit 3: jump if LODS&lt;/span&gt;
DI  IND   W DA,BL       &lt;span&gt;MOVS path: write to DI&lt;/span&gt;
IND  DI   JMPS NF1 7   &lt;span&gt;&lt;b&gt;4:&lt;/b&gt; run next instruction if not REP&lt;/span&gt;
  tmpC   JMP INT RPTI &lt;span&gt;&lt;b&gt;5:&lt;/b&gt; handle any interrupt&lt;/span&gt;
tmpC  CX  JMPS NZ 1     &lt;span&gt;update CX, loop if not zero&lt;/span&gt;
           RNI          &lt;span&gt;&lt;b&gt;7:&lt;/b&gt; run next instruction&lt;/span&gt;

OPR  M    JMPS F1 5    &lt;span&gt;&lt;b&gt;8:&lt;/b&gt; LODS path: store AL/AX, jump back if REP&lt;/span&gt;
           RNI           &lt;span&gt;run next instruction&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;STOS&lt;/code&gt; instruction is the opposite of &lt;code&gt;LODS&lt;/code&gt;, storing the accumulator value into memory.
The microcode (below) is essentially the second half of the &lt;code&gt;MOVS&lt;/code&gt; microcode.
The memory address in &lt;code&gt;DI&lt;/code&gt; is moved to the &lt;code&gt;IND&lt;/code&gt; register and the value in the accumulator is moved to the &lt;code&gt;OPR&lt;/code&gt; register
to set up the write operation. (As with &lt;code&gt;LODS&lt;/code&gt;, the &lt;code&gt;M&lt;/code&gt; register indicates the accumulator.&lt;span id=&quot;fnref2:m&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:m&quot;&gt;6&lt;/a&gt;&lt;/span&gt;)
The &lt;code&gt;CX&lt;/code&gt; register is decremented using the ALU.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
DI  IND    CALL F1 RPTS   &lt;span&gt;&lt;b&gt;STOS:&lt;/b&gt; if REP prefix, test if done&lt;/span&gt;
M  OPR     W DA,BL        &lt;span&gt;&lt;b&gt;1:&lt;/b&gt; write the value to memory&lt;/span&gt;
IND  DI    JMPS NF1 5      &lt;span&gt;Quit if not F1 (repeat)&lt;/span&gt;
  tmpC    JMP INT RPTI    &lt;span&gt;Jump to RPTI if interrupt&lt;/span&gt;
tmpC  CX   JMPS NZ 1       &lt;span&gt;Loop back if CX not zero&lt;/span&gt;
            RNI            &lt;span&gt;&lt;b&gt;5:&lt;/b&gt; run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;CMPS&lt;/code&gt; instruction compares strings, while the &lt;code&gt;SCAS&lt;/code&gt; instruction looks for a zero or non-zero value, depending on the prefix.
They share the microcode routine below, with the &lt;code&gt;X0&lt;/code&gt; condition testing bit 3 of the instruction to select the path.
The difference is that &lt;code&gt;CMPS&lt;/code&gt; reads the comparison character
from &lt;code&gt;SI&lt;/code&gt;, while &lt;code&gt;SCAS&lt;/code&gt; compares against the character in the accumulator. 
The comparison itself is done by subtracting the two values and discarding the result. The &lt;code&gt;F&lt;/code&gt; bit in the micro-instruction causes the processor&#39;s status flags to
be updated with the result of the subtraction, indicating less than, equal, or greater than.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
            CALL F1 RPTS   &lt;span&gt;&lt;b&gt;CMPS/SCAS:&lt;/b&gt; if RPT, quit if done&lt;/span&gt;
M  tmpA    JMPS X0 5      &lt;span&gt;&lt;b&gt;1:&lt;/b&gt;accum to tmpA, jump if SCAS&lt;/span&gt;
SI  IND    R DS,BL         &lt;span&gt;CMPS path, read from SI to tmpA&lt;/span&gt;
IND  SI                    &lt;span&gt;update SI&lt;/span&gt;
OPR  tmpA                  &lt;span&gt;fallthrough&lt;/span&gt;
DI  IND    R DA,BL        &lt;span&gt;&lt;b&gt;5:&lt;/b&gt; both: read from DI to tmpB&lt;/span&gt;
OPR  tmpB  SUBT tmpA       &lt;span&gt;subtract to compare&lt;/span&gt;
  no dest DEC tmpC F      &lt;span&gt;update flags, set up DEC&lt;/span&gt;
IND  DI    JMPS NF1 12     &lt;span&gt;return if not RPT&lt;/span&gt;
  CX      JMPS F1ZZ 12    &lt;span&gt;update CX, exit if condition&lt;/span&gt;
  tmpC    JMP INT RPTI    &lt;span&gt;if interrupt, jump to RPTI&lt;/span&gt;
            JMPS NZ 1       &lt;span&gt;loop if CX  0&lt;/span&gt;
            RNI            &lt;span&gt;&lt;b&gt;12:&lt;/b&gt; run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;One tricky part about the scan and compare instructions is that you can either repeat until the values are equal or until they are unequal,
with the &lt;code&gt;REPE&lt;/code&gt; or &lt;code&gt;REPNE&lt;/code&gt; prefixes respectively. Rather than implementing this two-part condition in microcode, the &lt;code&gt;F1ZZ&lt;/code&gt; condition above
tests the right condition depending on the prefix.&lt;/p&gt;
&lt;h2&gt;Hardware support&lt;/h2&gt;
&lt;p&gt;Although the 8086 uses microcode to implement instructions, it also uses a considerable amount of hardware to
simplify the microcode.
This hybrid approach was necessary in order to fit the microcode into the small ROM capacity available in 1978.&lt;span id=&quot;fnref:microcode&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:microcode&quot;&gt;7&lt;/a&gt;&lt;/span&gt;
This section discusses some of the hardware circuitry in the 8086 that supports the string operations.&lt;/p&gt;
&lt;h3&gt;Implementing the &lt;code&gt;REP&lt;/code&gt; prefixes&lt;/h3&gt;
&lt;p&gt;Instruction prefixes, including &lt;code&gt;REPNZ&lt;/code&gt; and &lt;code&gt;REPZ&lt;/code&gt;, are executed in hardware rather than microcode.
The first step of instruction decoding, before microcode starts, is the Group Decode ROM.
This ROM categorizes instructions into various groups.
For instructions that are categorized as prefixes, the signal from the Group Decode ROM
delays any interrupts (because you don&#39;t want an interrupt between the prefix and the instruction)
and starts the next instruction without executing microcode.
The Group Decode ROM also outputs a &lt;code&gt;REP&lt;/code&gt; signal specifically for these two prefixes.
This signal causes the &lt;code&gt;F1&lt;/code&gt; latch to be loaded with 1, indicating a &lt;code&gt;REP&lt;/code&gt; prefix.
(This latch is also used during multiplication to track the sign.)
This signal also causes the &lt;code&gt;F1Z&lt;/code&gt; latch to be loaded with bit 0 of the instruction, which is 0 for &lt;code&gt;REPNZ&lt;/code&gt; and 1 for &lt;code&gt;REPZ&lt;/code&gt;.
The microcode uses these latches to determine the appropriate behavior of the string instruction.&lt;/p&gt;
&lt;h3&gt;Updating &lt;code&gt;SI&lt;/code&gt; and &lt;code&gt;DI&lt;/code&gt;: the Constant ROM&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;SI&lt;/code&gt; and &lt;code&gt;DI&lt;/code&gt; index registers are updated during each step to point to the next element.
This update is more complicated than you might expect, though, since
the registers are incremented or decremented based on the Direction Flag.
Moreover, the step size, 1 or 2, varies for a byte or word operation.
Another complication is unaligned word accesses, using an odd memory address to access a word.
The 8086&#39;s bus can only handle aligned words, so an unaligned word access is split into two byte accesses, incrementing
the address after the first access.
If the operation is proceeding downward, the address then needs to be decremented by 3 (not 2) at the end to
cancel out this increment.
The point is that updating the index registers is not trivial but requires an adjustment anywhere between -3 and +2, depending
on the circumstances.&lt;/p&gt;
&lt;p&gt;The Bus Interface Unit performs these updates automatically, without requiring the microcode to implement the addition or subtraction.
The arithmetic is not performed by the regular ALU (Arithmetic/Logic Unit) but by the special adder dedicated to addressing
arithmetic.
The increment or decrement value is supplied by a special ROM called the Constant ROM, located next to the adder.
The Constant ROM (shown below) is implemented as a PLA (programmable logic array), a two-level structured arrangement of gates.
The first level (bottom) selects the desired constant, while the second level (middle) generates the bits of the constant: three bits plus a sign bit.
The constant ROM is also used for correcting the program counter value as described earlier.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-str/constant-die.jpg&quot;&gt;&lt;img alt=&quot;The Constant ROM, highlighted on the die. The correction constants are used to correct the PC.&quot; class=&quot;hilite&quot; height=&quot;451&quot; src=&quot;https://static.righto.com/images/8086-str/constant-die-w400.jpg&quot; title=&quot;The Constant ROM, highlighted on the die. The correction constants are used to correct the PC.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Constant ROM, highlighted on the die. The correction constants are used to correct the PC.&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;Condition testing&lt;/h3&gt;
&lt;p&gt;The microcode supports conditional jumps based on 16 conditions. Several of these conditions are designed to support the 
string operations.
To test if a &lt;code&gt;REP&lt;/code&gt; prefix is active, microcode uses the &lt;code&gt;F1&lt;/code&gt; test, which tests the &lt;code&gt;F1&lt;/code&gt; latch.
The &lt;code&gt;REPZ&lt;/code&gt; and &lt;code&gt;REPNZ&lt;/code&gt; prefixes loop while the zero flag is 1 or 0 respectively.
This somewhat complicated test is supported in microcode by the &lt;code&gt;F1ZZ&lt;/code&gt; condition, which evaluates the zero flag XOR the &lt;code&gt;F1Z&lt;/code&gt; latch. Thus, it tests for zero with REPZ (&lt;code&gt;F1Z=0&lt;/code&gt;) and nonzero with REPNZ (&lt;code&gt;F1Z=1&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Looping happens as long as the &lt;code&gt;CX&lt;/code&gt; register is nonzero. This is tested in microcode with the &lt;code&gt;NZ&lt;/code&gt; (Not Zero) condition.
A bit surprisingly, this test doesn&#39;t use the standard zero status flag, but a separate latch that tracks if an ALU result is zero.
(I call this the &lt;code&gt;Z16&lt;/code&gt; flag since it tests the 16-bit value, unlike the regular zero flag which tests either a byte or word.)
The &lt;code&gt;Z16&lt;/code&gt; flag is only used by the microcode and is invisible to the programmer.
The motivation behind this separate flag is so the string operations can leave the visible zero flag unchanged.&lt;span id=&quot;fnref:z16&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:z16&quot;&gt;8&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Another important conditional jump is &lt;code&gt;X0&lt;/code&gt;, which tests bit 3 of the instruction.
This condition distinguishes between the &lt;code&gt;MOVS&lt;/code&gt; and &lt;code&gt;LODS&lt;/code&gt; instructions, which differ in bit 3, and similarly for
&lt;code&gt;CMPS&lt;/code&gt; versus &lt;code&gt;SCAS&lt;/code&gt;.
The test uses the &lt;code&gt;X&lt;/code&gt; register which stores part of the instruction during decoding.
Note that the opcodes aren&#39;t arbitrarily assigned to instructions like &lt;code&gt;MOVS&lt;/code&gt; and &lt;code&gt;LODS&lt;/code&gt;. Instead, the opcodes
are carefully assigned so the instructions can share microcode but be distinguished by &lt;code&gt;X0&lt;/code&gt;.
Finally, the string operation microcode also uses the &lt;code&gt;INT&lt;/code&gt; condition, which tests if an interrupt is pending.&lt;/p&gt;
&lt;p&gt;The conditions are evaluated by the condition PLA (Programmable Logic Array, a grid of gates), shown below.
The four condition bits from the micro-instruction, along with their complements, are fed into the columns.
The PLA has 16 rows, one for each condition. 
Each row is a NOR gate matching one bit combination (i.e. selecting a condition) and the corresponding signal value to
test.
Thus, if a particular condition is specified and is satisfied, that row will be 1.
The 16 row outputs are combined by the 16-input NOR gate at the left.
Thus, if the specified condition is satisfied, this output will be 0, and if the condition is unsatisfied, the
output will be 1.
This signal controls the jump or call micro-instruction:
if the condition is satisfied, the new micro-address is loaded into the microcode address register.
If the condition is not satisfied, the microcode proceeds sequentially.
I discuss the 8086&#39;s conditional circuitry in more detail in &lt;a href=&quot;https://www.righto.com/2023/01/reverse-engineering-conditional-jump.html&quot;&gt;this post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-str/condition-pla.jpg&quot;&gt;&lt;img alt=&quot;The condition PLA evaluates microcode conditionals.&quot; class=&quot;hilite&quot; height=&quot;467&quot; src=&quot;https://static.righto.com/images/8086-str/condition-pla-w300.jpg&quot; title=&quot;The condition PLA evaluates microcode conditionals.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The condition PLA evaluates microcode conditionals.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;!--
These string instructions live on in the modern x86 architecture, mostly the same except they also support operation on double words or quad words (i.e. 32- or 64-bit operands).[^ins]

[^ins]:
    The 80186 added block instructions to support block I/O: `INS` and `OUTS`.
--&gt;

&lt;p&gt;Hopefully you have found this close examination of microcode interesting.
Microcode is implemented at an even lower level than assembly code, so it can be hard to understand.
Moreover, the microcode in the 8086 was carefully optimized to make it compact, so it is even more obscure.&lt;/p&gt;
&lt;p&gt;One of the big computer architecture debates of the 1980s was &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Reduced_instruction_set_computer&quot;&gt;RISC vs CISC&lt;/a&gt;&quot;, pitting Reduced Instruction Set Computers against Complex Instruction Set Computers.
Looking at the 8086 in detail has given me more appreciation for the issues in a CISC processor such as the 8086.
The 8086&#39;s string instructions are an example of the complex instructions in the 8086 that reduced the &quot;semantic gap&quot;
between assembly code and high-level languages and minimized code size.
While these instructions are powerful, their complexity spreads through the chip, requiring additional hardware features
described above. These instructions also caused a great deal of complications for interrupt handling, including prefix-handling
bugs that weren&#39;t fixed until later processors.&lt;/p&gt;
&lt;p&gt;I&#39;ve written multiple &lt;a href=&quot;https://www.righto.com/search/label/8086&quot;&gt;posts on the 8086&lt;/a&gt; so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@kenshirriff@oldbytes.space&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:history&quot;&gt;
&lt;p&gt;Block move instructions didn&#39;t originate with the 8086.
The IBM System/360 series of mainframes had an extensive set of block instructions providing moves, compare, logical operations
(AND, OR, Exclusive OR), character translation, formatting, and decimal arithmetic. These operations supported blocks
of up to 256 characters.&lt;/p&gt;
&lt;p&gt;The Z80 processor (1976) had block instructions to move and compare blocks of data. The Z80 supported ascending and
descending movements, but used separate instructions instead of a direction flag like the 8086.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:history&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:string&quot;&gt;
&lt;p&gt;The &quot;string&quot; operations process arbitrary memory bytes or words.
Despite the name, these instructions are not specific to zero-terminated strings or any other string format.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:string&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:bl&quot;&gt;
&lt;p&gt;The &lt;code&gt;BL&lt;/code&gt; value in the micro-instruction indicates that the &lt;code&gt;IND&lt;/code&gt; register should be incremented or decremented by 1 or 2
as appropriate.
I&#39;m not sure what &lt;code&gt;BL&lt;/code&gt; stands for in the microcode. The patent says &quot;BL symbolically represents a
two bit code which causes external logic to examine the
byte or word line and the direction flag in PSW register
to generate, according to random logic well known
to the art, the address factor required.&quot; So perhaps &quot;Byte Logic&quot;?&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:bl&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref2:bl&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:morse&quot;&gt;
&lt;p&gt;The designer of the 8086 instruction set, Steve Morse, discusses the motivation behind the string operations in his book &lt;a href=&quot;https://amzn.to/3K2r92L&quot;&gt;The 8086/8088 primer&lt;/a&gt;.
These instructions were designed to be flexible and support a variety of use cases.
The &lt;code&gt;XLAT&lt;/code&gt; (Translate) and &lt;code&gt;JCXZ&lt;/code&gt; (Jump if &lt;code&gt;CX&lt;/code&gt; Zero) instructions were designed to work well with the string instructions.&lt;/p&gt;
&lt;p&gt;The implementation of string instructions is discussed in detail in the &lt;a href=&quot;https://patents.google.com/patent/US4449184A&quot;&gt;8086 patent&lt;/a&gt;, section 13 onward.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:morse&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:memory&quot;&gt;
&lt;p&gt;A string operation could perform 64k moves, each of which consists of a read and a write, yielding 128k memory operations.
I think that if the memory accesses are unaligned, i.e. a word access to an odd address, then each byte of the word
needs to be accessed separately. So I think you could get up to 256k memory accesses.
Each memory operation takes at least 4 clock cycles, more if the memory is slow and has wait states.
So one string instruction could take over a million clock cycles.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:memory&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:m&quot;&gt;
&lt;p&gt;You might wonder why the register &lt;code&gt;M&lt;/code&gt; indicates the accumulator, and the explanation is a bit tricky.
The microcode uses 5-bit register specifications to indicate the source and destination for a data move.
Registers can be specified explicitly, such as &lt;code&gt;AX&lt;/code&gt; or &lt;code&gt;BX&lt;/code&gt;, or a byte register such as &lt;code&gt;AL&lt;/code&gt; or an
internal register such as &lt;code&gt;IND&lt;/code&gt; or &lt;code&gt;tmpA&lt;/code&gt;.
However, the microcode can also specify a generic source or destination register with &lt;code&gt;M&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt;.
The motivation is that the 8086 has a lot of operations that use an arbitrary source and destination register, for
instance &lt;code&gt;ADD AX, BX&lt;/code&gt;. Rather than making the microcode figure out which registers to use for these instructions,
the hardware decodes the register fields from the instruction and substitutes the appropriate registers for &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt;.
This makes the microcode much simpler.&lt;/p&gt;
&lt;p&gt;But why does the &lt;code&gt;LODS&lt;/code&gt; microcode use the &lt;code&gt;M&lt;/code&gt; register instead of &lt;code&gt;AX&lt;/code&gt; when this instruction only works with the accumulator?
The microcode takes advantage of another clever feature of the &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; registers. The hardware looks at the instruction to
determine if it is a byte or word instruction, and performs an 8-bit or 16-bit transfer accordingly.
If the &lt;code&gt;LODS&lt;/code&gt; microcode was hardcoded for the accumulator, the microcode would need separate paths for &lt;code&gt;AX&lt;/code&gt; and &lt;code&gt;AL&lt;/code&gt;,
the full accumulator and the lower byte of the accumulator.&lt;/p&gt;
&lt;p&gt;The final piece of the puzzle is how the hardware knows to use the accumulator for the string instructions when they
don&#39;t explicitly specify a register.
The first step of instruction decoding is the Group Decode ROM, which categorizes instructions into various groups.
One group is &quot;instructions that use the accumulator&quot;. The string operations are categorized in this group, which causes
the hardware to use the accumulator when the &lt;code&gt;M&lt;/code&gt; register is specified.
(Other instructions in this group include the immediate ALU operations, I/O operations, and accumulator moves.)&lt;/p&gt;
&lt;p&gt;I discussed the 8086&#39;s register codes in more detail &lt;a href=&quot;https://www.righto.com/2023/03/8086-register-codes.html&quot;&gt;here&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:m&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref2:m&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:microcode&quot;&gt;
&lt;p&gt;The 8086&#39;s microcode ROM was small: 512 words of 21 bits. In comparison, the VAX 11/780 minicomputer (1977)
had 5120 words of 96 bits, over 45 times as large.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:microcode&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:z16&quot;&gt;
&lt;p&gt;The internal &lt;code&gt;Z16&lt;/code&gt; zero flag is mostly used by the string operations. It is also used by the &lt;code&gt;LOOP&lt;/code&gt; iteration-control instructions and the shift
instructions that take a shift count.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:z16&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/6370120370244800510/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=6370120370244800510' title='10 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/6370120370244800510'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/6370120370244800510'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/04/8086-microcode-string-operations.html' title='The microcode and hardware in the 8086 processor that perform string operations'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>10</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-8868607841305902549</id><published>2023-03-22T09:45:00.000-07:00</published><updated>2023-03-22T09:45:54.962-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="analog"/><category scheme="http://www.blogger.com/atom/ns#" term="globus"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><category scheme="http://www.blogger.com/atom/ns#" term="space"/><title type='text'>Reverse-engineering the Globus INK, a Soviet spaceflight navigation computer</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
&lt;/style&gt;

&lt;p&gt;One of the most interesting navigation instruments onboard Soyuz spacecraft was the Globus INK,&lt;span id=&quot;fnref:ink&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:ink&quot;&gt;1&lt;/a&gt;&lt;/span&gt; which used a rotating globe
to indicate the spacecraft&#39;s position above the Earth.
This electromechanical analog computer used an elaborate system of gears, cams, and differentials
to compute the spacecraft&#39;s position.
The globe rotates in two dimensions: it spins end-over-end to indicate the spacecraft&#39;s orbit, while
the globe&#39;s hemispheres rotate according to the Earth&#39;s daily rotation around its axis.&lt;span id=&quot;fnref:day&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:day&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
The spacecraft&#39;s position above the Earth was represented by the fixed crosshairs on the plastic dome.
The Globus also has latitude and longitude dials next to the globe to show the position numerically, while the light/shadow dial below the globe indicated when the
spacecraft would enter or leave the Earth&#39;s shadow.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/globus.jpg&quot;&gt;&lt;img alt=&quot;The INK-2S &amp;quot;Globus&amp;quot; space navigation indicator.&quot; class=&quot;hilite&quot; height=&quot;457&quot; src=&quot;https://static.righto.com/images/globus-gearing/globus-w600.jpg&quot; title=&quot;The INK-2S &amp;quot;Globus&amp;quot; space navigation indicator.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The INK-2S &quot;Globus&quot; space navigation indicator.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Opening up the Globus reveals that it is packed with complicated gears and mechanisms.
It&#39;s amazing that this mechanical technology was used from the 1960s into the 21st century.
But what are all those gears doing? How can orbital functions be implemented with gears?
To answer these questions, I reverse-engineered the Globus and traced out its system of gears.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/opened-end.jpg&quot;&gt;&lt;img alt=&quot;The Globus with the case removed, showing the complex gearing inside.&quot; class=&quot;hilite&quot; height=&quot;496&quot; src=&quot;https://static.righto.com/images/globus-gearing/opened-end-w500.jpg&quot; title=&quot;The Globus with the case removed, showing the complex gearing inside.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Globus with the case removed, showing the complex gearing inside.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The diagram below summarizes my analysis.
The Globus is an analog computer that represents values by rotating shafts by particular amounts.
These rotations control the globe
and the indicator dials.
The flow of these rotational signals is shown by the lines on the diagram.
The computation is based around addition, performed by ten differential gear assemblies.
On the diagram, each &quot;&quot; symbol indicates one of these differential gear assemblies.
Other gears connect the components while scaling the signals through various gear ratios.
Complicated functions are implemented with three specially-shaped cams.
In the remainder of this blog post, I will break this diagram down into functional blocks and explain how the Globus operates.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/diagram.png&quot;&gt;&lt;img alt=&quot;This diagram shows the interconnections of the gear network in the Globus.&quot; class=&quot;hilite&quot; height=&quot;370&quot; src=&quot;https://static.righto.com/images/globus-gearing/diagram-w700.png&quot; title=&quot;This diagram shows the interconnections of the gear network in the Globus.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This diagram shows the interconnections of the gear network in the Globus.&lt;/div&gt;&lt;/p&gt;
&lt;!--
## The overall network

I&#39;ve created the diagram below to show how the mechanical components of the Globus are connected.
This diagram focuses on the ten differentials, numbered 1 through 10.
The orbital motion is controlled by differentials 1 through 3. This block is driven by the orbit solenoid, which provides a small
rotation once every second. The cam provides an adjustment to the orbital speed, which varies depending on altitude.

The orbit knob on the front panel allows the position to be adjusted by hand. Differential 4 handles this input and produces the
orbital position signal. For the &quot;landing position&quot; mode, differential 5 allows the landing motor to rotate the position.
The output from differential 5 indicates the orbital position and rotates the globe. It also rotates a potentiometer to provide an output signal
and drives the light/shadow wheel.

The second motion is the Earth&#39;s rotation around its axis. This is driven by a second solenoid that pulses onces a second.
There is also a knob to manually rotate the globe around its axis. These signals are combined by differential 6.
Differential 7 adds the signal from the landing motor and differential 8 adds the signal from the orbital rotation;
these cancel out the mechanical effect of the orbital rotation on the earth rotation.

Differentials 9 and 10 compute the longitude, combining the effect of the Earth&#39;s rotation with the orbital motion, corrected by a cam.
--&gt;

&lt;p&gt;For all its complexity, though, the functionality of the Globus is pretty limited. It only handles a fixed orbit at a specific angle, and treats the
orbit as circular.
The Globus does not have any navigation input such as an inertial measurement unit (IMU).
Instead, the cosmonauts configured the Globus by turning knobs to set the spacecraft&#39;s initial position and orbital period.
From there, the Globus simply projected the current position of
the spacecraft forward, essentially &lt;a href=&quot;https://en.wikipedia.org/wiki/Dead_reckoning&quot;&gt;dead reckoning&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/gears.jpg&quot;&gt;&lt;img alt=&quot;A closeup of the gears inside the Globus.&quot; class=&quot;hilite&quot; height=&quot;374&quot; src=&quot;https://static.righto.com/images/globus-gearing/gears-w500.jpg&quot; title=&quot;A closeup of the gears inside the Globus.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A closeup of the gears inside the Globus.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The globe&lt;/h2&gt;
&lt;p&gt;On seeing the Globus, one might wonder how the globe is rotated.
It may seem that the globe must be free-floating so it can rotate in two axes.
Instead, a clever mechanism attaches the globe to the unit.
The key is that the globe&#39;s equator is a solid piece of metal that rotates around the horizontal axis of the unit.
A second gear mechanism inside the globe rotates the globe around the North-South axis.
The two rotations are controlled by concentric shafts that are fixed to the unit.
Thus, the globe has two rotational degrees of freedom, even though it is attached at both ends.&lt;/p&gt;
&lt;p&gt;The photo below shows the frame that holds and controls the globe.
The dotted axis is fixed horizontally in the unit and rotations are fed through the two gears at the left.
One gear rotates the globe and frame around the dotted axis, while the gear train causes the globe to rotate around the
vertical polar axis (while the equator remains fixed).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/axis.jpg&quot;&gt;&lt;img alt=&quot;The axis of the globe is at 51.8&amp;deg; to support that orbital inclination.&quot; class=&quot;hilite&quot; height=&quot;331&quot; src=&quot;https://static.righto.com/images/globus-gearing/axis-w500.jpg&quot; title=&quot;The axis of the globe is at 51.8&amp;deg; to support that orbital inclination.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The axis of the globe is at 51.8&amp;deg; to support that orbital inclination.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The angle above is 51.8&amp;deg; which is very important: this is the inclination of the standard Soyuz orbit.
As a result, simply rotating the globe around the dotted line causes the crosshair to trace the orbit.&lt;span id=&quot;fnref:orbit&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:orbit&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
Rotating the two halves of the globe around the poles yields the different paths over the Earth&#39;s surface
as the Earth rotates.
An important consequence of this design is that the Globus only supports a circular orbit at a fixed angle.&lt;/p&gt;
&lt;h2&gt;Differential gear mechanism&lt;/h2&gt;
&lt;p&gt;The primary mathematical element of the Globus is the differential gear mechanism, which can perform addition or subtraction.
A differential gear takes two rotations as inputs and produces the (scaled) sum of the rotations as the output.
The photo below shows one of the differential mechanisms.
In the middle, the spider gear assembly (red box) consists of two bevel gears that can spin freely on a vertical shaft.
The spider gear assembly as a whole is attached to a horizontal shaft, called the spider shaft.
At the right, the spider shaft is attached to a spur gear (a gear with straight-cut teeth).
The spider gear assembly, the spider shaft, and the spider&#39;s spur gear rotate together as a unit.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/differential-diagram.jpg&quot;&gt;&lt;img alt=&quot;Diagram showing the components of a differential gear mechanism.&quot; class=&quot;hilite&quot; height=&quot;384&quot; src=&quot;https://static.righto.com/images/globus-gearing/differential-diagram-w500.jpg&quot; title=&quot;Diagram showing the components of a differential gear mechanism.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Diagram showing the components of a differential gear mechanism.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;At the left and right are two end gear assemblies (yellow).
The end gear is a bevel gear with angled teeth to mesh with the spider gears.
Each end gear is locked to a spur gear and these gears spin freely on the horizontal spider shaft.
In total, there are three spur gears: two connected to the end gears and one connected to the spider assembly.
In the diagrams, I&#39;ll use the symbol below to represent the differential gear assembly: the end gears are symmetric on the top and bottom, with the
spider shaft on the side.
Any of the three spur gears can be used as an output, with the other two serving as inputs.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/differential-symbol.jpg&quot;&gt;&lt;img alt=&quot;The symbol for the differential gear assembly.&quot; class=&quot;hilite&quot; height=&quot;117&quot; src=&quot;https://static.righto.com/images/globus-gearing/differential-symbol-w120.jpg&quot; title=&quot;The symbol for the differential gear assembly.&quot; width=&quot;120&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The symbol for the differential gear assembly.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;To understand the behavior of the differential, suppose the two end gears are driven in the same direction at the same rate, say upwards.&lt;span id=&quot;fnref:directions&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:directions&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
These gears will push on the spider gears and rotate the spider gear assembly, with the entire differential rotating
as a fixed unit.
On the other hand, suppose the two end gears are driven in opposite directions.
In this case, the spider gears will spin on their shaft, but the spider gear assembly will remain stationary.
In either case, the spider gear assembly motion is the average of the two end gear rotations, that is, the sum of the two rotations divided by 2.
(I&#39;ll ignore the factor of 2 since I&#39;m ignoring all the gear ratios.)
If the operation of the differential is still confusing, &lt;a href=&quot;https://youtu.be/mQhmmTX5f9Y?t=68&quot;&gt;this vintage Navy video&lt;/a&gt; has a detailed explanation.&lt;/p&gt;
&lt;h2&gt;The controls and displays&lt;/h2&gt;
&lt;p&gt;The diagram below shows the controls and displays of the Globus.
The rotating globe is the centerpiece of the unit. Its plastic cover has a crosshair that represents the spacecraft&#39;s position above the Earth&#39;s surface.
Surrounding the globe itself are dials that show the longitude, latitude, and the time before entering light and shadow.
The cosmonauts manually initialize the globe position with the concentric globe rotation knobs: one rotates the globe along the orbital path
while the other rotates the hemispheres.
The mode switch at the top selects between the landing position mode, the standard Earth orbit mode, and turning off the unit.
The orbit time adjustment configures the orbital time period in minutes while
the orbit counter below it counts the number of orbits.
Finally, the landing point angle sets the distance to the landing point in degrees of orbit.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/globus-labeled.jpg&quot;&gt;&lt;img alt=&quot;The Globus with the controls labeled.&quot; class=&quot;hilite&quot; height=&quot;466&quot; src=&quot;https://static.righto.com/images/globus-gearing/globus-labeled-w700.jpg&quot; title=&quot;The Globus with the controls labeled.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Globus with the controls labeled.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Computing the orbit time&lt;/h2&gt;
&lt;p&gt;The primary motion of the Globus is the end-over-end rotation of the globe showing the movement of the spacecraft in orbit.
The orbital motion is powered by a solenoid at the top of the Globus that receives pulses once a second and advances a ratchet wheel (&lt;a href=&quot;https://twitter.com/kenshirriff/status/1628118949421363201&quot;&gt;video&lt;/a&gt;).&lt;span id=&quot;fnref:torque&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:torque&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
This wheel is connected to a complicated cam and differential system to provide the orbital motion.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/orbit-solenoid.jpg&quot;&gt;&lt;img alt=&quot;The orbit solenoid (green) has a ratchet that rotates the gear to the right. The shaft connects it to differential gear assembly 1 at the bottom right.&quot; class=&quot;hilite&quot; height=&quot;404&quot; src=&quot;https://static.righto.com/images/globus-gearing/orbit-solenoid-w500.jpg&quot; title=&quot;The orbit solenoid (green) has a ratchet that rotates the gear to the right. The shaft connects it to differential gear assembly 1 at the bottom right.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The orbit solenoid (green) has a ratchet that rotates the gear to the right. The shaft connects it to differential gear assembly 1 at the bottom right.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Each orbit takes about 92 minutes, but the orbital time can be adjusted by a few minutes in steps of 0.01 minutes&lt;span id=&quot;fnref:time&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:time&quot;&gt;6&lt;/a&gt;&lt;/span&gt;
to account for changes in altitude. The Globus is surprisingly inflexible and this is the only orbital parameter that can be adjusted.&lt;span id=&quot;fnref:parameters&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:parameters&quot;&gt;7&lt;/a&gt;&lt;/span&gt;
The orbital period is adjusted by the three-position orbit time switch, which points to the minutes, tenths, or hundredths.
Turning the central knob adjusts the indicated period dial.&lt;/p&gt;
&lt;p&gt;The problem is how to generate the variable orbital rotation speed from the fixed speed of the solenoid.
The solution is a special cam, shaped like a cone with a spiral cross-section.
Three followers ride on the cam, so as the cam rotates, the follower is pushed outward and rotates on its shaft.
If the follower is near the narrow part of the cam, it moves over a small distance and has a small rotation.
But if the follower is near the wide part of the cam, it moves a larger distance and has a larger rotation.
Thus, by moving the follower to a particular point on the cam, the rotational speed of the follower is selected.
One follower adjusts the speed based on the minutes setting with others for the tenths and hundredths of minutes.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/cone-diagram.jpg&quot;&gt;&lt;img alt=&quot;A diagram showing the orbital speed control mechanism. The cone has three followers, but only two are visible from this angle. The &amp;quot;transmission&amp;quot; gears are moved in and out by the outer knob to select which follower is adjusted by the inner knob.&quot; class=&quot;hilite&quot; height=&quot;533&quot; src=&quot;https://static.righto.com/images/globus-gearing/cone-diagram-w600.jpg&quot; title=&quot;A diagram showing the orbital speed control mechanism. The cone has three followers, but only two are visible from this angle. The &amp;quot;transmission&amp;quot; gears are moved in and out by the outer knob to select which follower is adjusted by the inner knob.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A diagram showing the orbital speed control mechanism. The cone has three followers, but only two are visible from this angle. The &quot;transmission&quot; gears are moved in and out by the outer knob to select which follower is adjusted by the inner knob.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Of course, the cam can&#39;t spiral out forever.
Instead, at the end of one revolution, its cross-section drops back sharply to the starting diameter.
This causes the follower to snap back to its original position. 
To prevent this from jerking the globe backward, the follower is connected to the differential gearing via a slip clutch and ratchet.
Thus, when the follower snaps back, the ratchet holds the drive shaft stationary.
The drive shaft then continues its rotation as the follower starts cycling out again. 
Each shaft output is accordingly a (mostly) smooth rotation at a speed that depends on the position of the follower.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/diagram-orbit.png&quot;&gt;&lt;img alt=&quot;A cam-based system adjusts the orbital speed using three differential gear assemblies.&quot; class=&quot;hilite&quot; height=&quot;353&quot; src=&quot;https://static.righto.com/images/globus-gearing/diagram-orbit-w500.png&quot; title=&quot;A cam-based system adjusts the orbital speed using three differential gear assemblies.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A cam-based system adjusts the orbital speed using three differential gear assemblies.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The three adjustment signals are scaled by gear ratios to provide the appropriate contribution to the rotation.
As shown above, the adjustments are added to the solenoid output by three differentials to generate the orbit rotation signal, output from differential 3.&lt;span id=&quot;fnref:loop&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:loop&quot;&gt;8&lt;/a&gt;&lt;/span&gt;
This signal also drives the odometer-like orbit counter on the front of the Globus.
The diagram below shows how the components are arranged, as viewed from the back.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/diagram-back2.jpg&quot;&gt;&lt;img alt=&quot;A back view of the Globus showing the orbit components.&quot; class=&quot;hilite&quot; height=&quot;584&quot; src=&quot;https://static.righto.com/images/globus-gearing/diagram-back2-w600.jpg&quot; title=&quot;A back view of the Globus showing the orbit components.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A back view of the Globus showing the orbit components.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Displaying the orbit rotation&lt;/h2&gt;
&lt;p&gt;Since the Globus doesn&#39;t have any external position input such as inertial guidance, it must be initialized by the cosmonauts.
A knob on the front of the Globus provides manual adjustment of the orbital position.
Differential 4 adds the knob signal to the orbit output discussed above.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/diagram-orbit2.png&quot;&gt;&lt;img alt=&quot;The orbit controls drive the globe&#39;s motion.&quot; class=&quot;hilite&quot; height=&quot;334&quot; src=&quot;https://static.righto.com/images/globus-gearing/diagram-orbit2-w700.png&quot; title=&quot;The orbit controls drive the globe&#39;s motion.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The orbit controls drive the globe&#39;s motion.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The Globus has a &quot;landing point&quot; mode where the globe is rapidly rotated through a fraction of an orbit to indicate where the spacecraft would land
if the retro-rockets were fired. 
Turning the mode switch caused the globe to rotate until the landing position was under the crosshairs
and the cosmonauts could evaluate the suitability of this landing site.
This mode is implemented with a landing position motor that provides the rapid rotation. This motor also rotates the globe back to the orbital position.
The motor is driven through an electronics board with relays and a transistor, controlled by limit switches.
I discussed the electronics in a &lt;a href=&quot;https://www.righto.com/2023/03/reverse-engineering-electronics-in.html&quot;&gt;previous post&lt;/a&gt; so I won&#39;t go into more
details here.
The landing position motor feeds into the orbit signal through differential 5, producing the final orbit signal.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/landing-motor.jpg&quot;&gt;&lt;img alt=&quot;The landing position motor and its associated gearing. The motor speed is geared down and then fed through a worm gear (upper center).&quot; class=&quot;hilite&quot; height=&quot;382&quot; src=&quot;https://static.righto.com/images/globus-gearing/landing-motor-w400.jpg&quot; title=&quot;The landing position motor and its associated gearing. The motor speed is geared down and then fed through a worm gear (upper center).&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The landing position motor and its associated gearing. The motor speed is geared down and then fed through a worm gear (upper center).&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The orbit signal from differential 5 is used in several ways.
Most importantly, the orbit signal provides the end-over-end rotation of the globe to indicate the spacecraft&#39;s travel in orbit.
As discussed earlier, this is accomplished by rotating the globe&#39;s metal frame around the horizontal axis.
The orbital signal also rotates a potentiometer to provide an electrical indication of the orbital position to other spacecraft systems.&lt;/p&gt;
&lt;h2&gt;The light/shadow indicator&lt;/h2&gt;
&lt;p&gt;Docking a spacecraft is a tricky endeavor, best performed in daylight, so it is useful to know how much time remains until the spacecraft
enters the Earth&#39;s shadow. The light/shadow dial under the globe provides this information.
This display consists of two nested wheels. The outer wheel is white and has two quarters removed.
Through these gaps, the partially-black inner wheel is exposed, which can be adjusted to show 0% to 50% dark.
This display is rotated by the orbital signal, turning half a revolution per orbit.
As the spacecraft orbits, this dial shows the light/shadow transition and the time to the transistion.&lt;span id=&quot;fnref:scale&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:scale&quot;&gt;9&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/light-shadow-dials.jpg&quot;&gt;&lt;img alt=&quot;The light/shadow indicator, viewed from the underside of the Globus. The shadow indicator has been set to 35% shadow. Near the hub, a pin restricts motion of the inner wheel relative to the outer wheel.&quot; class=&quot;hilite&quot; height=&quot;348&quot; src=&quot;https://static.righto.com/images/globus-gearing/light-shadow-dials-w500.jpg&quot; title=&quot;The light/shadow indicator, viewed from the underside of the Globus. The shadow indicator has been set to 35% shadow. Near the hub, a pin restricts motion of the inner wheel relative to the outer wheel.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The light/shadow indicator, viewed from the underside of the Globus. The shadow indicator has been set to 35% shadow. Near the hub, a pin restricts motion of the inner wheel relative to the outer wheel.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;You might expect the orbit to be in the dark 50% of the time, but because the spacecraft is about 200 km above the Earth&#39;s surface,
it will sometimes be illuminated when the surface of the Earth underneath is dark.&lt;span id=&quot;fnref:iss&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:iss&quot;&gt;10&lt;/a&gt;&lt;/span&gt; In the ground track below, the dotted
part of the track is where the spacecraft is in the Earth&#39;s shadow; this is considerably less than 50%.
Also note that the end of the orbit doesn&#39;t match up with the beginning, due to the Earth&#39;s rotation during the orbit.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/orbitdisplay4.png&quot;&gt;&lt;img alt=&quot;Ground track of an Apollo-Soyuz Test Project orbit, corresponding to this Globus. Image courtesy of heavens-above.com.&quot; class=&quot;hilite&quot; height=&quot;300&quot; src=&quot;https://static.righto.com/images/globus-gearing/orbitdisplay4-w600.png&quot; title=&quot;Ground track of an Apollo-Soyuz Test Project orbit, corresponding to this Globus. Image courtesy of heavens-above.com.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Ground track of an Apollo-Soyuz Test Project orbit, corresponding to this Globus. Image courtesy of &lt;a href=&quot;https://www.heavens-above.com/orbit.aspx?satid=08032&quot;&gt;heavens-above.com&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The latitude indicator&lt;/h2&gt;
&lt;p&gt;The latitude indicator to the left of the globe shows the spacecraft&#39;s latitude. The map above shows how the latitude oscillates between
51.8&amp;deg;N and 51.8&amp;deg;S, corresponding to the launch inclination angle.
Even though the path around the globe is a straight (circular) line, the orbit appears roughly sinusoidal when projected onto the map.&lt;span id=&quot;fnref:sinusoid&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:sinusoid&quot;&gt;11&lt;/a&gt;&lt;/span&gt;
The exact latitude is a surprisingly complicated function of the orbital position.&lt;span id=&quot;fnref:formulas&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:formulas&quot;&gt;12&lt;/a&gt;&lt;/span&gt;
This function is implemented by a cam that is attached to the globe. The varying radius of the cam corresponds to the function.
A follower tracks the profile of the cam and rotates the latitude display wheel accordingly, providing the non-linear motion.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/latitude-cam.jpg&quot;&gt;&lt;img alt=&quot;A cam is attached to the globe and rotates with the globe.&quot; class=&quot;hilite&quot; height=&quot;353&quot; src=&quot;https://static.righto.com/images/globus-gearing/latitude-cam-w400.jpg&quot; title=&quot;A cam is attached to the globe and rotates with the globe.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A cam is attached to the globe and rotates with the globe.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The Earth&#39;s rotation&lt;/h2&gt;
&lt;p&gt;The second motion of the globe is the Earth&#39;s daily rotation around its axis, which I&#39;ll call the Earth rotation.
The Earth rotation is fed into the globe through the outer part of a concentric shaft, while the orbital rotation is provided through the
inner shaft.
The Earth rotation is transferred through three gears to the equatorial frame, where an internal mechanism rotates the hemispheres.
There&#39;s a complication, though:
if the globe&#39;s orbital shaft turns while the Earth rotation shaft remains stationary, the frame will rotate, causing the
gears to turn and the hemispheres to rotate.
In other words, keeping the hemispheres stationary requires the Earth shaft to rotate with the orbit shaft.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/globe-closeup.jpg&quot;&gt;&lt;img alt=&quot;A closeup of the gear mechanisms that drive the Globus, showing the concentric shafts that control the two rotations.&quot; class=&quot;hilite&quot; height=&quot;464&quot; src=&quot;https://static.righto.com/images/globus-gearing/globe-closeup-w400.jpg&quot; title=&quot;A closeup of the gear mechanisms that drive the Globus, showing the concentric shafts that control the two rotations.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A closeup of the gear mechanisms that drive the Globus, showing the concentric shafts that control the two rotations.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The Globus solves this problem by adding the orbit rotation to the Earth rotation, as shown in the diagram below, using differentials 7 and 8.
Differential 8 adds the normal orbit rotation, while differential 7 adds the orbit rotation due to the landing motor.&lt;span id=&quot;fnref:landing&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:landing&quot;&gt;14&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/diagram-earth.png&quot;&gt;&lt;img alt=&quot;The mechanism to compute the Earth&#39;s rotation around its axis.&quot; class=&quot;hilite&quot; height=&quot;391&quot; src=&quot;https://static.righto.com/images/globus-gearing/diagram-earth-w350.png&quot; title=&quot;The mechanism to compute the Earth&#39;s rotation around its axis.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The mechanism to compute the Earth&#39;s rotation around its axis.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The Earth motion is generated by
a second solenoid (below) that is driven with one pulse per second.&lt;span id=&quot;fnref:solenoid&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:solenoid&quot;&gt;13&lt;/a&gt;&lt;/span&gt;
This motion is simpler than the orbit motion because it has a fixed rate.
The &quot;Earth&quot; knob on the front of the Globus permits manual rotation around the Earth&#39;s axis. This signal is combined with the solenoid signal by differential 6.
The sum from the three differentials is fed into the globe, rotating the hemispheres around their axis.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/earth-solenoid.jpg&quot;&gt;&lt;img alt=&quot;This solenoid, ratchet, and gear on the underside of the Globus drive the Earth rotation.&quot; class=&quot;hilite&quot; height=&quot;286&quot; src=&quot;https://static.righto.com/images/globus-gearing/earth-solenoid-w350.jpg&quot; title=&quot;This solenoid, ratchet, and gear on the underside of the Globus drive the Earth rotation.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This solenoid, ratchet, and gear on the underside of the Globus drive the Earth rotation.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The solenoid and differentials are visible from the underside of the Globus. The diagram below labels these components as well as
other important components.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/diagram-underside.jpg&quot;&gt;&lt;img alt=&quot;The underside of the Globus.&quot; class=&quot;hilite&quot; height=&quot;665&quot; src=&quot;https://static.righto.com/images/globus-gearing/diagram-underside-w700.jpg&quot; title=&quot;The underside of the Globus.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The underside of the Globus.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The longitude display&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/longitude-cam.jpg&quot;&gt;&lt;img alt=&quot;The longitude cam and the followers that track its radius.&quot; class=&quot;hilite&quot; height=&quot;383&quot; src=&quot;https://static.righto.com/images/globus-gearing/longitude-cam-w350.jpg&quot; title=&quot;The longitude cam and the followers that track its radius.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The longitude cam and the followers that track its radius.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The longitude display is more complicated than the latitude display because it depends on both the Earth rotation and the orbit rotation.
Unlike the latitude, the longitude doesn&#39;t oscillate but increases.
The longitude increases by 360&amp;deg; every orbit according to a complicated formula describing the projection of the orbit onto the globe.
Most of the time, the increase is small, but when crossing near the poles, the longitude changes rapidly.
The Earth&#39;s rotation provides a smaller but steady negative change to the longitude.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/diagram-earth2.png&quot;&gt;&lt;img alt=&quot;The computation of the longitude.&quot; class=&quot;hilite&quot; height=&quot;245&quot; src=&quot;https://static.righto.com/images/globus-gearing/diagram-earth2-w220.png&quot; title=&quot;The computation of the longitude.&quot; width=&quot;220&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The computation of the longitude.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The diagram above shows how the longitude is computed by combining the Earth rotation with the orbit rotation.
Differential 9 adds the linear effect of the orbit on longitude (360&amp;deg; per orbit) and subtracts the effect of the Earth&#39;s rotation (360&amp;deg; per day).
The nonlinear effect of the orbit is computed by a cam that is rotated by the orbit signal. The shape of the cam is picked up and fed into differential 10,
computing the longitude that is displayed on the dial. The differentials, cam, and dial are visible from the back of the Globus (below).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/diagram-back.jpg&quot;&gt;&lt;img alt=&quot;A closeup of the differentials from the back of the Globus.&quot; class=&quot;hilite&quot; height=&quot;621&quot; src=&quot;https://static.righto.com/images/globus-gearing/diagram-back-w450.jpg&quot; title=&quot;A closeup of the differentials from the back of the Globus.&quot; width=&quot;450&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A closeup of the differentials from the back of the Globus.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The time-lapse video below demonstrates the behavior of the rotating displays.
The latitude display on the left oscillates between 51.8&amp;deg;N and 51.8&amp;deg;S.
The longitude display at the top advances at a changing rate. Near the equator, it advances slowly, while it accelerates near the poles.
The light/shadow display at the bottom rotates at a constant speed, completing half a revolution (one light/shadow cycle) per orbit.&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/nDHtJy9cpC0&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The Globus INK is a remarkable piece of machinery, an analog computer that calculates orbits through an intricate
system of gears, cams, and differentials.
It provided astronauts with a high-resolution, full-color display of the spacecraft&#39;s position, way beyond what
an electronic space computer could provide in the 1960s.&lt;/p&gt;
&lt;p&gt;The drawback of the Globus is that its functionality is limited.
Its parameters must be manually configured: the spacecraft&#39;s starting position, the orbital speed, the light/shadow regions, and the landing angle.
It doesn&#39;t take any external guidance inputs, such as an IMU (inertial measurement unit), so it&#39;s not particularly accurate.
Finally, it only supports a circular orbit at a fixed angle.
While a more modern digital display lacks the physical charm of a rotating globe, the digital solution provides
much more capability.&lt;/p&gt;
&lt;p&gt;I recently wrote blog posts providing a &lt;a href=&quot;https://www.righto.com/2023/01/inside-globus-ink-mechanical-navigation.html&quot;&gt;Globus overview&lt;/a&gt;
and &lt;a href=&quot;https://www.righto.com/2023/03/reverse-engineering-electronics-in.html&quot;&gt;the Globus electronics&lt;/a&gt;.
Follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@kenshirriff@oldbytes.space&lt;/a&gt;.
Many thanks to Marcel for providing the Globus.
I worked on this with CuriousMarc, so check out his &lt;a href=&quot;https://www.youtube.com/@CuriousMarc/videos&quot;&gt;Globus videos&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:ink&quot;&gt;
&lt;p&gt;In Russian, the name for the device is &quot;  &quot; abbreviated as  (INK). This translates to &quot;space navigation indicator.&quot;
but I&#39;ll use the more descriptive nickname &quot;Globus&quot; (i.e. globe).
The Globus has a long history, back to the beginnings of Soviet crewed spaceflight. The first version was simpler and had the Russian acronym  (IMP).
Development of the IMP started in &lt;a href=&quot;https://web.mit.edu/slava/space/essays/essay-tiapchenko1.htm&quot;&gt;1960&lt;/a&gt; for the Vostok (1961)
and Voshod (1964) spaceflights.
The more complex INK model (described in this blog post) was created for the Soyuz flights, starting in 1967.
The landing position feature is the main improvement of the INK model.
The Soyuz-TMA (2002) upgraded to the Neptun-ME system which used digital display screens and abandoned the Globus.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:ink&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:day&quot;&gt;
&lt;p&gt;According to &lt;a href=&quot;https://astronaut.ru/bookcase/article/article152.htm?reload_coolmenus&quot;&gt;this document&lt;/a&gt;,
one revolution of the globe relative to the axis of daily rotation occurs in a time equal to a sidereal day,
taking into account the precession of the orbit relative to the earth&#39;s axis, caused by the asymmetry of the Earth&#39;s gravitational field.
(A sidereal day is approximately 4 minutes shorter than a regular 24-hour day. The difference is that the sidereal day is
relative to the fixed stars, rather than relative to the Sun.)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:day&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:orbit&quot;&gt;
&lt;p&gt;To see how the angle between the poles and the globe&#39;s rotation results in the desired orbital inclination, consider two limit cases.
First, suppose the angle between is 90&amp;deg;. In this case, the globe is &quot;straight&quot; with the equator horizontal.
Rotating the globe along the horizontal axis, flipping the poles end-over-end, will cause the crosshair to
trace a polar orbit, giving the expected inclination of 90&amp;deg;.
On the other hand, suppose the angle is 0&amp;deg;. In this case, the globe is &quot;sideways&quot; with the equator vertical.
Rotating the globe will cause the crosshair to remain over the equator, corresponding to an equatorial orbit
with 0&amp;deg; inclination.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:orbit&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:directions&quot;&gt;
&lt;p&gt;There is a bit of ambiguity when describing the gear motions.
If the end gears are rotating upwards when viewed from the front, the gears are both rotating clockwise when viewed from the right, so
I&#39;m referring to them as rotating in the same direction.
But if you view each gear from its own side, the gear on the left is turning counterclockwise, so from that perspective they are turning
in opposite directions.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:directions&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:torque&quot;&gt;
&lt;p&gt;The solenoids are important since they provide all the energy to drive the globe.
One of the problems with gear-driven analog computers is that each gear and shaft has a bit of friction and loses a bit of torque,
and there is nothing to amplify the signal along the way.
Thus, the 27-volt solenoids need to provide enough force to run the entire system.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:torque&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:time&quot;&gt;
&lt;p&gt;The orbital time can be adjusted between 86.85 minutes and 96.85 minutes according to &lt;a href=&quot;https://astronaut.ru/bookcase/article/article152.htm?reload_coolmenus&quot;&gt;this detailed page&lt;/a&gt; that describes the Globus in Russian.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:time&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:parameters&quot;&gt;
&lt;p&gt;The Globus is manufactured for a particular orbital inclination, in this case 51.8&amp;deg;. The Globus assumes a circular orbit and does not account
for any variations.
The Globus does not account for any maneuvering in orbit.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:parameters&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:loop&quot;&gt;
&lt;p&gt;The outputs from the orbit cam are fed into the overall orbit rotation, which drives the orbit cam.
This may seem like an &quot;infinite loop&quot; since the outputs from the cam turn the cam itself.
However, the outputs from the cam are a small part of the overall orbit rotation, so the feedback dies off.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:loop&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:scale&quot;&gt;
&lt;p&gt;The scales on the light/shadow display are a bit confusing. The inner scale (blue) is measured in percentage of an orbit, up to 100%.
The fixed outer scale (red) measures minutes, indicating how many minutes until the spacecraft enters or leaves shadow.
The spacecraft completes 100% of an orbit in about 90 minutes, so the scales almost, but not quite, line up.
The wheel is driven by the orbit mechanism and turns half a revolution per orbit.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-gearing/light-dark.jpg&quot;&gt;&lt;img alt=&quot;The light and shadow indicator is controlled by two knobs.&quot; class=&quot;hilite&quot; height=&quot;175&quot; src=&quot;https://static.righto.com/images/globus-gearing/light-dark-w500.jpg&quot; title=&quot;The light and shadow indicator is controlled by two knobs.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The light and shadow indicator is controlled by two knobs.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- --&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:scale&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:iss&quot;&gt;
&lt;p&gt;The Internation Space Station illustrates how an orbiting spacecraft is illuminated more than 50% of the time due to its height.
You can often see the ISS illuminated in the nighttime sky close to sunset and sunrise
(&lt;a href=&quot;https://spotthestation.nasa.gov/&quot;&gt;link&lt;/a&gt;).&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:iss&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:sinusoid&quot;&gt;
&lt;p&gt;The ground track on the map is roughly, but not exactly, sinusoidal.
As the orbit swings further from the equator, the track deviates more from a pure sinusoid.
The shape will depend, of course, on the rectangular map projection.
For more information, see &lt;a href=&quot;https://math.stackexchange.com/questions/1843444/how-do-great-circles-project-on-the-mercator-projection&quot;&gt;this StackExcahnge post&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:sinusoid&quot; title=&quot;Jump back to footnote 11 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:formulas&quot;&gt;
&lt;p&gt;To get an idea of how the latitude and longitude behave,
consider a polar orbit with 90&amp;deg; angle of inclination, one that goes up a line of longitude, crosses the North Pole,
and goes down the opposite line of latitude.
Now, shift the orbit away from the poles a bit, but keeping a great circle.
The spacecraft will go up, nearly along a constant line of longitude, with the latitude increasing steadily. As the spacecraft reaches the peak of its orbit
near the North Pole, it will fall a bit short of the Pole but will still rapidly cross over to the other side.
During this phase, the spacecraft rapidly crosses many lines of longitude (which are close together near the Pole) until it reaches the opposite
line of longitude.
Meanwhile, the latitude stops increasing short of 90&amp;deg; and then starts dropping.
On the other side, the process repeats, with the longitude nearly constant while the latitude drops relatively constantly.&lt;/p&gt;
&lt;p&gt;The latitude and longitude are generated by complicated trigonometric functions.
The latitude is given by arcsin(sin i * sin (2t/T)), while the longitude is given by  = arctan (cos i * tan(2t/T)) + t + &lt;sub&gt;0&lt;/sub&gt;,
where t is the spaceship&#39;s flight time starting at the equator, i is the angle of inclination (51.8),
T is the orbital period,  is the angular velocity of the Earth&#39;s rotation, and &lt;sub&gt;0&lt;/sub&gt; is the longitude of the ascending node.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:formulas&quot; title=&quot;Jump back to footnote 12 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:solenoid&quot;&gt;
&lt;p&gt;An important function of the gears is to scale the rotations as needed by using different gear ratios.
For the most part, I&#39;m ignoring the gear ratios, but the Earth rotation gearing is interesting.
The gear driven by the solenoid has 60 teeth, so it rotates exactly once per minute.
This gear drives a shaft with a very small gear on the other end with 15 teeth. This gear meshes with a much larger gear with approximately 75 teeth,
which will thus rotate once every 5 minutes. The other end of that shaft has a gear with approximately 15 teeth, meshed with a large gear
with approximately 90 teeth. This divides the rate by 6, yielding a rotation every 30 minutes.
The sequence of gears and shafts continues, until the rotation is reduced to once per day.
(The tooth counts are approximate because the gears are partially obstructed inside the Globus, making counting difficult.)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:solenoid&quot; title=&quot;Jump back to footnote 13 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:landing&quot;&gt;
&lt;p&gt;There&#39;s a potential simplification when canceling out the orbital shaft rotation from the Earth rotation.
If the orbit motion was taken from differential 5 instead of differential 4, the landing motor effect would get added automatically,
eliminating the need for differential 7.
I think the landing motor motion was added separately so the mechanism could account for the Earth&#39;s rotation during the landing descent.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:landing&quot; title=&quot;Jump back to footnote 14 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/8868607841305902549/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=8868607841305902549' title='2 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/8868607841305902549'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/8868607841305902549'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/03/reverse-engineering-globus-ink-soviet.html' title='Reverse-engineering the Globus INK, a Soviet spaceflight navigation computer'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://img.youtube.com/vi/nDHtJy9cpC0/default.jpg" height="72" width="72"/><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-8390323699966089555</id><published>2023-03-15T08:53:00.009-07:00</published><updated>2023-04-04T17:56:20.651-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="chips"/><category scheme="http://www.blogger.com/atom/ns#" term="microcode"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>Reverse-engineering the multiplication algorithm in the Intel 8086 processor</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;
&lt;style&gt;
  pre.microcode {font-family: courier, fixed; padding: 10px; background-color: #f5f5f5; display:inline-block;border:none;}
  pre.microcode span {color: green; font-style:italic; font-family: sans-serif; font-size: 90%;}
&lt;/style&gt;

&lt;p&gt;While programmers today take multiplication for granted, most microprocessors in the 1970s could only add and subtract &amp;mdash; multiplication required a slow and tedious loop implemented in assembly code.&lt;span id=&quot;fnref:mul&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:mul&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
One of the nice features of the Intel 8086 processor (1978) was
that it provided machine instructions for multiplication,&lt;span id=&quot;fnref:division&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:division&quot;&gt;2&lt;/a&gt;&lt;/span&gt; able to multiply 8-bit or 16-bit numbers with a single instruction.
Internally, the 8086 still performed a loop, but the loop was implemented in microcode: faster and transparent to
the programmer.
Even so, multiplication was a slow operation, about 24 to 30 times slower than addition.&lt;/p&gt;
&lt;p&gt;In this blog post, I explain the multiplication process inside the 8086, analyze the microcode that it used, and discuss the hardware
circuitry that helped it out.&lt;span id=&quot;fnref:microcode&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:microcode&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
My analysis is based on reverse-engineering the 8086 from die photos. The die photo below shows the chip under a microscope.
I&#39;ve labeled the key functional blocks; the ones that are important to this post are darker.
At the left, the ALU (Arithmetic/Logic Unit) performs the arithmetic operations at the heart of multiplication: addition and shifts.
Multiplication also uses a few other hardware features: the X register, the F1 flag, and a loop counter.
The microcode ROM at the lower right controls the process.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-mul/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;592&quot; src=&quot;https://static.righto.com/images/8086-mul/die-labeled-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Microcode&lt;/h2&gt;
&lt;p&gt;The multiplication routines in the 8086 are implemented in microcode.
Most people think of machine instructions as the basic steps that a computer performs.
However, many processors (including the 8086) have another layer of software underneath: microcode.
With microcode, instead of building the control circuitry from complex logic gates, the control logic is largely replaced with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.
This is especially useful for a machine instruction such as multiplication, which requires many steps in a loop.&lt;/p&gt;
&lt;!--
The 8086 uses a hybrid approach: although it uses microcode, much of the instruction functionality is implemented with gate logic.
This approach removed duplication from the microcode and kept the microcode small enough for 1978 technology.
In a sense, the microcode is parameterized.
For instance, the microcode can specify a generic Arithmetic/Logic Unit (ALU) operation and a generic register.
The gate logic examines the instruction to determine which specific operation to perform and the appropriate register.
--&gt;

&lt;p&gt;A micro-instruction in the 8086 is encoded into 21 bits as shown below.
Every micro-instruction has a move from a source register to a destination register, each specified with 5 bits.
The meaning of the remaining bits depends on the type field and can be anything from an ALU operation to a memory read or write to
a change of microcode control flow.
Thus, an 8086 micro-instruction typically does two things in parallel: the move and the action.
For more about 8086 microcode, see my &lt;a href=&quot;https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html&quot;&gt;microcode blog post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-mul/microcode-format.jpg&quot;&gt;&lt;img alt=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; class=&quot;hilite&quot; height=&quot;203&quot; src=&quot;https://static.righto.com/images/8086-mul/microcode-format-w700.jpg&quot; title=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The encoding of a micro-instruction into 21 bits. Based on &lt;a href=&quot;https://digitalcommons.law.scu.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=1031&amp;context=chtlj&quot;&gt;NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The behavior of an ALU micro-operation is important for multiplication.
The ALU has three temporary registers that are invisible to the programmer: tmpA, tmpB, and tmpC.
An ALU operation takes its first argument from any temporary register, while the second argument always comes from tmpB.
An ALU operation requires two micro-instructions.
The first micro-instruction specifies the ALU operation and source register, configuring the ALU. For instance, &lt;code&gt;ADD tmpA&lt;/code&gt; to add tmpA to the default tmpB.
In the next micro-instruction (or a later one), the ALU result can be accessed through the &lt;code&gt;&lt;/code&gt; register and moved to another register.&lt;/p&gt;
&lt;p&gt;Before I get into the microcode routines, I should explain two ALU operations that play a central role in multiplication: &lt;code&gt;LRCY&lt;/code&gt; and &lt;code&gt;RRCY&lt;/code&gt;, Left Rotate through Carry and Right Rotate through Carry.
(These correspond to the &lt;code&gt;RCL&lt;/code&gt; and &lt;code&gt;RCR&lt;/code&gt; machine instructions, which rotate through carry left or right.)
These operations shift the bits in a 16-bit word, similar to the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; bit-shift operations in high-level languages, but with an additional feature.
Instead of discarding the bit on the end, that bit is moved into the carry flag (&lt;code&gt;CF&lt;/code&gt;). Meanwhile, the bit formerly in the carry flag moves into the word.
You can think of this as rotating the bits while treating the carry flag as a 17th bit of the word.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-mul/rotates.jpg&quot;&gt;&lt;img alt=&quot;The left rotate through carry and right rotate through carry micro-instructions.&quot; class=&quot;hilite&quot; height=&quot;172&quot; src=&quot;https://static.righto.com/images/8086-mul/rotates-w300.jpg&quot; title=&quot;The left rotate through carry and right rotate through carry micro-instructions.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The left rotate through carry and right rotate through carry micro-instructions.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;These shifts perform an important part of the multiplication process since shifting can be viewed as multiplying by two.
&lt;code&gt;LRCY&lt;/code&gt; also provides a convenient way to move the most-significant bit to the carry flag, where it can be tested for a conditional jump.
(This is important because the top bit is used as the sign bit.)
Similarly, &lt;code&gt;RRCY&lt;/code&gt; provides access to the least significant bit, very important for the multiplication process.
Another important property is that performing &lt;code&gt;RRCY&lt;/code&gt; on an upper word and then &lt;code&gt;RRCY&lt;/code&gt; on a lower word will perform a 32-bit shift, since
the low bit of the upper word will be moved into the high bit of the lower word via the carry bit.&lt;/p&gt;
&lt;h2&gt;Binary multiplication&lt;/h2&gt;
&lt;p&gt;The shift-and-add method of multiplication (below) is similar to grade-school long multiplication, except it uses binary instead of decimal.
In each row, the multiplicand is multiplied by one digit of the multiplier. (The multiplicand is the value that gets repeatedly added, and the multiplier
controls how many times it gets added.)
Successive rows are shifted left one digit.
At the bottom, the rows are added together to yield the product.
The example below shows how 6&amp;times;5 is calculated in binary using long multiplication.&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
div.mul {font-family: &quot;courier-new&quot;, courier, monospace}
div.mul .top {border-bottom: 1px solid #ccc;}
div.mul .sum {border-top: 1px solid #ccc;}
div.mul .dim {color: #aaa;}
&lt;/style&gt;

&lt;div class=&quot;mul&quot;&gt;
&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0110&lt;/span&gt;
&lt;br/&gt;&lt;span class=&quot;top&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;times;0101&lt;/span&gt;
&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0110&lt;/span&gt;
&lt;br/&gt;&lt;span class=&quot;dim&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;0000&lt;/span&gt;
&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;0110&lt;/span&gt;
&lt;br/&gt;&lt;span class=&quot;dim&quot;&gt;&amp;nbsp;0000&lt;/span&gt;
&lt;br/&gt;&lt;span class=&quot;sum&quot;&gt;00011110&lt;/span&gt;
&lt;/div&gt;

&lt;p&gt;Binary long multiplication is much simpler than decimal multiplication: at each step, you&#39;re multiplying by 0 or 1.
Thus, each row is either zero or the multiplicand appropriately shifted (0110 in this case).
(Unlike decimal long multiplication, you don&#39;t need to know the multiplication table.)
This simplifies the hardware implementation, since each step either adds the multiplicand or doesn&#39;t.
In other words, each step tests a bit of the multiplier, starting with the low bit, to determine if an add should take place or not.
This bit can be obtained by shifting the multiplier one bit to the right each step.&lt;/p&gt;
&lt;p&gt;Although the diagram above shows the sum at the end, a real implementation performs the addition at each step of the loop, keeping a running total.
Moreover, in the 8086, instead of shifting the multiplicand to the left during each step, the sum shifts to the right.
(The result is the same but it makes the implementation easier.)
Thus, multiplying 6&amp;times;5 goes through the steps below.&lt;/p&gt;
&lt;div class=&quot;mul&quot;&gt;
&lt;span&gt;&amp;nbsp;&amp;nbsp;0101&lt;/span&gt;
&lt;br/&gt;&lt;span class=&quot;top&quot;&gt;&amp;nbsp;&amp;times;0110&lt;/span&gt;
&lt;br/&gt;&lt;span&gt;&amp;nbsp;00000&lt;/span&gt;
&lt;br/&gt;&lt;span&gt;&amp;nbsp;001010&lt;/span&gt;
&lt;br/&gt;&lt;span&gt;&amp;nbsp;0011110&lt;/span&gt;
&lt;br/&gt;&lt;span&gt;&amp;nbsp;00011110&lt;/span&gt;
&lt;/div&gt;

&lt;p&gt;Why would you shift the result to the right?
There&#39;s a clever reason for this.
Suppose you&#39;re multiplying two 16-bit numbers, which yields a 32-bit result. That requires four 16-bit words of storage if you use the
straightforward approach.
But if you look more closely, the first sum fits into 16 bits, and then you need one more bit at each step. Meanwhile, you&#39;re &quot;using up&quot;
one bit of the multiplier at each step.
So if you squeeze the sum and the multiplier together, you can fit them into two words.
Shifting right accomplishes this, as the diagram below illustrates for &lt;code&gt;0xffff&lt;/code&gt;&amp;times;&lt;code&gt;0xf00f&lt;/code&gt;. The sum (blue) starts in a 16-bit register called &lt;code&gt;tmpA&lt;/code&gt;
while the multiplier (green) is stored in the 16-bit &lt;code&gt;tmpB&lt;/code&gt; register.
In each step, they are both shifted right, so the sum gains one bit and the multiplier loses one bit. By the end, the sum takes up all 32 bits,
split across both registers.&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
table.mul {border-collapse: collapse; border: 1px solid #888; font-family: &quot;courier-new&quot;, courier, monospace; padding: 2px; font-size:90%;}
table.mul th {border-bottom: 1px solid #444;}
table.mul th:nth-child(1) {border-left: 1px solid #444; border-right: 2px solid #444;}
table.mul th:nth-child(3) {border-left: 1px solid #444;}
table.mul th:nth-child(4) {padding: 0 4px;}
table.mul tr:nth-child(2) {border-bottom: 1px solid #444;}
table.mul tr:nth-child(2) {border-bottom: 1px solid #444;}
table.mul td:nth-child(8) {border-right: 1px solid #444;}
table.mul td:nth-child(16) {border-right: 2px solid #444;}
table.mul td:nth-child(24) {border-right: 1px solid #444;}
table.mul td {padding: 0px 4px;}
table.mul td.a {background-color: #ddf;}
table.mul td.b {background-color: #cfc;}
&lt;/style&gt;

&lt;table class=&quot;mul&quot;&gt;
&lt;tr style=&quot;font-family: sans-serif; color: blue&quot;&gt;&lt;th colspan=16&gt;sum (tmpA)&lt;/th&gt;&lt;th colspan=16 style=&quot;font-family:sans-serif; color: green&quot;&gt;multiplier (tmpC)&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;The multiplication microcode&lt;/h2&gt;
&lt;p&gt;The 8086 has four multiply instructions to handle signed and unsigned multiplication of byte and word operands.
These machine instructions are implemented in microcode.
I&#39;ll start by describing the unsigned word multiplication, which multiplies two 16-bit values and produces a 32-bit result.
The source word is provided by either a register or memory. It is multiplied by &lt;code&gt;AX&lt;/code&gt;, the accumulator register.
The 32-bit result is returned in the &lt;code&gt;DX&lt;/code&gt; and &lt;code&gt;AX&lt;/code&gt; registers.&lt;/p&gt;
&lt;p&gt;The microcode below is the main routine for word multiplication, both signed and unsigned.
Each micro-instruction specifies a register move on the left, and an action on the right.
The moves transfer words between the visible registers and the ALU&#39;s temporary registers, while the actions are mostly subroutine calls
to other micro-routines.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
  move        action
AX  tmpC   LRCY tmpC        &lt;span&gt;&lt;b&gt;iMUL rmw:&lt;/b&gt;&lt;/span&gt;
M  tmpB    CALL X0 PREIMUL   &lt;span&gt;called for signed multiplication&lt;/span&gt;
            CALL CORX         &lt;span&gt;the core routine&lt;/span&gt;
            CALL F1 NEGATE    &lt;span&gt;called for negative result&lt;/span&gt;
            CALL X0 IMULCOF   &lt;span&gt;called for signed multiplication&lt;/span&gt;
tmpC  AX   JMPS X0 7  
            CALL MULCOF       &lt;span&gt;called for unsigned multiplication&lt;/span&gt;
tmpA  DX   RNI  
&lt;/pre&gt;

&lt;p&gt;The microcode starts by moving one argument &lt;code&gt;AX&lt;/code&gt; into the ALU&#39;s temporary C register and setting up the ALU to perform a Left Rotate through Carry on this register, in order to access the sign bit.
Next, it moves the second argument &lt;code&gt;M&lt;/code&gt; into the temporary B register; &lt;code&gt;M&lt;/code&gt; references the register or memory specified in the second byte
of the instruction, the &quot;ModR/M&quot; byte.
For a signed multiply instruction, the &lt;code&gt;PREIMUL&lt;/code&gt; micro-subroutine is called, but I&#39;ll skip that for now.
(The &lt;code&gt;X0&lt;/code&gt; condition tests bit 3 of the instruction, which in this case distinguishes &lt;code&gt;MUL&lt;/code&gt; from &lt;code&gt;IMUL&lt;/code&gt;.)
Next, the &lt;code&gt;CORX&lt;/code&gt; subroutine is called, which is the heart of the multiplication.&lt;span id=&quot;fnref:corx&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:corx&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
If the result needs to be negated (indicated by the &lt;code&gt;F1&lt;/code&gt; condition), the &lt;code&gt;NEGATE&lt;/code&gt; micro-subroutine is called.
For signed multiplication, &lt;code&gt;IMULCOF&lt;/code&gt; is then called to set the carry and overflow flags, while &lt;code&gt;MULCOF&lt;/code&gt; is called for unsigned multiplication.
Meanwhile, the result bytes are moved from the temporary C and temporary registers to the &lt;code&gt;AX&lt;/code&gt; and &lt;code&gt;DX&lt;/code&gt; registers.
Finally, &lt;code&gt;RNI&lt;/code&gt; runs the next machine instruction, ending the microcode routine.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;CORX&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The heart of the multiplication code is the &lt;code&gt;CORX&lt;/code&gt; routine, which performs the multiplication loop, computing the product through shifts and adds.
The first two lines set up the loop, initializing the sum (tmpA) to 0.
The number of loops is controlled by a special-purpose loop counter.
The &lt;code&gt;MAXC&lt;/code&gt; micro-instruction initializes the counter to 7 or 15, for a byte or word multiply respectively.
The first shift of tmpC is performed, putting the low bit into the carry flag.&lt;/p&gt;
&lt;p&gt;The loop body performs the shift-and-add step.
It tests the carry flag, the low bit of the multiplicand. It skips over the &lt;code&gt;ADD&lt;/code&gt; if there is no carry (&lt;code&gt;NCY&lt;/code&gt;).
Otherwise, tmpB is added to tmpA. (As tmpA gets shifted to the right, tmpB gets added to higher and higher positions in the result.)
The tmpA and tmpC registers are rotated right. This also puts the next bit of the multiplicand into the carry flag for the next cycle.
The microcode jumps to the top of the loop if the counter is not zero (&lt;code&gt;NCZ&lt;/code&gt;). Otherwise, the subroutine returns with the result in tmpA and tmpC.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
ZERO  tmpA  RRCY tmpC   &lt;span&gt;&lt;b&gt;CORX:&lt;/b&gt; initialize right rotate&lt;/span&gt;
  tmpC     MAXC         &lt;span&gt; get rotate result, initialize counter to max value&lt;/span&gt;
             JMPS NCY 8  &lt;span&gt;&lt;b&gt;5:&lt;/b&gt; top of loop&lt;/span&gt;
             ADD tmpA     &lt;span&gt;conditionally add&lt;/span&gt;
  tmpA               F  &lt;span&gt;sum to tmpA, update flags to get carry&lt;/span&gt;
             RRCY tmpA   &lt;span&gt;&lt;b&gt;8:&lt;/b&gt; 32-bit shift of tmpA/tmpC&lt;/span&gt;
  tmpA     RRCY tmpC  
  tmpC     JMPS NCZ 5   &lt;span&gt;loop to 5 if counter is not 0&lt;/span&gt;
             RTN  
&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;MULCOF&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The last subroutine is &lt;code&gt;MULCOF&lt;/code&gt;, which configures the carry and overflow flags.
The 8086 uses the rule that if the upper half of the result is nonzero, the carry and overflow flags are set, otherwise they are cleared.
The first two lines pass tmpA (the upper half of the result) through the ALU to set the
zero flag for the conditional jump. As a side-effect, the other status flags will get set but these values are &quot;undefined&quot; in the documentation.&lt;span id=&quot;fnref:flags&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:flags&quot;&gt;6&lt;/a&gt;&lt;/span&gt;
If the test is nonzero, the carry and overflow flags are set (&lt;code&gt;SCOF&lt;/code&gt;), otherwise they are cleared (&lt;code&gt;CCOF&lt;/code&gt;).&lt;span id=&quot;fnref:overflow&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:overflow&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
The &lt;code&gt;SCOF&lt;/code&gt; and &lt;code&gt;CCOF&lt;/code&gt; micro-operations were implemented solely for used by multiplication, illustrating how microcode can be designed around
specific needs.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
             PASS tmpA  &lt;span&gt;&lt;b&gt;MULCOF:&lt;/b&gt; pass tmpA through to test if zero&lt;/span&gt;
  no dest  JMPS 12   F &lt;span&gt;update flags&lt;/span&gt;

             JMPS Z 8   &lt;span&gt;&lt;b&gt;12:&lt;/b&gt; jump if zero&lt;/span&gt;
             SCOF RTN    &lt;span&gt;otherwise set carry and overflow&lt;/span&gt;

             CCOF RTN   &lt;span&gt;&lt;b&gt;8:&lt;/b&gt; clear carry and overflow&lt;/span&gt;
&lt;/pre&gt;

&lt;h2&gt;8-bit multiplication&lt;/h2&gt;
&lt;p&gt;The 8086 has separate instructions for 8-bit multiplication.
The process for 8-bit multiplication is similar to 16-bit multiplication, except the values are half as long and the shift-and-add loop executes 8 times instead of 16.
As shown below, the 8-bit sum starts in the low half of the temporary A register and is shifted left into tmpC.
Meanwhile, the 8-bit multiplier starts in the low half of tmpC and is shifted out to the right.
At the end, the result is split between tmpA and tmpC.&lt;/p&gt;
&lt;table class=&quot;mul&quot;&gt;
&lt;tr style=&quot;font-family: sans-serif; color: blue&quot;&gt;&lt;th colspan=16&gt;sum (tmpA)&lt;/th&gt;&lt;th colspan=16 style=&quot;font-family:sans-serif; color: green&quot;&gt;multiplier (tmpC)&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;The 8086 supports many instructions with byte and word versions, using 8-bit or 16-bit arguments.
In most cases, the byte and word instructions use the same microcode, with the ALU and register hardware using bytes or words based on the instruction.
However, the byte- and word-multiply instructions use different registers, requiring microcode changes.
In particular, the multiplier is in &lt;code&gt;AL&lt;/code&gt;, the low half of the accumulator.
At the end, the 16-bit result is returned in &lt;code&gt;AX&lt;/code&gt;, the full 16-bit accumulator; two micro-instructions assemble the result from tmpC and tmpA into
the two bytes of the accumulator, &#39;AL&#39; and &#39;AH&#39; respectively.
Apart from those changes, the microcode is the same as the word multiply microcode discussed earlier.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
AL  tmpC    LRCY tmpC         &lt;span&gt;&lt;b&gt;iMUL rmb:&lt;/b&gt;&lt;/span&gt;
M  tmpB     CALL X0 PREIMUL  
             CALL CORX  
             CALL F1 NEGATE  
             CALL X0 IMULCOF  
tmpC  AL    JMPS X0 7  
             CALL MULCOF  
tmpA  AH    RNI
&lt;/pre&gt;

&lt;h2&gt;Signed multiplication&lt;/h2&gt;
&lt;p&gt;The 8086 (like most computers) represents signed numbers using a format called two&#39;s complement.
While a regular byte holds a number from 0 to 255, a signed byte holds a number from -128 to 127.
A negative number is formed by flipping all the bits (known as the one&#39;s complement) and then adding 1, yielding the two&#39;s complement value.&lt;span id=&quot;fnref:complement&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:complement&quot;&gt;7&lt;/a&gt;&lt;/span&gt;
For instance, +5 is &lt;code&gt;0x05&lt;/code&gt; while -5 is &lt;code&gt;0xfb&lt;/code&gt;.
(Note that the top bit of a number is set for a negative number; this is the sign bit.)
The nice thing about two&#39;s complement numbers is that the same addition and subtraction operations work on both signed and unsigned values.
Unfortunately, this is not the case for signed multiplication, since signed and unsigned values yield different results due to sign extension.&lt;/p&gt;
&lt;p&gt;The 8086 has separate multiplication instructions &lt;code&gt;IMUL&lt;/code&gt; (Integer Multiply) to perform signed multiplication.
The 8086 performs signed multiplication by converting the arguments to positive values, performing unsigned multiplication, and then
negating the result if necessary.
As shown above, signed and unsigned multiplication both use the same microcode, but the microcode conditionally calls some subroutines for
signed multiplication.
I will discuss those micro-subroutines below.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;PREIMUL&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The first subroutine for signed multiplication is &lt;code&gt;PREIMUL&lt;/code&gt;, performing preliminary operations for integer multiplication.
It converts the two arguments, stored in tmpC and tmpB, to positive values.
It keeps track of the signs using an internal flag called &lt;code&gt;F1&lt;/code&gt;, toggling this flag for a negative argument.
This conveniently handles the rule that two negatives make a positive since complementing the &lt;code&gt;F1&lt;/code&gt; flag twice will clear it.&lt;/p&gt;
&lt;p&gt;This microcode, below, illustrates the complexity of microcode and how micro-operations are carefully arranged to get the right values at the right time.
The first micro-instruction performs one ALU operation and sets up a second operation.
The calling code had set up the ALU to perform &lt;code&gt;LRCY tmpC&lt;/code&gt;, so that&#39;s the result returned by  (and discarded).
Performing a left rotate and discarding the result may seem pointless, but the important side-effect is that the top bit
(i.e. the sign bit) ends up in the carry flag.
The microcode does not have a conditional jump based on the sign, but has a conditional jump based on carry, so the point is
to test if tmpC is negative.
The first micro-instruction also sets up negation (&lt;code&gt;NEG tmpC&lt;/code&gt;) for the &lt;em&gt;next&lt;/em&gt; ALU operation.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
  no dest  NEG tmpC   &lt;span&gt;&lt;b&gt;PREIMUL:&lt;/b&gt; set up negation of tmpC&lt;/span&gt;
             JMPS NCY 7  &lt;span&gt;jump if tmpC positive&lt;/span&gt;
  tmpC     CF1         &lt;span&gt;if negative, negate tmpC, flip F1&lt;/span&gt;
             JMPS 7      &lt;span&gt;jump to shared code&lt;/span&gt;

             LRCY tmpB  &lt;span&gt;&lt;b&gt;7:&lt;/b&gt;&lt;/span&gt;
  no dest  NEG tmpB    &lt;span&gt;set up negation of tmpB&lt;/span&gt;
             JMPS NCY 11 &lt;span&gt;jump if tmpB positive&lt;/span&gt;
  tmpB     CF1 RTN     &lt;span&gt;if negative, negate tmpB, flip F1&lt;/span&gt;
             RTN        &lt;span&gt;&lt;b&gt;11:&lt;/b&gt; return&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;For the remaining lines,
if the carry is clear (&lt;code&gt;NCY&lt;/code&gt;), the next two lines are skipped. Otherwise, the ALU result (&lt;code&gt;&lt;/code&gt;) is written to tmpC, making it positive,
and the &lt;code&gt;F1&lt;/code&gt; flag is complemented with &lt;code&gt;CF1&lt;/code&gt;. (The second short jump (&lt;code&gt;JMPS&lt;/code&gt;) may look unnecessary, but I reordered the code for clarity.)
The second half of the microcode performs a similar test on tmpB. If tmpB is negative, it is negated and &lt;code&gt;F1&lt;/code&gt; is toggled.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;NEGATE&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The microcode below is called after computing the result, if the result needs to be made negative.
Negation is harder than you might expect because the result is split between the tmpA and tmpC registers.
The two&#39;s complement operation (&lt;code&gt;NEG&lt;/code&gt;) is applied to the low word, while either 2&#39;s complement or one&#39;s complement (&lt;code&gt;COM1&lt;/code&gt;) is applied to
the upper word, depending on the carry for mathematical reasons.&lt;span id=&quot;fnref:neg&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:neg&quot;&gt;8&lt;/a&gt;&lt;/span&gt;
The code also toggles F1 and makes tmpB positive; I think this code is only useful for division, which also uses the &lt;code&gt;NEGATE&lt;/code&gt; subroutine.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
             NEG tmpC   &lt;span&gt;&lt;b&gt;NEGATE:&lt;/b&gt; negate tmpC&lt;/span&gt;
  tmpC     COM1 tmpA F &lt;span&gt;maybe complement tmpA&lt;/span&gt;
             JMPS CY 6  
             NEG tmpA    &lt;span&gt;negate tmpA if there&#39;s no carry&lt;/span&gt;
  tmpA     CF1        &lt;span&gt;&lt;b&gt;6:&lt;/b&gt; toggle F1 for some reason&lt;/span&gt;

             LRCY tmpB  &lt;span&gt;&lt;b&gt;7:&lt;/b&gt; test sign of tmpB&lt;/span&gt;
  no dest  NEG tmpB    &lt;span&gt;maybe negate tmpB&lt;/span&gt;
             JMPS NCY 11 &lt;span&gt;skip if tmpB positive&lt;/span&gt;
  tmpB     CF1 RTN     &lt;span&gt;else negate tmpB, toggle F1&lt;/span&gt;
             RTN        &lt;span&gt;&lt;b&gt;11:&lt;/b&gt; return&lt;/span&gt;
&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;IMULCOF&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;IMULCOF&lt;/code&gt; routine is similar to &lt;code&gt;MULCOF&lt;/code&gt;, but the calculation is a bit trickier for a signed result.
This routine sets the carry and overflow flags if the upper half of the result is significant, that is, it is not
just the sign extension of the lower half.&lt;span id=&quot;fnref:imulcof&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:imulcof&quot;&gt;9&lt;/a&gt;&lt;/span&gt;
In other words, the top byte is not significant if it duplicates the top bit (the sign bit) of the lower byte.
The trick in the microcode is to add the top bit of the lower byte to the upper byte by putting it in the carry flag
and performing an add with carry (&lt;code&gt;ADC&lt;/code&gt;) of 0.
If the result is 0, the upper byte is not significant, handling the positive and negative cases.
(This also holds for words instead of bytes.)&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
ZERO  tmpB  LRCY tmpC  &lt;span&gt;&lt;b&gt;IMULCOF:&lt;/b&gt; get top bit of tmpC&lt;/span&gt;
  no dest  ADC tmpA    &lt;span&gt;add to tmpA and 0 (tmpB)&lt;/span&gt;
  no dest   F          &lt;span&gt;update flags&lt;/span&gt;
             JMPS Z 8   &lt;span&gt;&lt;b&gt;12: jump if zero result&lt;/b&gt;&lt;/span&gt;
             SCOF RTN    &lt;span&gt;otherwise set carry and overflow&lt;/span&gt;

             CCOF RTN   &lt;span&gt;&lt;b&gt;8:&lt;/b&gt; clear carry and overflow&lt;/span&gt;
&lt;/pre&gt;

&lt;h2&gt;The hardware for multiplication&lt;/h2&gt;
&lt;p&gt;For the most part, the 8086 uses the regular ALU addition and shifts for the multiplication algorithm. Some special hardware
features provide assistance.&lt;/p&gt;
&lt;h3&gt;Loop counter&lt;/h3&gt;
&lt;p&gt;The 8086 has a special 4-bit loop counter for multiplication. This counter starts at 7 for byte multiplication and 15 for word multiplication,
based on the instruction.
This loop counter allows the microcode to decrement the counter, test for the end, and perform a conditional branch in one micro-operation.
The counter is implemented with four flip-flops, along with logic to compute the value after decrementing by one.
The &lt;code&gt;MAXC&lt;/code&gt; (Maximum Count) micro-instruction sets the counter to 7 or 15 for byte or word operations respectively.
The &lt;code&gt;NCZ&lt;/code&gt; (Not Counter Zero) micro-instruction has two actions. First, it performs a conditional jump if the counter is nonzero.
Second, it decrements the counter.&lt;/p&gt;
&lt;h3&gt;X register&lt;/h3&gt;
&lt;p&gt;The multiplication microcode uses an internal register called the &lt;code&gt;X&lt;/code&gt; register to distinguish between the &lt;code&gt;MUL&lt;/code&gt; and &lt;code&gt;IMUL&lt;/code&gt; instructions.
The &lt;code&gt;X&lt;/code&gt; register is a 3-bit register that holds the ALU opcode, indicated by bits 5&amp;ndash;3 of the instruction.&lt;span id=&quot;fnref:x-reg&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:x-reg&quot;&gt;10&lt;/a&gt;&lt;/span&gt;
Since the instruction is held in the Instruction Register, you might wonder why a separate register is required.
The motivation is that some opcodes specify the type of ALU operation in the second byte of the instruction, the ModR/M byte, bits 5&amp;ndash;3.&lt;span id=&quot;fnref:opcode&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:opcode&quot;&gt;11&lt;/a&gt;&lt;/span&gt;
Since the ALU operation is sometimes specified in the first byte and sometimes in the second byte, the &lt;code&gt;X&lt;/code&gt; register was added to handle
both these cases.&lt;/p&gt;
&lt;p&gt;For the most part, the &lt;code&gt;X&lt;/code&gt; register indicates which of the eight standard ALU operations is selected (&lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, &lt;code&gt;ADC&lt;/code&gt;, &lt;code&gt;SBB&lt;/code&gt;, &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;SUB&lt;/code&gt;, &lt;code&gt;XOR&lt;/code&gt;, &lt;code&gt;CMP&lt;/code&gt;). 
However, a few instructions use bit 0 of the &lt;code&gt;X&lt;/code&gt; register to distinguish between other pairs of instructions.
For instance, it distinguishes between &lt;code&gt;MUL&lt;/code&gt; and &lt;code&gt;IMUL&lt;/code&gt;, &lt;code&gt;DIV&lt;/code&gt; and &lt;code&gt;IDIV&lt;/code&gt;, &lt;code&gt;CMPS&lt;/code&gt; and &lt;code&gt;SCAS&lt;/code&gt;, &lt;code&gt;MOVS&lt;/code&gt; and &lt;code&gt;LODS&lt;/code&gt;, or &lt;code&gt;AAA&lt;/code&gt; and &lt;code&gt;AAS&lt;/code&gt;.
While these instruction pairs may appear to have arbitrary opcodes, they have been carefully assigned.
The microcode can test this bit using the &lt;code&gt;X0&lt;/code&gt; condition and perform conditional jumps.&lt;/p&gt;
&lt;p&gt;The implementation of the &lt;code&gt;X&lt;/code&gt; register is straightforward, consisting of three flip-flops to hold the three bits of the instruction.
The flip-flops are loaded from the prefetch queue bus during First Clock and during Second Clock for appropriate instructions, as the
instruction bytes travel over the bus.
Testing bit 0 of the &lt;code&gt;X&lt;/code&gt; register with the &lt;code&gt;X0&lt;/code&gt; condition is supported by the microcode condition evaluation circuitry, so it can be used for conditional jumps in the microcode.&lt;/p&gt;
&lt;h3&gt;The F1 flag&lt;/h3&gt;
&lt;p&gt;The multiplication microcode uses an internal flag called &lt;code&gt;F1&lt;/code&gt;,&lt;span id=&quot;fnref:f1&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:f1&quot;&gt;12&lt;/a&gt;&lt;/span&gt; which has two distinct uses.
The flag keeps track of a &lt;code&gt;REP&lt;/code&gt; prefix for use with a string operation.
But the &lt;code&gt;F1&lt;/code&gt; flag is also used by signed multiplication and division to keep track of the sign.
The &lt;code&gt;F1&lt;/code&gt; flag can be toggled by microcode through the &lt;code&gt;CF1&lt;/code&gt; (Complement F1) micro-instruction.
The &lt;code&gt;F1&lt;/code&gt; flag is implemented with a flip-flop, along with a multiplexer to select the value. It is cleared when a new instruction starts,
set by a &lt;code&gt;REP&lt;/code&gt; prefix, and toggled by the &lt;code&gt;CF1&lt;/code&gt; micro-instruction.&lt;/p&gt;
&lt;p&gt;The diagram below shows how the F1 latch and the loop counter appear on the die. In this image, the metal layer has been removed, showing the
silicon and the polysilicon wiring underneath.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-mul/counter.jpg&quot;&gt;&lt;img alt=&quot;The counter and F1 latch as they appear on the die. The latch for the REP state is also here.&quot; class=&quot;hilite&quot; height=&quot;308&quot; src=&quot;https://static.righto.com/images/8086-mul/counter-w600.jpg&quot; title=&quot;The counter and F1 latch as they appear on the die. The latch for the REP state is also here.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The counter and F1 latch as they appear on the die. The latch for the REP state is also here.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Later advances in multiplication&lt;/h2&gt;
&lt;p&gt;The 8086 was pretty slow at multiplying compared to later Intel processors.&lt;span id=&quot;fnref:performance&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:performance&quot;&gt;13&lt;/a&gt;&lt;/span&gt;
The 8086 took up to 133 clock cycles to multiply unsigned 16-bit values due to the complicated microcode loops.
By 1982, the Intel 286 processor cut this time down to 21 clock cycles.
The Intel 486 (1989) used an improved algorithm that could end early, so multiplying by a small number could take just 9 cycles.&lt;/p&gt;
&lt;p&gt;Although these optimizations improved performance, they still depended on looping over the bits.
With the shift to 32-bit processors, the loop time became unwieldy.
The solution was to replace the loop with hardware: instead of performing 32 shift-and-add loops,
an array of adders could compute the multiplication in one step.
This quantity of hardware was unreasonable in the 8086 era, but as Moore&#39;s law made transistors smaller and cheaper, hardware multiplication became
practical.
For instance, the Cyrix Cx486SLC (1992) had a 16-bit hardware multiplier that cut word multiply down to 3 cycles.
The Intel Core 2 (2006) was even faster, able to complete a 32-bit multiplication every clock cycle.&lt;/p&gt;
&lt;!-- Manual page 26-160 http://www.bitsavers.org/components/intel/80486/i486_Processor_Programmers_Reference_Manual_1990.pdf --&gt;
&lt;!-- https://techmonitor.ai/technology/cyrix_promises_misery_for_intel_with_its_cx486slc --&gt;
&lt;!-- Pentium: alpert 1993 --&gt;

&lt;p&gt;Hardware multiplication is a fairly complicated subject, with many optimizations to maximize performance while minimizing hardware.&lt;span id=&quot;fnref:hardware&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:hardware&quot;&gt;14&lt;/a&gt;&lt;/span&gt;
Simply replacing the loop with a sequence of 32 adders is too slow because the result would be delayed while propagating through all the adders.
The solution is to arrange the adders as a tree to provide parallelism. The first layer has 16 adders to add pairs of terms. The next layer adds pairs of these partial
sums, and so forth. The resulting tree of adders is 5 layers deep rather than 32, reducing the time to compute the sum.
Real multipliers achieve further performance improvements by splitting up the adders and creating a more complex tree:
the venerable &lt;a href=&quot;https://en.wikipedia.org/wiki/Wallace_tree&quot;&gt;Wallace tree&lt;/a&gt; (1964) and &lt;a href=&quot;https://en.wikipedia.org/wiki/Dadda_multiplier&quot;&gt;Dadda multiplier&lt;/a&gt; (1965) are
two popular approaches.
Another optimization is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Booth%27s_multiplication_algorithm&quot;&gt;Booth algorithm&lt;/a&gt; (1951), which performs signed
multiplication directly, without converting the arguments to positive values first.
The Pentium 4 (2000) used a Booth encoder and a Wallace tree
(&lt;a href=&quot;https://past.date-conference.com/proceedings-archive/2017/pyear/PAPERS/2002/DATE02/PDFFILES/01B_1.PDF&quot;&gt;ref&lt;/a&gt;), but research in
the early 2000s found the Dadda tree is faster and it is now more popular.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Multiplication is much harder to compute than addition or subtraction. The 8086 processor hid this complexity from the programmer
by providing four multiplication instructions for byte and word multiplication of signed or unsigned values.
These instructions implemented multiplication in microcode, performing shifts and adds in a loop.
By using microcode subroutines and conditional execution, these four machine instructions share most of the microcode.
As the microcode capacity of the 8086 was very small, this was a critical feature of the implementation.&lt;/p&gt;
&lt;p&gt;If you made it through all the discussion of microcode, congratulations!
Microcode is even harder to understand than assembly code.
Part of the problem is that microcode is very fine-grain, with even ALU operations split into multiple steps.
Another complication is that 8086 microcode performs a register move and another operation in parallel, so it&#39;s hard to
keep track of what&#39;s going on.
Microcode can seem a bit like a jigsaw puzzle, with pieces carefully fit together as compactly as possible.
I hope the explanations here made sense, or at least gave you a feel for how microcode operates.&lt;/p&gt;
&lt;p&gt;I&#39;ve written multiple &lt;a href=&quot;https://www.righto.com/search/label/8086&quot;&gt;posts on the 8086&lt;/a&gt; so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@kenshirriff@oldbytes.space&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:mul&quot;&gt;
&lt;p&gt;Mainframes going back to ENIAC had multiply and divide instructions.
However, early microprocessors took a step back and didn&#39;t supports these more complex operations.
(My theory is that the decline in memory prices made it more cost-effective to implement multiply and divide in software than hardware.)
The National Semiconductor &lt;a href=&quot;https://en.wikipedia.org/wiki/IMP-16&quot;&gt;IMP-16&lt;/a&gt;, a 16-bit bit-slice microprocessor from 1973, may be the first with multiply and divide instructions.
The 8-bit &lt;a href=&quot;https://en.wikipedia.org/wiki/Motorola_6809&quot;&gt;Motorola 6809&lt;/a&gt; processor (1978) included 8-bit multiplication but not division.
I think the 8086 was the first Intel processor to support multiplication.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:mul&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:division&quot;&gt;
&lt;p&gt;The 8086 also supported division. 
Although the division instructions are similar to multiplication in many ways, I&#39;m focusing on multiplication and ignoring division for this blog post.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:division&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:microcode&quot;&gt;
&lt;p&gt;My microcode analysis is based on Andrew Jenner&#39;s &lt;a href=&quot;https://www.reenigne.org/blog/8086-microcode-disassembled/&quot;&gt;8086 microcode disassembly&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:microcode&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:corx&quot;&gt;
&lt;p&gt;I think &lt;code&gt;CORX&lt;/code&gt; stands for &lt;code&gt;Core Multiply&lt;/code&gt; and &lt;code&gt;CORD&lt;/code&gt; stands for &lt;code&gt;Core Divide&lt;/code&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:corx&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:overflow&quot;&gt;
&lt;p&gt;The definitions of carry and overflow are different for multiplication compared to addition and subtraction.
Note that the result of a multiplication operation will always fit in the available result space, which is twice as large as the arguments.
For instance, the biggest value you can get by multiplying 16-bit values is &lt;code&gt;0xffff&lt;/code&gt;&amp;times;&lt;code&gt;0xffff&lt;/code&gt;=&lt;code&gt;0xfffe0001&lt;/code&gt; which fits into 32 bits.
(Signed and 8-bit multiplications fit similarly.)
This is in contrast to addition and subtraction, which can exceed their available space.
A carry indicates that an addition exceeded its space when treated as unsigned, while an overflow indicates that an addition exceeded its space
when treated as unsigned.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:overflow&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:flags&quot;&gt;
&lt;p&gt;The Intel documentation states that the sign, carry, overflow, and parity flags are undefined after the &lt;code&gt;MUL&lt;/code&gt; operation, even though
the microcode causes them to be computed.
The meaning of &quot;undefined&quot; is that programmers shouldn&#39;t count on the flag values because Intel might change the behavior in later chips.
&lt;a href=&quot;https://www.vogons.org/viewtopic.php?t=46211&quot;&gt;This thread&lt;/a&gt; discusses the effects of &lt;code&gt;MUL&lt;/code&gt; on the flags, and how the behavior is different
on the &lt;a href=&quot;https://en.wikipedia.org/wiki/NEC_V20&quot;&gt;NEC V20&lt;/a&gt; chip.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:flags&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:complement&quot;&gt;
&lt;p&gt;It may be worth explaining why the two&#39;s complement of a number is defined by adding 1 to the one&#39;s complement.
The one&#39;s complement of a number simply flips all the bits. If you take a byte value &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;0xff&lt;/code&gt; - &lt;code&gt;n&lt;/code&gt; is the one&#39;s complement, since
a 1 bit in &lt;code&gt;n&lt;/code&gt; produces a 0 bit in the result.&lt;/p&gt;
&lt;p&gt;Now, suppose we want to represent -5 as a signed byte. Adding &lt;code&gt;0x100&lt;/code&gt; will keep the same byte value with a carry out of the byte.
But &lt;code&gt;0x100&lt;/code&gt; - 5 = (1 + 0xff) - 5 = 1 + (&lt;code&gt;0xff&lt;/code&gt; - 5) = 1 + (one&#39;s complement of 5).
Thus, it makes sense mathematically to represent -5 by adding 1 to the one&#39;s complement of 5, and this holds for any value.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:complement&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:neg&quot;&gt;
&lt;p&gt;The negation code is a bit tricky because the result is split across two words.
In most cases, the upper word is bitwise complemented. However, if the lower word is zero, then the upper word is negated (two&#39;s complement).
I&#39;ll demonstrate with 16-bit values to keep the examples small.
The number 257 (0x0101) is negated to form -257 (0xfeff). Note that the upper byte is the one&#39;s complement (0x01 vs 0xfe) while the lower
byte is two&#39;s complement (0x01 vs 0xff).
On the other hand, the number 256 (0x0100) is negated to form -256 (0xff00). In this case, the upper byte is the two&#39;s complement (0x01 vs 0xff)
and the lower byte is also the two&#39;s complement (0x00 vs 0x00).&lt;/p&gt;
&lt;p&gt;(Mathematical explanation: the two&#39;s complement is formed by taking the one&#39;s complement and adding 1. In most cases, there won&#39;t be a carry from
the low byte to the upper byte, so the upper byte will remain the one&#39;s complement. However, if the low byte is 0, the complement is 0xff and
adding 1 will form a carry. Adding this carry to the upper byte yields the two&#39;s complement of that byte.)&lt;/p&gt;
&lt;p&gt;To support multi-word negation, the 8086&#39;s &lt;code&gt;NEG&lt;/code&gt; instruction clears the carry flag if the operand is 0, and otherwise sets the carry flag.
(This is the opposite from the above because subtractions (including &lt;code&gt;NEG&lt;/code&gt;) treat the carry flag as a borrow flag, with the opposite meaning.)
The microcode &lt;code&gt;NEG&lt;/code&gt; operation has identical behavior to the machine instruction, since it is used to implement the machine instruction.&lt;/p&gt;
&lt;p&gt;Thus to perform a two-word negation, the microcode negates the low word (tmpC) and updates the flags (&lt;code&gt;F&lt;/code&gt;).
If the carry is set, the one&#39;s complement is applied to the upper word (tmpA). But if the carry is cleared, the two&#39;s complement is applied to tmpA.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:neg&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:imulcof&quot;&gt;
&lt;p&gt;The &lt;code&gt;IMULCOF&lt;/code&gt; routine considers the upper half of the result significant if it is not the sign extension of the lower half.
For instance, dropping the top byte of &lt;code&gt;0x0005&lt;/code&gt; (+5) yields 0x05 (+5).
Dropping the top byte of &lt;code&gt;0xfffb&lt;/code&gt; (-5) yields 0xfb (-5). Thus, the upper byte is not significant in these cases.
Conversely, dropping the top byte of &lt;code&gt;0x00fb&lt;/code&gt; (+251) yields &lt;code&gt;0xfb&lt;/code&gt; (-5), so the upper byte is significant.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:imulcof&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:x-reg&quot;&gt;
&lt;p&gt;Curiously, the &lt;a href=&quot;https://patents.google.com/patent/US4449184A/&quot;&gt;8086 patent&lt;/a&gt; states that the &lt;code&gt;X&lt;/code&gt; register is a 4-bit register holding bits 3&amp;ndash;6 of
the byte (col. 9, line 20). But looking at the die, it is a 3-bit register holding bits 3&amp;ndash;5 of the byte.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:x-reg&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:opcode&quot;&gt;
&lt;p&gt;Some instructions are specified by bits 5&amp;ndash;3 in the ModR/M byte rather than in the first opcode byte.
The motivation is to avoid wasting bits for instructions that use a ModR/M byte but don&#39;t need a register specification.
For instance, consider the instruction &lt;code&gt;ADD [BX],0x1234&lt;/code&gt;. This instruction uses a ModR/M byte to specify the memory address.
However, because it uses an immediate operand, it does not need the register specification normally provided by bits 5&amp;ndash;3 of the ModR/M byte.
This frees up the bits to specify the instruction.
From one perspective, this is an ugly hack, while from another perspective it is a clever optimization.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:opcode&quot; title=&quot;Jump back to footnote 11 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:f1&quot;&gt;
&lt;p&gt;Andrew Jenner discusses the F1 flag and the interaction between &lt;code&gt;REP&lt;/code&gt; and multiplication &lt;a href=&quot;https://www.reenigne.org/blog/8086-microcode-disassembled/&quot;&gt;here&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:f1&quot; title=&quot;Jump back to footnote 12 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:performance&quot;&gt;
&lt;p&gt;Here are some detailed performance numbers.
The 8086 processor takes 70&amp;ndash;77 clock cycles to multiply 8-bit values and 118&amp;ndash;133 clock cycles to multiply 16-bit values.
Signed multiplies are a bit slower because of the sign calculations: 80&amp;ndash;98 and 128&amp;ndash;154 clock cycles respectively.
The time is variable because of the conditional jumps in the multiplication process.&lt;/p&gt;
&lt;p&gt;The Intel 186 (1982) optimized multiplication slightly, bringing the register word multiply down to 35&amp;ndash;37 cycles.
The Intel 286 (also 1982) reduced this to 21 clocks.
The 486 (1989) used a shift-add multiply function but it had an &quot;early out&quot; algorithm that stopped when the remaining bits were zero, so a 16-bit multiply could take from 9 to 22 clocks.
The 8087 floating point coprocessor (1980) used radix-4 multiplication, multiplying by pairs of bits at a time and either adding or subtracting. This yields half the addition cycles.
The Pentium&#39;s P5 micro-architecture (1993) took the unusual approach of reusing the floating-point unit&#39;s hardware multiplier for integer multiplication, taking 10 cycles for a 32-bit multiplication.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:performance&quot; title=&quot;Jump back to footnote 13 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:hardware&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://inst.eecs.berkeley.edu/~eecs151/sp18/files/Lecture21.pdf&quot;&gt;This presentation&lt;/a&gt; gives a good overview of implementations of multiplication in hardware.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:hardware&quot; title=&quot;Jump back to footnote 14 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/8390323699966089555/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=8390323699966089555' title='13 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/8390323699966089555'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/8390323699966089555'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/03/8086-multiplication-microcode.html' title='Reverse-engineering the multiplication algorithm in the Intel 8086 processor'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>13</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-276186601431337636</id><published>2023-03-10T22:10:00.001-08:00</published><updated>2023-03-11T10:12:03.716-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="chips"/><category scheme="http://www.blogger.com/atom/ns#" term="microcode"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>Reverse-engineering the register codes for the 8086 processor&#39;s microcode</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;
&lt;style&gt;
  pre.microcode {font-family: courier, fixed; padding: 10px; background-color: #f5f5f5; display:inline-block;border:none;}
  pre.microcode span {color: green; font-style:italic; font-family: sans-serif; font-size: 90%;}
&lt;/style&gt;

&lt;p&gt;Like most processors, the Intel 8086 (1978) provides registers that are faster than main memory.
As well as the registers that are visible to the programmer, the 8086 has a handful of internal registers that are hidden from the user.
Internally, the 8086 has a complicated scheme to select which register to use, with a combination of microcode and hardware.
Registers are assigned a 5-bit identifying number, either from the machine instruction or from the microcode.
In this blog post, I explain how this register system works.&lt;/p&gt;
&lt;p&gt;My analysis is based on reverse-engineering the 8086 from die photos. The die photo below shows the chip under a microscope.
For this die photo, I removed the the metal and polysilicon layers, revealing the silicon underneath.
I&#39;ve labeled the key functional blocks; the ones that are important to this post are darker.
In particular, the registers and the Arithmetic/Logic Unit (ALU) are at the left and the microcode ROM is in the lower right.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top and an Execution Unit (EU) below.
The BIU handles bus and memory activity as well as instruction prefetching, while the Execution Unit (EU) executes the instructions.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-registers/die-labeled2.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled.  Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;634&quot; src=&quot;https://static.righto.com/images/8086-registers/die-labeled2-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled.  Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled.  Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Microcode&lt;/h2&gt;
&lt;p&gt;Most people think of machine instructions as the basic steps that a computer performs.
However, many processors (including the 8086) have another layer of software underneath: microcode.
With microcode, instead of building the control circuitry from complex logic gates, the control logic is largely replaced with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.&lt;/p&gt;
&lt;p&gt;The 8086 uses a hybrid approach: although it uses microcode, much of the instruction functionality is implemented with gate logic.
This approach removed duplication from the microcode and kept the microcode small enough for 1978 technology.
In a sense, the microcode is parameterized.
For instance, the microcode can specify a generic Arithmetic/Logic Unit (ALU) operation and a generic register.
The gate logic examines the instruction to determine which specific operation to perform and the appropriate register.&lt;/p&gt;
&lt;p&gt;A micro-instruction in the 8086 is encoded into 21 bits as shown below.
Every micro-instruction has a move from a source register to a destination register, each specified with 5 bits; this encoding is the
main topic of this blog post.
The meaning of the remaining bits depends on the type field and can be anything from an ALU operation to a memory read or write to
a change of microcode control flow.
For more about 8086 microcode, see my &lt;a href=&quot;https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html&quot;&gt;microcode blog post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-registers/microcode-format.jpg&quot;&gt;&lt;img alt=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; class=&quot;hilite&quot; height=&quot;203&quot; src=&quot;https://static.righto.com/images/8086-registers/microcode-format-w700.jpg&quot; title=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The encoding of a micro-instruction into 21 bits. Based on &lt;a href=&quot;https://digitalcommons.law.scu.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=1031&amp;context=chtlj&quot;&gt;NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Let&#39;s look at how the machine instruction &lt;code&gt;XCHG AX,reg&lt;/code&gt; is implemented in microcode. This instruction exchanges &lt;code&gt;AX&lt;/code&gt; with the register specified in the low 3 bits
of the instruction.&lt;span id=&quot;fnref:nop&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:nop&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
The microcode for this instruction consists of three micro-instructions, so the instruction takes three clock cycles.
Each micro-instruction contains a move, which is the interesting part.&lt;span id=&quot;fnref:action&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:action&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
The specified register is moved to the ALU&#39;s temporary B register, the &lt;code&gt;AX&lt;/code&gt; register is moved to the specified register, and finally
the temporary B is moved to &lt;code&gt;AX&lt;/code&gt;, completing the swap.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
 move       action
M  tmpB           &lt;span&gt;&lt;b&gt;XCHG AX,rw&lt;/b&gt;: move reg to tmpB&lt;/span&gt;
AX  M      NXT     &lt;span&gt;move AX to reg, Next to last&lt;/span&gt;
tmpB  AX   RNI     &lt;span&gt;move tmpB to AX, Run Next Instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;The key part for this discussion is how &lt;code&gt;M&lt;/code&gt; indicates the desired register.
Suppose the instruction is &lt;code&gt;XCHG AX,DX&lt;/code&gt;. The bottom three bits of the instruction are &lt;code&gt;010&lt;/code&gt;, indicating &lt;code&gt;DX&lt;/code&gt;.
During the first clock cycle of instruction execution, the opcode byte is transferred from the prefetch queue over the queue bus.
The &lt;code&gt;M&lt;/code&gt; register is loaded with the &lt;code&gt;DX&lt;/code&gt; number (which happens to be 26), based on the bottom three bits of the instruction.
After a second clock cycle, the microcode starts.
The first micro-instruction puts &lt;code&gt;M&lt;/code&gt;&#39;s value (26) onto the source bus and the number for &lt;code&gt;tmpB&lt;/code&gt; (13) on the destination bus, causing the transfer from
&lt;code&gt;DX&lt;/code&gt; to &lt;code&gt;tmpB&lt;/code&gt;.
The second micro-instruction puts the &lt;code&gt;AX&lt;/code&gt; number (24) onto the source bus and the &lt;code&gt;M&lt;/code&gt; value (26) onto the destination bus, causing the transfer from &lt;code&gt;AX&lt;/code&gt; to &lt;code&gt;DX&lt;/code&gt;.
The third micro-instruction puts &lt;code&gt;tmpB&lt;/code&gt; number (13) onto the source bus and the &lt;code&gt;AX&lt;/code&gt; number (24) onto the destination bus, causing the transfer from &lt;code&gt;tmpB&lt;/code&gt; to &lt;code&gt;AX&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Thus, the values on the source and destination bus control the data transfer during each micro-instruction. Microcode can either specify these values explicitly
(as for &lt;code&gt;AX&lt;/code&gt; and &lt;code&gt;tmpB&lt;/code&gt;) or can specify the &lt;code&gt;M&lt;/code&gt; register to use the register defined in the instruction.
Thus, the same microcode implements all the &lt;code&gt;XCHG&lt;/code&gt; instructions and the microcode doesn&#39;t need to know which register is involved.&lt;/p&gt;
&lt;h2&gt;The register encoding&lt;/h2&gt;
&lt;p&gt;The microcode above illustrated how different numbers specified different registers.
The table below shows how the number 0-31 maps onto a register.
Some numbers have a different meaning for a source register or a destination register; a slash separates these entries.&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
  table#src {border-collapse: collapse; border: 1px solid #888;}
  table#src td {padding: 2px 6px;}
  table#src td.l {border-left: 2px solid #888;}
  table#src td.seg {background-color: #cfc;}
  table#src td.w0 {background-color: #cff;}
  table#src td.w1 {background-color: #fcc;}
&lt;/style&gt;

&lt;table id=&quot;src&quot;&gt;
&lt;tr&gt;&lt;td class=&quot;l&quot;&gt;0&lt;/td&gt;&lt;td class=&quot;seg&quot;&gt;ES&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;8&lt;/td&gt;&lt;td class=&quot;w0&quot;&gt;AL&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;16&lt;/td&gt;&lt;td class=&quot;w0&quot;&gt;AH&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;24&lt;/td&gt;&lt;td class=&quot;w1&quot;&gt;AX&lt;/td&gt;
&lt;tr&gt;&lt;td class=&quot;l&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;seg&quot;&gt;CS&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;9&lt;/td&gt;&lt;td class=&quot;w0&quot;&gt;CL&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;17&lt;/td&gt;&lt;td class=&quot;w0&quot;&gt;CH&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;25&lt;/td&gt;&lt;td class=&quot;w1&quot;&gt;CX&lt;/td&gt;
&lt;tr&gt;&lt;td class=&quot;l&quot;&gt;2&lt;/td&gt;&lt;td class=&quot;seg&quot;&gt;SS&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;10&lt;/td&gt;&lt;td class=&quot;w0&quot;&gt;DL&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;18&lt;/td&gt;&lt;td class=&quot;w0&quot;&gt;DH&lt;/td&gt;&lt;td&gt;(M)&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;26&lt;/td&gt;&lt;td class=&quot;w1&quot;&gt;DX&lt;/td&gt;
&lt;tr&gt;&lt;td class=&quot;l&quot;&gt;3&lt;/td&gt;&lt;td class=&quot;seg&quot;&gt;DS&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;11&lt;/td&gt;&lt;td class=&quot;w0&quot;&gt;BL&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;19&lt;/td&gt;&lt;td class=&quot;w0&quot;&gt;BH&lt;/td&gt;&lt;td&gt;(N)&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;27&lt;/td&gt;&lt;td class=&quot;w1&quot;&gt;BX&lt;/td&gt;
&lt;tr&gt;&lt;td class=&quot;l&quot;&gt;4&lt;/td&gt;&lt;td class=&quot;&quot;&gt;PC&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;12&lt;/td&gt;&lt;td class=&quot;&quot;&gt;tmpA&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;20&lt;/td&gt;&lt;td colspan=2 class=&quot;&quot;&gt;/tmpAL&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;28&lt;/td&gt;&lt;td class=&quot;w1&quot;&gt;SP&lt;/td&gt;
&lt;tr&gt;&lt;td class=&quot;l&quot;&gt;5&lt;/td&gt;&lt;td class=&quot;&quot;&gt;IND&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;13&lt;/td&gt;&lt;td class=&quot;&quot;&gt;tmpB&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;21&lt;/td&gt;&lt;td colspan=2 class=&quot;&quot;&gt;ONES/tmpBL&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;29&lt;/td&gt;&lt;td class=&quot;w1&quot;&gt;BP&lt;/td&gt;
&lt;tr&gt;&lt;td class=&quot;l&quot;&gt;6&lt;/td&gt;&lt;td class=&quot;&quot;&gt;OPR&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;14&lt;/td&gt;&lt;td class=&quot;&quot;&gt;tmpC&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;22&lt;/td&gt;&lt;td colspan=2 class=&quot;&quot;&gt;CR/tmpAH&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;30&lt;/td&gt;&lt;td class=&quot;w1&quot;&gt;SI&lt;/td&gt;
&lt;tr&gt;&lt;td class=&quot;l&quot;&gt;7&lt;/td&gt;&lt;td class=&quot;&quot;&gt;Q/-&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;15&lt;/td&gt;&lt;td class=&quot;&quot;&gt;F&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;23&lt;/td&gt;&lt;td colspan=2 class=&quot;&quot;&gt;ZERO/tmpBH&lt;/td&gt;&lt;td class=&quot;l&quot;&gt;31&lt;/td&gt;&lt;td class=&quot;w1&quot;&gt;DI&lt;/td&gt;
&lt;/table&gt;

&lt;p&gt;Most of these entries are programmer-visible registers: the segment registers are in green, the 8-bit registers in blue, and the 16-bit registers
in red.
Some internal registers and pseudo-registers are also accessible:
&lt;code&gt;IND&lt;/code&gt; (Indirect register), holding the memory address for a read or write;
&lt;code&gt;OPR&lt;/code&gt; (Operand register), holding the data for a read or write;
&lt;code&gt;Q&lt;/code&gt; (Queue), reading a byte from the instruction prefetch queue;
ALU temporary registers A, B, and C, along with low (L) and (H) bytes;
&lt;code&gt;F&lt;/code&gt;, Flags register;
&lt;code&gt;&lt;/code&gt;, the ALU output;
&lt;code&gt;ONES&lt;/code&gt;, all ones;
&lt;code&gt;CR&lt;/code&gt;, the three low bits of the microcode address;
and &lt;code&gt;ZERO&lt;/code&gt;, the value zero. The &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; entries can only be specified from microcode, taking the place of &lt;code&gt;DH&lt;/code&gt; and &lt;code&gt;BH&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The table is kind of complicated, but there are reasons for its structure.
First, machine instructions in the 8086 encode registers according to the system below.
The 5-bit register number above is essentially an extension of the instruction encoding.
Moreover, the AX/CX/DX/BX registers (red) are lined up with their upper-byte and lower-byte versions (blue).
This simplifies the hardware since
the low three bits of the register number select the register, while the upper two bits perform the byte versus word selection.&lt;span id=&quot;fnref:conflict&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:conflict&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
The internal registers fit into available spots in the table.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-registers/reg-assignments.jpg&quot;&gt;&lt;img alt=&quot;The register assignments, from MCS-86 Assembly Language Reference Guide.&quot; class=&quot;hilite&quot; height=&quot;189&quot; src=&quot;https://static.righto.com/images/8086-registers/reg-assignments-w400.jpg&quot; title=&quot;The register assignments, from MCS-86 Assembly Language Reference Guide.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The register assignments, from &lt;a href=&quot;http://bitsavers.org/components/intel/8086/9800749-1_MCS-86_Assembly_Language_Reference_Guide_Oct78.pdf&quot;&gt;MCS-86 Assembly Language Reference Guide&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The ModR/M byte&lt;/h2&gt;
&lt;p&gt;Many of the 8086 instructions use a second byte called the ModR/M byte to specify the addressing modes.&lt;span id=&quot;fnref:modrm&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:modrm&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
The ModR/M byte gives the 8086 a lot of flexibility in how an instruction accesses its operands.
The byte specifies a register for one operand and either a register or memory for the other operand.
The diagram below shows how the byte is split into three fields:
&lt;code&gt;mod&lt;/code&gt; selects the overall mode, &lt;code&gt;reg&lt;/code&gt; selects a register, and &lt;code&gt;r/m&lt;/code&gt; selects either a register or memory mode.
For a ModR/M byte, the &lt;code&gt;reg&lt;/code&gt; and the &lt;code&gt;r/m&lt;/code&gt; fields are read into the &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;M&lt;/code&gt; registers respectively, so the registers specified in the ModR/M byte
can be accessed by the microcode.&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
table.modrm {border-collapse:collapse; border: 2px solid #999; padding: 5px;}
table.modrm th {border: 2px solid #999;}
table.modrm th,td {padding: 2px 9px;}
table.modrm td {border-left: 2px solid #999;}
table.modrm .bl {border-left: 3px solid #999;}
table.modrm .c {text-align: center;}
&lt;/style&gt;

&lt;table class=&quot;modrm&quot;&gt;
&lt;tr&gt;&lt;th class=&quot;r&quot; colspan=2&gt;mod&lt;/th&gt;&lt;th class=&quot;g&quot; colspan=3&gt;reg&lt;/th&gt;&lt;th class=&quot;b&quot; colspan=3&gt;r/m&lt;/th&gt;&lt;tr&gt;
&lt;tr&gt;&lt;td class=&quot;r&quot;&gt;7&lt;/td&gt;&lt;td class=&quot;r&quot;&gt;6&lt;/td&gt;&lt;td class=&quot;g&quot;&gt;5&lt;/td&gt;&lt;td class=&quot;g&quot;&gt;4&lt;/td&gt;&lt;td class=&quot;g&quot;&gt;3&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;2&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Let&#39;s look at the instruction &lt;code&gt;SUB AX,BX&lt;/code&gt; which subtracts &lt;code&gt;BX&lt;/code&gt; from &lt;code&gt;AX&lt;/code&gt;.
In the 8086, some important processing steps take place before the microcode starts.
In particular, the &quot;Group Decode ROM&quot; categorizes the instruction into over a dozen categories that affect how it is processed, such as
instructions that are implemented without microcode, one-byte instructions, or instructions with a ModR/M byte.
The Group Decode ROM also indicates the structure of instructions, such as instructions that have a &lt;code&gt;W&lt;/code&gt; bit selecting byte versus word operations, or
a &lt;code&gt;D&lt;/code&gt; bit reversing the direction of the operands.
In this case, the Group Decode ROM classifies the instruction as 
containing a &lt;code&gt;D&lt;/code&gt; bit, a &lt;code&gt;W&lt;/code&gt; bit, an ALU operation, and a ModR/M byte.&lt;/p&gt;
&lt;p&gt;Based on the Group Decode ROM&#39;s signals, fields from the opcode and ModR/M bytes are extracted and stored in various internal registers.
The ALU operation type (&lt;code&gt;SUB&lt;/code&gt;) is stored in the &lt;code&gt;ALU opr&lt;/code&gt; register.
The ModR/M byte specifies &lt;code&gt;BX&lt;/code&gt; in the &lt;code&gt;reg&lt;/code&gt; field and &lt;code&gt;AX&lt;/code&gt; in the &lt;code&gt;r/m&lt;/code&gt; field so
the &lt;code&gt;reg&lt;/code&gt; register number (&lt;code&gt;BX&lt;/code&gt;, 27) is stored in the &lt;code&gt;N&lt;/code&gt; register, and the &lt;code&gt;r/m&lt;/code&gt; register number
(&lt;code&gt;AX&lt;/code&gt;, 24) is stored in the &lt;code&gt;M&lt;/code&gt; register.&lt;/p&gt;
&lt;p&gt;Once the preliminary decoding is done, the microcode below for this ALU instruction is executed.&lt;span id=&quot;fnref:microcode&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:microcode&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
There are three micro-instructions, so the instruction takes three clock cycles.
First, the register specified by &lt;code&gt;M&lt;/code&gt; (i.e. &lt;code&gt;AX&lt;/code&gt;) is moved to the ALU&#39;s temporary A register (&lt;code&gt;tmpA&lt;/code&gt;).
Meanwhile, &lt;code&gt;XI&lt;/code&gt; configures the ALU to perform the operation specified by the instruction bits, i.e. &lt;code&gt;SUB&lt;/code&gt;.
The second micro-instruction moves the register specified by &lt;code&gt;N&lt;/code&gt; (i.e. &lt;code&gt;BX&lt;/code&gt;) to the ALU&#39;s &lt;code&gt;tmpB&lt;/code&gt; register.
The last micro-instruction stores the ALU&#39;s result (&lt;code&gt;&lt;/code&gt;, number 20) in the register indicated by &lt;code&gt;M&lt;/code&gt; (i.e. &lt;code&gt;AX&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
  move       action
M  tmpA     XI tmpA   &lt;span&gt;&lt;b&gt;ALU rmr&lt;/b&gt;: AX to tmpA&lt;/span&gt;
N  tmpB     NXT       &lt;span&gt;BX to tmpB&lt;/span&gt;
  M        RNI F     &lt;span&gt;result to AX, update flags&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;One of the interesting features of the 8086 is that many instructions contain a &lt;code&gt;D&lt;/code&gt; bit that reverses the direction of the operation,
swapping the source and the destination. If we keep the ModR/M byte but use the &lt;code&gt;SUB&lt;/code&gt; instruction with the &lt;code&gt;D&lt;/code&gt; bit set, the
instruction becomes &lt;code&gt;SUB BX,AX&lt;/code&gt;, subtracting &lt;code&gt;AX&lt;/code&gt; from &lt;code&gt;BX&lt;/code&gt;, the opposite of before.
(Swapping the source and destination is more useful when one argument is in memory. But I&#39;ll use an example with two registers to keep it simple.)
This instruction runs exactly the same microcode as before. The difference is that when the microcode accesses &lt;code&gt;M&lt;/code&gt;, due to the direction bit it
gets the value in &lt;code&gt;N&lt;/code&gt;, i.e. &lt;code&gt;BX&lt;/code&gt; instead of &lt;code&gt;AX&lt;/code&gt;. The access to &lt;code&gt;N&lt;/code&gt; is similarly swapped.
The result is that &lt;code&gt;AX&lt;/code&gt; is subtracted from &lt;code&gt;BX&lt;/code&gt;, and the change of direction is transparent to the microcode.&lt;/p&gt;
&lt;h2&gt;The M and N registers&lt;/h2&gt;
&lt;p&gt;Now let&#39;s take a closer look at how the &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; registers are implemented.
Each register holds a 5-bit register number, expanded from the three bits of the instruction.
The M register is loaded from the three least significant bits of the instruction or ModR/M byte,
while the N register is loaded with bits three through five.
Most commonly, the registers are specified by the ModR/M byte, but some instructions specify the register in the opcode.&lt;span id=&quot;fnref:format&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:format&quot;&gt;6&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
table.mn {border-collapse:collapse; border: 2px solid #999; padding: 5px;text-align: center}
table.mn th,td {padding: 2px 9px;}
table.mn tr:first-child {border-bottom: 1px solid #999;}
table.mn th:first-child {border-right: 1px solid #999;}
table.mn th.seg {background-color: #cfc;}
table.mn th.w0 {background-color: #cff;}
table.mn th.w1 {background-color: #fcc;}
&lt;/style&gt;

&lt;p&gt;The table below shows how the bits in the instruction&#39;s opcode or ModR/M byte (&lt;code&gt;i5&lt;/code&gt;, &lt;code&gt;i4&lt;/code&gt;, &lt;code&gt;i3&lt;/code&gt;) are converted to a 5-bit number for the N register.
There are three cases: a 16-bit register, an 8-bit register, and a segment register.
The mappings below may seem random, but they result in the entries shown in the 5-bit register encoding table earlier.
I&#39;ve colored the entries so you can see the correspondence.&lt;/p&gt;
&lt;table class=&quot;mn&quot;&gt;
&lt;tr&gt;&lt;th &gt; Mode&lt;/th&gt;&lt;th&gt;4&lt;/th&gt;&lt;th&gt;3&lt;/th&gt;&lt;th&gt;2&lt;/th&gt;&lt;th&gt;1&lt;/th&gt;&lt;th&gt;0&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th class=&quot;w1&quot;&gt;16-bit reg&lt;/th&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;i5&lt;/td&gt;&lt;td&gt;i4&lt;/td&gt;&lt;td&gt;i3&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th class=&quot;w0&quot;&gt;8-bit reg&lt;/th&gt;&lt;td&gt;i5&lt;/td&gt;&lt;td&gt;i5&#39;&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;i4&lt;/td&gt;&lt;td&gt;i3&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th class=&quot;seg&quot;&gt;segment reg&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;i4&lt;/td&gt;&lt;td&gt;i3&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;I&#39;ll go through the three cases in more detail.
Many 8086 instructions have two versions, one that acts on bytes and one that acts on words, distinguished by the &lt;code&gt;W&lt;/code&gt; bit (bit 0) in the instruction.
If the Group Decode ROM indicates that the instruction has a &lt;code&gt;W&lt;/code&gt; bit and the &lt;code&gt;W&lt;/code&gt; bit is 0, then the instruction is a byte instruction.&lt;span id=&quot;fnref:byte&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:byte&quot;&gt;7&lt;/a&gt;&lt;/span&gt;
If the instruction has a ModR/M byte and the instruction operates on a byte, the &lt;code&gt;N&lt;/code&gt; register is loaded with the 5-bit number for the specified
byte register.
This happens during &quot;Second Clock&quot;, the clock cycle when the ModR/M byte is fetched from the instruction queue.
The second case is similar; if the instruction operates on a word, the &lt;code&gt;N&lt;/code&gt; register is loaded with the number for the word register specified in the
ModR/M byte.&lt;/p&gt;
&lt;p&gt;The third case handles a segment register.
The &lt;code&gt;N&lt;/code&gt; register is loaded with a segment register number during Second Clock if the Group Decode ROM indicates the instruction has a ModR/M byte with a segment-register field (specifically the segment register &lt;code&gt;MOV&lt;/code&gt; instructions).
A bit surprisingly, a segment register number is also loaded during First Clock.
This supports the &lt;code&gt;PUSH&lt;/code&gt; and &lt;code&gt;POP&lt;/code&gt; segment register instructions, which have the segment register encoded in bits 3 and 4 of the opcode.&lt;span id=&quot;fnref:prefix&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:prefix&quot;&gt;8&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;!--
N-reg-load-seg: FC or SC and SR group
N-reg-load-reg
N-reg-load-reg8
--&gt;

&lt;p&gt;The table below shows how the bits are assigned in the M register, which uses instruction bits &lt;code&gt;i2&lt;/code&gt;, &lt;code&gt;i1&lt;/code&gt;, and &lt;code&gt;i0&lt;/code&gt;.
The cases are a bit more complicated than the &lt;code&gt;N&lt;/code&gt; register.
First, a 16-bit register number is loaded from the opcode byte during First Clock to support instructions that specify the register in the low bits.
During Second Clock, this value may be replaced.&lt;/p&gt;
&lt;p&gt;For a ModR/M byte using register mode, the &lt;code&gt;M&lt;/code&gt; register is reloaded with the specified
8-bit or a 16-bit register, depending on the byte mode signal described earlier.
However, for a ModR/M byte that uses a memory mode, the &lt;code&gt;M&lt;/code&gt; register is loaded with &lt;code&gt;OPR&lt;/code&gt; (Operand), the internal register that holds the word that is read or written to memory.&lt;/p&gt;
&lt;table class=&quot;mn&quot;&gt;
&lt;tr&gt;&lt;th&gt;Mode&lt;/th&gt;&lt;th&gt;4&lt;/th&gt;&lt;th&gt;3&lt;/th&gt;&lt;th&gt;2&lt;/th&gt;&lt;th&gt;1&lt;/th&gt;&lt;th&gt;0&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th class=&quot;w1&quot;&gt;16-bit reg&lt;/th&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;i2&lt;/td&gt;&lt;td&gt;i1&lt;/td&gt;&lt;td&gt;i0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th class=&quot;w0&quot;&gt;8-bit reg&lt;/th&gt;&lt;td&gt;i2&lt;/td&gt;&lt;td&gt;i2&#39;&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;i1&lt;/td&gt;&lt;td&gt;i0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;OPR&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;AX/AL&lt;/th&gt;&lt;td&gt;byte&#39;&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;convert to 8-bit&lt;/th&gt;&lt;td&gt;m2&lt;/td&gt;&lt;td&gt;m2&#39;&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;m1&lt;/td&gt;&lt;td&gt;m0&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Many instructions use the AX or AL register, such as the ALU immediate instructions,
the input and output instructions, and string instructions. For these, the Group Decode ROM triggers the &lt;code&gt;AX&lt;/code&gt; or &lt;code&gt;AL&lt;/code&gt; register number
specifically to be loaded into the M register during Second Clock. The top bit is set for a word operation and cleared for a byte operation providing
&lt;code&gt;AX&lt;/code&gt; or &lt;code&gt;AL&lt;/code&gt; as appropriate.&lt;/p&gt;
&lt;p&gt;The final &lt;code&gt;M&lt;/code&gt; register case is a bit tricky. For an immediate move instruction such as &lt;code&gt;MOV BX,imm&lt;/code&gt;, bit 3 switches between a byte and a word move (rather than bit 0), because bits 2-0 specify the register.
Unfortunately, the Group Decode ROM outputs aren&#39;t available during First Clock to indicate this case.
Instead, &lt;code&gt;M&lt;/code&gt; is loaded during First Clock with the assumption of a 16-bit register. If that turns out to be wrong, the &lt;code&gt;M&lt;/code&gt; register is converted
to an 8-bit register number during Second Clock by shuffling a few bits.&lt;/p&gt;
&lt;h2&gt;Producing the source and destination values&lt;/h2&gt;
&lt;p&gt;There are three cases for the number that goes on the source or destination buses:
the register number can come from the micro-instruction, the value can come from the &lt;code&gt;M&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt; register as specified in the micro-instruction,
or the value can come from the &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; register with the roles swapped by the &lt;code&gt;D&lt;/code&gt; bit.
(Note that the source and destination can be different cases and are selected with separate circuitry.)&lt;/p&gt;
&lt;p&gt;The first case is the default case, where the 5 bits from the micro-instruction source or destination specify the register directly.
For instance, in the micro-instruction &lt;code&gt;tmpBAX&lt;/code&gt;, the microcode knows which registers are being used and specifies them directly.&lt;/p&gt;
&lt;p&gt;The second and third cases involve more logic. Consider the source in &lt;code&gt;MtmpB&lt;/code&gt;. 
For an instruction without a &lt;code&gt;D&lt;/code&gt; bit, the register number is taken from &lt;code&gt;M&lt;/code&gt;. Likewise if the &lt;code&gt;D&lt;/code&gt; bit is 0. But if the instruction uses a &lt;code&gt;D&lt;/code&gt; bit
and the &lt;code&gt;D&lt;/code&gt; bit is 1, then the register number is taken from &lt;code&gt;N&lt;/code&gt;.
Multiplexers between the &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; registers select the appropriate register to put on the bus.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-registers/mn-diagram.jpg&quot;&gt;&lt;img alt=&quot;The M and N registers as they appear on the die. The metal layer has been removed from this image to show the silicon and polysilicon underneath.&quot; class=&quot;hilite&quot; height=&quot;507&quot; src=&quot;https://static.righto.com/images/8086-registers/mn-diagram-w350.jpg&quot; title=&quot;The M and N registers as they appear on the die. The metal layer has been removed from this image to show the silicon and polysilicon underneath.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The M and N registers as they appear on the die. The metal layer has been removed from this image to show the silicon and polysilicon underneath.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The diagram above shows how the &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; register circuitry is implemented on the die, with the &lt;code&gt;N&lt;/code&gt; register at the top and the &lt;code&gt;M&lt;/code&gt; register below.
Each register has an input multiplexer that implements the tables above, selecting the appropriate 5 bits depending on the mode. The registers themselves are implemented as
dynamic latches driven by the clock. In the middle, a crossover multiplexer drives the source and destination buses, selecting the &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; registers
as appropriate and amplifying the signals with relatively large transistors. The third output from the multiplexer, the bits from the micro-instruction, is implemented in circuitry
physically separated and closer to the microcode ROM.&lt;/p&gt;
&lt;!--

The 8086 has multiple internal buses that connect its functional units.
The ALU (Arithmetic/Logic Unit) is a key part of the processor, as it performs arithmetic and logical operations on 16-bit values.
The ALU bus connects the registers to the ALU for these operations.
The ALU does not receive values directly from the bus, though. The ALU has three temporary registers to provide inputs: temporary A, B, and C.
Any of the temporary registers can provide the first operand, while the second operand always comes from the temporary B register.
The ALU&#39;s result is accessed over the ALU bus.
After performing an operation, the ALU updates the status flags directly. Conditional operations also access the flags directly.
However, the flags can also be read and written over the ALU bus, for instructions such as pushing and popping the flags.
--&gt;

&lt;h2&gt;The register selection hardware&lt;/h2&gt;
&lt;p&gt;How does the 5-bit number select a register?
The 8086 has a bunch of logic that turns a register number into a control line that enables reading or writing of the register.
For the most part, this logic is implemented with NOR gates that match a particular register number and generate a select signal.
The signal goes through a special &lt;a href=&quot;https://www.righto.com/2022/11/the-unusual-bootstrap-drivers-inside.html&quot;&gt;bootstrap driver&lt;/a&gt;
to boost its voltage since it needs to control 16 register bits.&lt;/p&gt;
&lt;p&gt;The 8086 registers are separated into two main groups. The &quot;upper registers&quot; are in the upper left of the chip, in the Bus Interface Unit.
These are the registers that are directly involved with memory accesses.
The &quot;lower registers&quot; are in the lower left of the chip, in the Execution Unit.
From bottom to top, they are &lt;code&gt;AX&lt;/code&gt;, &lt;code&gt;CX&lt;/code&gt;, &lt;code&gt;DX&lt;/code&gt;, &lt;code&gt;BX&lt;/code&gt;, &lt;code&gt;SP&lt;/code&gt;, &lt;code&gt;BP&lt;/code&gt;, &lt;code&gt;SI&lt;/code&gt;, and &lt;code&gt;DI&lt;/code&gt;; their physical order matches their order in the instruction set.&lt;span id=&quot;fnref:bx&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:bx&quot;&gt;9&lt;/a&gt;&lt;/span&gt;
A separate PLA (Programmable Logic Array) selects the ALU temporary registers or flags as destination.
Just below it, a PLA selects the source from ALU temporary registers, flags, or the ALU result (&lt;code&gt;&lt;/code&gt;).&lt;span id=&quot;fnref:ones&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:ones&quot;&gt;10&lt;/a&gt;&lt;/span&gt;
I&#39;ve written about the 8086&#39;s registers and their low-level implementation &lt;a href=&quot;https://www.righto.com/2020/07/the-intel-8086-processors-registers.html&quot;&gt;here&lt;/a&gt; if you want more information.&lt;/p&gt;
&lt;h2&gt;Some history&lt;/h2&gt;
&lt;p&gt;The 8086&#39;s system of selecting registers with 3-bit codes originates with the Datapoint 2200,&lt;span id=&quot;fnref:360&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:360&quot;&gt;11&lt;/a&gt;&lt;/span&gt;
a desktop computer announced in 1970.
The processor of the Datapoint 2200 was implemented with a board of TTL integrated circuits, since this was before microprocessors.
Many of the Datapoint&#39;s instructions used a 3-bit code to select a register, with a destination register specification in bits 5-3 of the
instruction and a source register in bits 2-0. (This layout is essentially the same as in 8086 instructions and the ModR/M byte.)&lt;span id=&quot;fnref:octal&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:octal&quot;&gt;12&lt;/a&gt;&lt;/span&gt;
The eight values of this code selected one of 7 registers, with the eighth value indicating a memory access.
Intel copied the Datapoint 2200 architecture for the 8008&lt;span id=&quot;fnref:datapoint&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:datapoint&quot;&gt;13&lt;/a&gt;&lt;/span&gt; microprocessor (1972) and cleaned it up for the 8080 (1974),
but kept the basic instruction layout and register/memory selection bits.&lt;/p&gt;
&lt;!--
Microcode was part of the motivation,
but other microcoded systems generally don&#39;t do this.
For example, the IBM System/360 Model 50 uses microcode (which I discuss [here](https://www.righto.com/2022/01/ibm360model50.html)),
but registers are selected in an ad hoc manner; each field in the micro-instruction uses a different numbering scheme, selecting just the
registers needed for that purpose. (Part of the reason is that the processor has a multitude of special-purpose buses, each with different
register connections.)
--&gt;

&lt;p&gt;The 8086&#39;s use of a numbering system for all the registers goes considerably beyond this pattern, partly because its registers
function both as general-purpose registers and special-purpose registers.&lt;span id=&quot;fnref:general-purpose&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:general-purpose&quot;&gt;14&lt;/a&gt;&lt;/span&gt;
Many instructions can act on the AX, BX, etc. registers interchangeably, treating them as general-purpose registers.
But these registers each have their own special purposes for other instructions, so the microcode must be able to access them specifically.
This motivates the 8086&#39;s approach where registers can be treated as general-purpose registers that are selected
from instruction bits, or as special-purpose registers selected by the microcode.&lt;/p&gt;
&lt;!--
A look at some other processsors shows the variety of approaches that can be taken for register selection.
The Zilog Z80 (1976) shows how register selection can be done in a non-microcoded processor.
The Z80 is an extension of the Intel 8080 but more complicated, with two register banks, each containing a larger number of registers.
Like the earlier Intel chips, the Z80 uses three-bit register codes in instructions with a decoder generating the appropriate register select line from these bits.
For the register banks, a bank-select flip-flop determine which register bank to use.
The Z80 also allowed some registers to be exchanged. This wasn&#39;t implemented by physically moving the values between registers,
but by renaming the registers by toggling a flip-flop.
I wrote more about Z80 registers [here](https://www.righto.com/2014/10/how-z80s-registers-are-implemented-down.html).
--&gt;

&lt;p&gt;The Motorola 68000 (1979) makes an interesting comparison to the 8086 since they were competitors.
The 68000 uses much wider microcode (85-bit microinstructions compared to 21 bits in the 8086).
It has two main internal buses, but instead of providing generic source and destination transfers like the 8086, the 68000 has a
much more complicated system: about two dozen microcode fields that connect registers and other components to the bus in various ways.&lt;span id=&quot;fnref:horizontal&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:horizontal&quot;&gt;15&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;!--
The general source-to-destination pattern used in the 8086 seems like it should be very common, but I had a hard time finding other systems
tht used it.
One system is the [RCA Spectra 70](https://en.wikipedia.org/wiki/RCA_Spectra_70),
a mostly forgotten mainframe from 1966 that used microcode.[spectra70]
A 56-bit microinstruction included the transfer of a source register to a destination register with six-bit codes specifying the registers, including numerous internal
registers.


[spectra70]: The microcode of the Spectra 70/45 is described in detail in the book [Microprogramming: principles and practices](https://amzn.to/3JfrE9j), chapter 9.


--&gt;

&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Internally, the 8086 represents registers with a 5-bit number. This is unusual compared to previous microprocessors, which usually
selected registers directly from the instruction or control circuitry.
Three factors motivated this design in the 8086. First, it used microcode, so a uniform method of specifying registers (both programmer-visible
and internal) was useful.
Second, being able to swap the source and destination in an instruction motivated a level of indirection in register specification, provided by the
&lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; registers.
Finally, the flexibility of the ModR/M byte, in particular supporting byte, word, and segment registers, meant that the register specification
needed 5 bits.&lt;/p&gt;
&lt;p&gt;I&#39;ve written multiple &lt;a href=&quot;https://www.righto.com/search/label/8086&quot;&gt;posts on the 8086&lt;/a&gt; so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:nop&quot;&gt;
&lt;p&gt;As an aside, the &lt;code&gt;NOP&lt;/code&gt; instruction (no operation) in the 8086 is really &lt;code&gt;XCHG AX,AX&lt;/code&gt;. Exchanging the &lt;code&gt;AX&lt;/code&gt; register with itself accomplishes nothing
but takes 3 clock cycles.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:nop&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:action&quot;&gt;
&lt;p&gt;The action part of the micro-instructions indicates the second-last
micro-instruction (&lt;code&gt;NXT&lt;/code&gt;, next) and the last (&lt;code&gt;RNI&lt;/code&gt;, Run Next Instruction), so execution of the next machine instruction can start.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:action&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:conflict&quot;&gt;
&lt;p&gt;Note that register #18 can refer both to &lt;code&gt;DH&lt;/code&gt; and the destination register.
This doesn&#39;t cause a conflict because it refers to &lt;code&gt;DH&lt;/code&gt; if loaded from the instruction, and refers to the destination
register if specified in the micro-instruction.
The only issue is that a micro-instruction can&#39;t refer to the &lt;code&gt;DH&lt;/code&gt; register explicitly (or the &lt;code&gt;BH&lt;/code&gt; register similarly).
This restriction isn&#39;t a problem because the microcode never needs to do this.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:conflict&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:modrm&quot;&gt;
&lt;p&gt;I discuss the 8086&#39;s ModR/M byte in detail &lt;a href=&quot;https://www.righto.com/2023/02/8086-modrm-addressing.html&quot;&gt;here&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:modrm&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:microcode&quot;&gt;
&lt;p&gt;The microcode listings are based on Andrew Jenner&#39;s &lt;a href=&quot;https://www.reenigne.org/blog/8086-microcode-disassembled/&quot;&gt;disassembly&lt;/a&gt;.
I have made some modifications to (hopefully) make it easier to understand.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:microcode&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:format&quot;&gt;
&lt;p&gt;There are a few instructions that specify a register in the opcode rather than the ModR/M byte.
For 16-bit registers, the &lt;code&gt;INC&lt;/code&gt;, &lt;code&gt;DEC&lt;/code&gt;, &lt;code&gt;XCHG&lt;/code&gt;, &lt;code&gt;PUSH&lt;/code&gt;, and &lt;code&gt;POP&lt;/code&gt; instructions specify the register in the low three bits of the opcode.
The &lt;code&gt;MOV&lt;/code&gt; immediate instructions specify either an 8-bit or 16-bit register in the low three bits.
On the other hand, the segment is specified by bits 3 and 4 of the segment prefixes, &lt;code&gt;PUSH&lt;/code&gt;, and &lt;code&gt;POP&lt;/code&gt; instructions.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:format&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:byte&quot;&gt;
&lt;p&gt;A few instructions only have byte versions (&lt;code&gt;DAA&lt;/code&gt;, &lt;code&gt;AAA&lt;/code&gt;, &lt;code&gt;DAS&lt;/code&gt;, &lt;code&gt;AAS&lt;/code&gt;, &lt;code&gt;AAM&lt;/code&gt;, &lt;code&gt;AAD&lt;/code&gt;, &lt;code&gt;XLAT&lt;/code&gt;).
This is indicated by a Group Decode ROM output and forces instruction execution into byte mode.
Thus, these instructions would load a byte register into &lt;code&gt;N&lt;/code&gt;, but since these instructions don&#39;t have a register specification, it doesn&#39;t matter.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:byte&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:prefix&quot;&gt;
&lt;p&gt;The segment prefixes use the same instruction bits (3 and 4) as &lt;code&gt;PUSH&lt;/code&gt; and &lt;code&gt;POP&lt;/code&gt; to select the segment register,
so you might expect the prefixes to also load the &lt;code&gt;N&lt;/code&gt; register.
However, the prefixes are implemented in hardware, rather than microcode. Thus, they do not use the &lt;code&gt;N&lt;/code&gt; register and the &lt;code&gt;N&lt;/code&gt; register is not loaded
with the segment register number.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:prefix&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:bx&quot;&gt;
&lt;p&gt;You might wonder why the &lt;code&gt;BX&lt;/code&gt; register is out of sequence with the other registers, both physically on the chip
and in the instruction set.
The 8086 was designed so 8080 assembly code could be translated to 8086 code.
Originally, the 8086 registers had different names: &lt;code&gt;XA&lt;/code&gt;, &lt;code&gt;BC&lt;/code&gt;, &lt;code&gt;DE&lt;/code&gt;, &lt;code&gt;HL&lt;/code&gt;, &lt;code&gt;SP&lt;/code&gt;, &lt;code&gt;MP&lt;/code&gt;, &lt;code&gt;IJ&lt;/code&gt;, and &lt;code&gt;IK&lt;/code&gt;.
The first four names matched the registers in the Intel 8080 processor, while &lt;code&gt;MP&lt;/code&gt; was Memory Pointer and &lt;code&gt;IJ&lt;/code&gt; and &lt;code&gt;IK&lt;/code&gt;
were Index registers.
However, when the 8086 was released the registers were given names that corresponded to their functions in the 8086, abandoning the 8080 names.
&lt;code&gt;XA&lt;/code&gt; became the Accumulator &lt;code&gt;AX&lt;/code&gt;,
The &lt;code&gt;BC&lt;/code&gt; register was used for counting, so it became the Count register &lt;code&gt;CX&lt;/code&gt;.
The &lt;code&gt;DE&lt;/code&gt; register was a data register, so it became the Data register &lt;code&gt;DX&lt;/code&gt;.
The &lt;code&gt;HL&lt;/code&gt; register was used as a base for memory accesses, so it became the Base register &lt;code&gt;BX&lt;/code&gt;.
The result is that the &lt;code&gt;BX&lt;/code&gt; register ended up last.&lt;/p&gt;
&lt;p&gt;A program &lt;code&gt;CONV-86&lt;/code&gt; allowed 8080 assembly programs to be translated into 8086 assembly programs, with 8080 registers
replaced with the corresponding 8086 registers.
The old 8086 register names can be seen in the &lt;a href=&quot;https://patents.google.com/patent/US4449184A&quot;&gt;8086 patent&lt;/a&gt;, while the
Accumulator, Base, Count, Data names are in the &lt;a href=&quot;http://bitsavers.org/components/intel/8086/9800749-1_MCS-86_Assembly_Language_Reference_Guide_Oct78.pdf&quot;&gt;MCS-86 Assembly Language Reference Guide&lt;/a&gt;.
See also &lt;a href=&quot;https://retrocomputing.stackexchange.com/questions/5121/why-are-first-four-x86-general-purpose-registers-named-in-such-unintuitive-order&quot;&gt;this Stack Exchange discussion&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:bx&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:ones&quot;&gt;
&lt;p&gt;The all-ones source doesn&#39;t have any decoding; the ALU bus is precharged to the high state, so it is all ones by default.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:ones&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:360&quot;&gt;
&lt;p&gt;The system of using bit fields in instructions to select registers is much older, of course.
The groundbreaking IBM System/360 architecture (1964), for instance, used 4-bit fields in instructions to select one of the 16 general-purpose
registers.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:360&quot; title=&quot;Jump back to footnote 11 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:octal&quot;&gt;
&lt;p&gt;Note that with this instruction layout, the instruction set maps cleanly onto octal.
The Datapoint 2200 used octal to describe the instruction set, but Intel switched to hexadecimal for its processors.
Hexadecimal was becoming more popular than octal at the time, but the move to hexadecimal hides most of the inherent structure of the instructions.
See &lt;a href=&quot;https://gist.github.com/seanjensengrey/f971c20d05d4d0efc0781f2f3c0353da&quot;&gt;x86 is an octal machine&lt;/a&gt; for details.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:octal&quot; title=&quot;Jump back to footnote 12 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:datapoint&quot;&gt;
&lt;p&gt;The Datapoint manufacturer talked to Intel and Texas Instruments about replacing the board of chips with a single processor chip.
Texas Instruments produced the TMX 1795 microprocessor chip and Intel produced the 8008 shortly after,
both copying the Datapoint 2200&#39;s architecture and instruction set.
Datapoint didn&#39;t like the performance of these chips and decided to stick with a TTL-based processor.
Texas Instruments couldn&#39;t find a customer for the TMX 1795 and abandoned it.
Intel, on the other hand, sold the 8008 as an 8-bit microprocessor, creating the microprocessor market in the process.
Register selection in these processors was pretty simple: the 3 instruction bits were decoded into 8 select lines that selected the appropriate register (or memory).
Since these processors had hard-coded control instead of microcode, the control circuity generated other register selection lines directly.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:datapoint&quot; title=&quot;Jump back to footnote 13 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:general-purpose&quot;&gt;
&lt;p&gt;While the 8086 has eight registers that can be viewed as general-purpose, they all have some specific purposes.
The &lt;code&gt;AX&lt;/code&gt; register acts as the accumulator and has several special functions, such as its use in the &lt;code&gt;XCHG&lt;/code&gt; (Exchange) operation, I/O operations, multiplication, and division.
The &lt;code&gt;BX&lt;/code&gt; register has a special role as a base register for memory accesses.
The &lt;code&gt;CX&lt;/code&gt; register acts as the counter for string operations and for the &lt;code&gt;JCXZ&lt;/code&gt; (Jump if &lt;code&gt;CX&lt;/code&gt; Zero) instruction.
The &lt;code&gt;DX&lt;/code&gt; register can specify the port for I/O operations and is used for &lt;code&gt;CWD&lt;/code&gt; (Convert Word to Doubleword) and in multiplication and division.
The &lt;code&gt;SP&lt;/code&gt; register has a unique role as the stack pointer.
The &lt;code&gt;SI&lt;/code&gt; and &lt;code&gt;DI&lt;/code&gt; registers are used as index registers for string operations and memory accesses.
Finally, the &lt;code&gt;BP&lt;/code&gt; register has a unique role as base pointer into the stack segment.
On the 8-bit side, &lt;code&gt;AX&lt;/code&gt;, &lt;code&gt;BX&lt;/code&gt;, &lt;code&gt;CX&lt;/code&gt;, and &lt;code&gt;DX&lt;/code&gt; can be accessed as 8-bit registers, while the other registers cannot.
The 8-bit &lt;code&gt;AL&lt;/code&gt; register is used specifically for &lt;code&gt;XLAT&lt;/code&gt; (Translate) while &lt;code&gt;AH&lt;/code&gt; is used for the flag operations &lt;code&gt;LAHF&lt;/code&gt; and &lt;code&gt;SAHF&lt;/code&gt;.
Thus, the 8086&#39;s registers are not completely orthogonal, and each one has some special cases, often for historical reasons.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:general-purpose&quot; title=&quot;Jump back to footnote 14 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:horizontal&quot;&gt;
&lt;p&gt;Another way of looking at the Motorola 68000&#39;s microcode is that the register controls come from &quot;horizontal&quot; microcode, a micro-instruction
with many bits, and fields that control functional elements directly.
The 8086&#39;s microcode is more &quot;vertical&quot;; the micro-instructions have relatively few bits and the fields are highly encoded.
In particular, the 8086&#39;s source and destination register fields are highly encoded, while the 68000 has fields that control the connection
of an individual register to the bus.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:horizontal&quot; title=&quot;Jump back to footnote 15 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/276186601431337636/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=276186601431337636' title='3 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/276186601431337636'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/276186601431337636'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/03/8086-register-codes.html' title='Reverse-engineering the register codes for the 8086 processor&#39;s microcode'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-6097486051589556772</id><published>2023-03-04T10:16:00.003-08:00</published><updated>2023-03-04T13:59:58.828-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="analog"/><category scheme="http://www.blogger.com/atom/ns#" term="globus"/><category scheme="http://www.blogger.com/atom/ns#" term="space"/><title type='text'>Reverse-engineering the electronics in the Globus analog navigational computer</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
&lt;/style&gt;

&lt;p&gt;In the Soyuz space missions, cosmonauts tracked their position above the Earth with a remarkable electromechanical
device with a rotating globe.
This navigation instrument was an analog computer that used an elaborate system of gears, cams, and differentials
to compute the spacecraft&#39;s position.
Officially, the unit was called a &quot;space navigation indicator&quot; with the Russian acronym  (INK),&lt;span id=&quot;fnref:ink&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:ink&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
but I&#39;ll use the nickname &quot;Globus&quot;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/globus.jpg&quot;&gt;&lt;img alt=&quot;The INK-2S &amp;quot;Globus&amp;quot; space navigation indicator.&quot; class=&quot;hilite&quot; height=&quot;457&quot; src=&quot;https://static.righto.com/images/globus-electronics/globus-w600.jpg&quot; title=&quot;The INK-2S &amp;quot;Globus&amp;quot; space navigation indicator.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The INK-2S &quot;Globus&quot; space navigation indicator.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;We recently received a Globus from a collector and opened it up for repair and reverse engineering. 
Although the Globus does all its calculations mechanically, it has some electronics to control the motors.
Inconveniently, all the wires in the wiring harness to the external connector had been cut so
I had to do some reverse engineering before we could power it up.
In this blog post, I explain how the electronics operate.
(For an overview of the mechanical components inside the Globus, see my &lt;a href=&quot;https://www.righto.com/2023/01/inside-globus-ink-mechanical-navigation.html&quot;&gt;previous article&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/gears.jpg&quot;&gt;&lt;img alt=&quot;A closeup of the gears inside the Globus. It performed calculations with gears, cams, and differentials.&quot; class=&quot;hilite&quot; height=&quot;375&quot; src=&quot;https://static.righto.com/images/globus-electronics/gears-w500.jpg&quot; title=&quot;A closeup of the gears inside the Globus. It performed calculations with gears, cams, and differentials.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A closeup of the gears inside the Globus. It performed calculations with gears, cams, and differentials.&lt;/div&gt;&lt;/p&gt;
&lt;!--
![A closeup of the differential gears inside the Globus. It performed calculations with gears, cams, and differentials.](differentials.jpg &quot;w600&quot;)
--&gt;

&lt;h2&gt;Functionality&lt;/h2&gt;
&lt;p&gt;The primary purpose of the Globus is to indicate the spacecraft&#39;s position. The globe rotated while fixed crosshairs on the
plastic dome 
indicated the spacecraft&#39;s position.
Thus, the globe matched the cosmonauts&#39; view of the Earth, allowing them to confirm their location.
Latitude and longitude dials next to the globe provided a numerical indication of location.
The light/shadow dial at the bottom showed when the spacecraft would be illuminated by the sun or in shadow.&lt;/p&gt;
&lt;p&gt;The mode of the Globus is controlled by a three-position rotary switch near the top of the Globus.
The middle position &quot;&quot; (, Earth) shows the position of the spacecraft over the Earth.
The left position, &quot;&quot; ( , landing site) selects the landing position mode.
The third position &quot;&quot; (off) turns off most of the Globus.
This rotary switch is surprisingly complicated with three wafers, each with two poles. Most of the electronics
go through this switch, so this switch will appear often in the schematics below.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/rotary-switch.jpg&quot;&gt;&lt;img alt=&quot;The rotary switch to select the landing angle mode.&quot; class=&quot;hilite&quot; height=&quot;204&quot; src=&quot;https://static.righto.com/images/globus-electronics/rotary-switch-w300.jpg&quot; title=&quot;The rotary switch to select the landing angle mode.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The rotary switch to select the landing angle mode.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;In the landing position mode, the Globus rotates to show where the spacecraft would land if you fired the retrorockets now.
This allowed the cosmonauts to evaluate the suitability of this landing site.
This position is computed simply by rapidly rotating the globe through a fraction of an orbit, since the landing position
will be on the current orbital track. Most of the electronics in the Globus control the motor that performs this rotation.&lt;/p&gt;
&lt;h2&gt;Overview of the electronics&lt;/h2&gt;
&lt;p&gt;The Globus is primarily mechanical, but it has more electrical and electronic components than you might expect.
The mechanical motion is powered by two solenoids with ratchets to turn gears.
The landing site mode is implemented with a motor to rotate to the landing position, controlled by two limit switches.
An electroluminescent light indicates the landing position mode.
A potentiometer provides position feedback to external devices.&lt;/p&gt;
&lt;p&gt;To control these components, the Globus has an electronics board
with four relays, along with a germanium power transistor and some resistors and diodes.&lt;span id=&quot;fnref:flyback&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:flyback&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
Bundles of thin white wires with careful lacing connect the electronics board to the other components.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/electronics.jpg&quot;&gt;&lt;img alt=&quot;The electronics circuit board.&quot; class=&quot;hilite&quot; height=&quot;267&quot; src=&quot;https://static.righto.com/images/globus-electronics/electronics-w700.jpg&quot; title=&quot;The electronics circuit board.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The electronics circuit board.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The back of the circuit board has a few more diodes. The wiring is all point-to-point; it is not a printed-circuit board.
I will explain the circuitry in more detail below.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/board-back.jpg&quot;&gt;&lt;img alt=&quot;The back of the circuit board.&quot; class=&quot;hilite&quot; height=&quot;272&quot; src=&quot;https://static.righto.com/images/globus-electronics/board-back-w700.jpg&quot; title=&quot;The back of the circuit board.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The back of the circuit board.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The drive solenoids&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/upper-solenoid.jpg&quot;&gt;&lt;img alt=&quot;The green cylinder at the front is the upper solenoid, driving the orbital motion. The digit wheels to indicate orbital time are at the left.&quot; class=&quot;hilite&quot; height=&quot;256&quot; src=&quot;https://static.righto.com/images/globus-electronics/upper-solenoid-w400.jpg&quot; title=&quot;The green cylinder at the front is the upper solenoid, driving the orbital motion. The digit wheels to indicate orbital time are at the left.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The green cylinder at the front is the upper solenoid, driving the orbital motion. The digit wheels to indicate orbital time are at the left.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The Globus contains two ratchet solenoids: one for the orbital rotation and one for the Earth&#39;s rotation.
The complex gear trains and the motion of the globe are driven by these solenoids.
These solenoids take 1-hertz pules of 27 volts and 100ms duration.
Each pulse causes the solenoid to advance the gear by one tooth; a pawl keeps the gear from slipping back.
These small rotations drive the gears throughout the Globus and result in a tiny movement of the globe.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/solenoid2.jpg&quot;&gt;&lt;img alt=&quot;The lower driving solenoid powers the Earth rotation.&quot; class=&quot;hilite&quot; height=&quot;281&quot; src=&quot;https://static.righto.com/images/globus-electronics/solenoid2-w300.jpg&quot; title=&quot;The lower driving solenoid powers the Earth rotation.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The lower driving solenoid powers the Earth rotation.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;As the schematic shows, the solenoids are controlled by two switches that are closed in the  (landing position) and  (Earth orbit) modes.
The solenoids are powered through three pins.
The wiring doesn&#39;t entirely make sense to me. If powered through pins 2A and 7A, the Earth motor is switched while
the orbit motor is always powered. But if powered through pins 2A and 5B, both motors are switched.
Maybe pin 7A monitors the on/off status of the Globus.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/schematic-solenoids.jpg&quot;&gt;&lt;img alt=&quot;Schematic diagram of the solenoid wiring.&quot; class=&quot;hilite&quot; height=&quot;283&quot; src=&quot;https://static.righto.com/images/globus-electronics/schematic-solenoids-w200.jpg&quot; title=&quot;Schematic diagram of the solenoid wiring.&quot; width=&quot;200&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Schematic diagram of the solenoid wiring.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;By powering the solenoids with 1 hertz pulses, we caused the Globus to rotate. The motion is very slow (90 minutes for an orbit and one day for the Earth&#39;s rotation), so we tried overclocking it at 10 hertz. This made the motion barely visible; Marc used a time-lapse to speed it up in the video below.&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/vCogLM-R8FU&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2&gt;The landing location mechanism&lt;/h2&gt;
&lt;p&gt;The Globus can display where the spacecraft would land if you started a re-entry burn now, with an accuracy
of 150 km.
This is computed by projecting the current orbit forward for a particular distance, specified as an angle.
The cosmonaut specifies this value with the landing angle knob (&lt;a href=&quot;http://www.svengrahn.pp.se/histind/Ugol/Ugol.html&quot;&gt;details&lt;/a&gt;).
Rotating the globe to this new position is harder than you might expect, using a motor, limit switches, and the
majority of the electronics in the Globus.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/landing-angle.jpg&quot;&gt;&lt;img alt=&quot;The landing angle control.&quot; class=&quot;hilite&quot; height=&quot;146&quot; src=&quot;https://static.righto.com/images/globus-electronics/landing-angle-w300.jpg&quot; title=&quot;The landing angle control.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The landing angle control.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The landing angle knob pivots the angle limit switch, shown below.
The swing arm moves as the globe rotates to the landing position and
hits the angle limit switch when the landing position is reached.
When returning to Earth orbit mode, the swing arm swings back until it hits the fixed limit switch.
Thus, the globe is rotated by the selected amount when displaying the landing position.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/landing-angle-diagram.jpg&quot;&gt;&lt;img alt=&quot;The landing angle function uses a complex mechanism.&quot; class=&quot;hilite&quot; height=&quot;471&quot; src=&quot;https://static.righto.com/images/globus-electronics/landing-angle-diagram-w450.jpg&quot; title=&quot;The landing angle function uses a complex mechanism.&quot; width=&quot;450&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The landing angle function uses a complex mechanism.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;To control the motor, the rotary switch reverses the DC motor based on the mode, while the limit switches and power transistor turn the motor on and off.
In landing position mode (), the motor spins the globe forward.
The mode switch controls the direction of current flow: from upper right, through the motor, through the angle
limit switch, through the transistor, and to ground at the bottom.
The motor will rotate the globe and the arm until it hits the &quot;landing position&quot; limit switch, cutting power to the motor and
activating the path to the light circuit,
which I will discuss below. The diode prevents current flowing backward through the motor to the relay.
The power transistor apparently acts as a current sink, regulating the current through the motor. &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/schematic-landing.jpg&quot;&gt;&lt;img alt=&quot;Schematic diagram of the landing location mechanism.&quot; class=&quot;hilite&quot; height=&quot;591&quot; src=&quot;https://static.righto.com/images/globus-electronics/schematic-landing-w400.jpg&quot; title=&quot;Schematic diagram of the landing location mechanism.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Schematic diagram of the landing location mechanism.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;In Earth orbit mode (), the motor spins the globe back to its regular position.
The mode switch reverses the current flow through the motor: from the upper-left,
through the diode and the motor, and out the lower-right to the transistor.
At the bottom, the relay completes the circuit until the moving arm hits the fixed orbit limit switch.
This opens the normally-closed contact, cutting power to the relay, opening the relay contact, and stopping the motor.&lt;/p&gt;
&lt;h2&gt;The landing place light&lt;/h2&gt;
&lt;p&gt;The upper-left corner of the Globus has an electroluminescent light labeled &quot; &quot; (Landing place).
This light illuminates when the globe indicates the landing place rather than the orbital position.
The light is powered by AC provided on two external pins and is controlled by two relays.
One relay is activated by the landing circuit described above, when the limit switch closes. The second relay is driven
by an external pin.
I don&#39;t know if this is for a &quot;lamp test&quot; or control from an external system.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/schematic-light.jpg&quot;&gt;&lt;img alt=&quot;Schematic diagram of the circuitry that controls the electroluminescent light.&quot; class=&quot;hilite&quot; height=&quot;361&quot; src=&quot;https://static.righto.com/images/globus-electronics/schematic-light-w400.jpg&quot; title=&quot;Schematic diagram of the circuitry that controls the electroluminescent light.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Schematic diagram of the circuitry that controls the electroluminescent light.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;We powered the light with an EL inverter from &lt;a href=&quot;http://adafru.it/448&quot;&gt;Adafruit&lt;/a&gt;, which produces 100 VAC at 2KHz, perhaps.
The spacecraft used a &quot;Static Inverter&quot; to power the light, but I don&#39;t have any details on it.
The display provides a nice blue glow.&lt;/p&gt;
&lt;!--
![The Adafruit inverter. ](inverter.jpg &quot;w300&quot;)
--&gt;

&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/illuminated.jpg&quot;&gt;&lt;img alt=&quot;The landing position indicator, illuminated.&quot; class=&quot;hilite&quot; height=&quot;230&quot; src=&quot;https://static.righto.com/images/globus-electronics/illuminated-w300.jpg&quot; title=&quot;The landing position indicator, illuminated.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The landing position indicator, illuminated.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The potentiometer&lt;/h2&gt;
&lt;p&gt;A 360&amp;deg; potentiometer (below) converts the spacecraft&#39;s orbital position into a resistance. Sources indicate that
the Globus provides this signal to other units on the spacecraft, but I don&#39;t know specifically what
these devices are.
The potentiometer appears to linearly track the spacecraft&#39;s position through the orbital cycle.
Note that this is not the same as the latitude, which oscillates, or the longitude, which is non-linear.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/rheostat.jpg&quot;&gt;&lt;img alt=&quot;The potentiometer converts the orbital position into a voltage.
To the right is the cam that produces the longitude display. Antarctica is visible on the globe.&quot; class=&quot;hilite&quot; height=&quot;351&quot; src=&quot;https://static.righto.com/images/globus-electronics/rheostat-w400.jpg&quot; title=&quot;The potentiometer converts the orbital position into a voltage.
To the right is the cam that produces the longitude display. Antarctica is visible on the globe.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The potentiometer converts the orbital position into a voltage.
To the right is the cam that produces the longitude display. Antarctica is visible on the globe.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;As the schematic below shows, the potentiometer has a resistor on one leg for some reason.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/schematic-pot.jpg&quot;&gt;&lt;img alt=&quot;Schematic diagram of the orbital-position potentiometer.&quot; class=&quot;hilite&quot; height=&quot;206&quot; src=&quot;https://static.righto.com/images/globus-electronics/schematic-pot-w230.jpg&quot; title=&quot;Schematic diagram of the orbital-position potentiometer.&quot; width=&quot;230&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Schematic diagram of the orbital-position potentiometer.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The external connector&lt;/h2&gt;
&lt;p&gt;To connect the Globus to the rest of the spacecraft, the back of the Globus has a 32-pin connector, a standard RS32TV Soviet military design.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/back.jpg&quot;&gt;&lt;img alt=&quot;The back of the Globus, with the connector at the upper left.&quot; class=&quot;hilite&quot; height=&quot;289&quot; src=&quot;https://static.righto.com/images/globus-electronics/back-w400.jpg&quot; title=&quot;The back of the Globus, with the connector at the upper left.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The back of the Globus, with the connector at the upper left.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The connector was wired to nearby 5-pin and 7-pin terminal strips. In the schematics, I label these connectors as
&quot;B&quot; and &quot;A&quot; respectively.
Inconveniently, all the wires to the box&#39;s external connector were cut (the black wires), perhaps to decommission the
unit.
The pinout of the external connector is unknown so we can&#39;t easily reconnect the wires.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-electronics/cut-wires.jpg&quot;&gt;&lt;img alt=&quot;A closeup of the back of the connector showing the cut black wires.&quot; class=&quot;hilite&quot; height=&quot;295&quot; src=&quot;https://static.righto.com/images/globus-electronics/cut-wires-w400.jpg&quot; title=&quot;A closeup of the back of the connector showing the cut black wires.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A closeup of the back of the connector showing the cut black wires.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;By tracing out the wiring of the Globus, I determined its circuitry. 
This was more difficult than expected, since the wiring consists of bundles of identical white wires.
Moreover, many things go through the mode switch, and its terminals were inaccessible.
Between the mode switch and the limit switches, there were many cases to check.&lt;/p&gt;
&lt;p&gt;Once I determined the circuitry, we could power up the Globus. So far, we have powered the solenoids to turn
the Globus. We also illuminated the landing position light. Finally, we ran the landing position motor.&lt;/p&gt;
&lt;p&gt;Follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.
Many thanks to Marcel for providing the Globus.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:ink&quot;&gt;
&lt;p&gt;In Russian, the name for the device is &quot;  &quot; abbreviated as  (INK). This translates to &quot;space navigation indicator.&quot;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:ink&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:flyback&quot;&gt;
&lt;p&gt;Most of the diodes are &lt;a href=&quot;https://en.wikipedia.org/wiki/Flyback_diode&quot;&gt;flyback diodes&lt;/a&gt;, two diodes in series across
each relay coil to eliminate the inductive kick when the coil is disconnected.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:flyback&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/6097486051589556772/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=6097486051589556772' title='3 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/6097486051589556772'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/6097486051589556772'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/03/reverse-engineering-electronics-in.html' title='Reverse-engineering the electronics in the Globus analog navigational computer'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://img.youtube.com/vi/vCogLM-R8FU/default.jpg" height="72" width="72"/><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-5529658376547613898</id><published>2023-02-28T09:55:00.000-08:00</published><updated>2023-02-28T09:55:59.101-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="chips"/><category scheme="http://www.blogger.com/atom/ns#" term="microcode"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>How the 8086 processor determines the length of an instruction</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;
&lt;style&gt;
  pre.microcode {font-family: courier, fixed; padding: 10px; background-color: #f5f5f5; display:inline-block;border:none;}
  pre.microcode span {color: green; font-style:italic; font-family: sans-serif; font-size: 90%;}
&lt;/style&gt;

&lt;p&gt;The Intel 8086 processor (1978) has a complicated instruction set with instructions ranging from one to six bytes long.
This raises the question of how the processor knows the length of an instruction.&lt;span id=&quot;fnref:stackoverflow&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:stackoverflow&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
The answer is that the 8086 uses an interesting combination of lookup ROMs and microcode to determine how many bytes to use for an instruction.
In brief, the ROMs perform enough decoding to figure out if it needs one byte or two.
After that, the microcode simply consumes instruction bytes as it needs them.
Thus, nothing in the chip explicitly &quot;knows&quot; the length of an instruction.
This blog post describes this process in more detail.&lt;/p&gt;
&lt;p&gt;The die photo below shows the chip under a microscope.
I&#39;ve labeled the key functional blocks; the ones that are important to this post are darker.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top and an Execution Unit (EU) below.
The BIU handles bus and memory activity as well as instruction prefetching, while the Execution Unit (EU) executes the instructions.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-length/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;627&quot; src=&quot;https://static.righto.com/images/8086-length/die-labeled-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The prefetch queue, the loader, and the microcode&lt;/h2&gt;
&lt;p&gt;The 8086 uses a 6-byte instruction prefetch queue to hold instructions, and this queue will play an important role in this discussion.&lt;span id=&quot;fnref:8088&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:8088&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
Earlier microprocessors read instructions from memory as they were needed, which could cause the CPU to wait on memory.
The 8086, instead, read instructions from memory before they were needed, storing them in the instruction prefetch queue.
(You can think of this as a primitive instruction cache.)
To execute an instruction, the 8086 took bytes out of the queue one at a time. If the queue ran empty, the processor waited until more
instruction bytes were fetched from memory into the queue.&lt;/p&gt;
&lt;p&gt;A circuit called the loader handles the interaction between the prefetch queue and instruction execution.
The loader is a small state machine that provides control signals to the rest of the execution circuitry.
The loader gets the first byte of an instruction from the prefetch queue and issues a signal FC (First Clock) that starts execution of the instruction.&lt;/p&gt;
&lt;p&gt;At this point, the Group Decode ROM performs the first stage of instruction decoding, classifying the instruction into various categories based
on the opcode byte.
Most of the 8086&#39;s instructions are implemented in microcode.
However, a few instructions are so simple that they are implemented with logic circuits. For example, the &lt;code&gt;CLC&lt;/code&gt; (Clear Carry) instruction
clears the carry flag directly.
The Group Decode ROM categorizes these instructions as 1BL (one-byte, implemented in logic). The loader responds by issuing an SC (Second Clock)
signal to wrap up execution and start the next instruction. Thus, these simple instructions take two clock cycles.&lt;/p&gt;
&lt;p&gt;The 8086 has various prefix bytes that can be put in front of an instruction to change its behavior.
For instance, a segment prefix changes the memory segment that the instruction uses. A &lt;code&gt;LOCK&lt;/code&gt; prefix locks the bus during the next
instruction. The Group Decode ROM detects a prefix and outputs a prefix signal. This causes the prefix to be handled in logic,
rather than microcode, similar to the 1BL instructions.
Thus, a prefix also takes one byte and two clock cycles.&lt;/p&gt;
&lt;p&gt;The remaining instructions are handled by microcode.&lt;span id=&quot;fnref:microcode&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:microcode&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
Let&#39;s start with a one-byte instruction such as &lt;code&gt;INC AX&lt;/code&gt;, which increments the &lt;code&gt;AX&lt;/code&gt; register.
As before, the loader gets the instruction byte from the prefix queue.
The Group Decode ROM determines that this instruction is implemented in microcode and can start after one byte, so the microcode engine starts
running.
The microcode below handles the increment and decrement instructions. It moves the appropriate register, indicated by &lt;code&gt;M&lt;/code&gt; to the ALU&#39;s temporary B
register. 
It puts the incremented or decremented result () back into the register (&lt;code&gt;M&lt;/code&gt;). &lt;code&gt;RNI&lt;/code&gt; tells the loader to run the next instruction.
With two micro-instruction, this instruction takes two clock cycles.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
M  tmpB        XI tmpB, NX &lt;span&gt;&lt;b&gt;INC/DEC&lt;/b&gt;: get value from M, set up ALU&lt;/span&gt;
  M           WB,RNI F     &lt;span&gt;put result in M, run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;But what happens with an instruction that is more than one byte long, such as adding an immediate value to a register?
Let&#39;s look at &lt;code&gt;ADD AX,1234&lt;/code&gt;, which adds 1234 to the AX register.
As before, the loader reads one byte and then the microcode engine starts running.
At this point, the 8086 doesn&#39;t &quot;realize&quot; that this is a 3-byte instruction.
The first line of the microcode below gets one byte of the immediate operand: &lt;code&gt;QtmpBL&lt;/code&gt; loads a byte from the instruction prefetch queue into the low byte of the temporary B
register.
Similarly, the second line loads the second byte. The next line puts the register value (&lt;code&gt;M&lt;/code&gt;) in &lt;code&gt;tmpA&lt;/code&gt;. The last line puts
the sum back into the register and runs the next instruction.
Since this instruction takes two bytes from the prefetch queue, it is three bytes long in total.
But nothing explicitly indicates this instruction is three bytes long.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
Q  tmpBL       JMPS L8 2  &lt;span&gt;&lt;b&gt;alu A,i&lt;/b&gt;: get byte from queue&lt;/span&gt;
Q  tmpBH                   &lt;span&gt;get byte from queue&lt;/span&gt;
M  tmpA        XI tmpA, NX &lt;span&gt;get value from M, set up ALU&lt;/span&gt;
  M           WB,RNI F    &lt;span&gt;put result in M, run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;You can also add a one-byte immediate value to a register, such as &lt;code&gt;ADD AL,12&lt;/code&gt;. This uses the same microcode above. However,
in the first line, &lt;code&gt;JMPS L8&lt;/code&gt; is a conditional jump that skips the second micro-instruction if the data length is 8 bits.
Thus, the microcode only consumes one byte from the prefetch queue, making the instruction two bytes long.
In other words, what makes this instruction two bytes instead of three is the bit in the opcode which triggers the conditional jump in the microcode.&lt;/p&gt;
&lt;p&gt;The 8086 has another class of instructions, those with a ModR/M byte following the opcode.
The Group Decode ROM classifies these instructions as 2BR (two-byte ROM) indicating that the second byte must be fetched before processing by
the microcode ROM.
For these instructions, the loader fetches the second byte from the prefetch queue before triggering the SC (Second Clock signal) to start microcode execution.&lt;/p&gt;
&lt;p&gt;The ModR/M byte indicates the addressing mode that the instruction should use, such as register-to-register or memory-to-register.
The ModR/M can change the instruction length by specifying an address displacement of one or two bytes. 
A second ROM called the Translation ROM selects the appropriate microcode for the addressing mode (&lt;a href=&quot;http://www.righto.com/2023/02/8086-modrm-addressing.html&quot;&gt;details&lt;/a&gt;).
For example, if the addressing mode includes an address displacement, the microcode below is used:&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
Q  tmpBL   JMPS MOD1 12 &lt;span&gt;&lt;b&gt;[i]&lt;/b&gt;: get byte(s)&lt;/span&gt;
Q  tmpBH         
  tmpA    BX EAFINISH &lt;span&gt;&lt;b&gt;12&lt;/b&gt;: add displacement&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;This microcode fetches two displacement bytes from the prefetch queue (&lt;code&gt;Q&lt;/code&gt;).
However, if the ModR/M byte specifies a one-byte displacement, the &lt;code&gt;MOD1&lt;/code&gt; condition causes the microcode to jump over the second
fetch.
Thus, this microcode uses one or two additional instruction bytes depending on the value of the &lt;code&gt;ModR/M&lt;/code&gt; byte.&lt;/p&gt;
&lt;p&gt;To summarize, nothing in the 8086 &quot;knows&quot; how long an instruction is.
The Group Decode ROM makes part of the decision, classifying instructions as a prefix, 1-byte logic, 2-byte ROM, or otherwise, causing the
loader to fetch one or two bytes.
The microcode then consumes instruction bytes as needed.
In the end, the length of an 8086 instruction is determined by how many bytes are taken from the prefetch queue by the time it ends.&lt;/p&gt;
&lt;h2&gt;Some other systems&lt;/h2&gt;
&lt;p&gt;It&#39;s interesting to see how other processors deal with instruction length.
For example, RISC processors (Reduced Instruction Set Computers) typically have fixed-length instructions.
For instance, the ARM-1 processor used 32-bit instructions, making instruction decoding very simple.&lt;/p&gt;
&lt;p&gt;Early microprocessors such as the MOS Technology 6502 (1975) didn&#39;t use microcode, but were controlled by state machines.
The CPU fetches instruction bytes from memory as needed, as it moves through various execution states.
Thus, as with the 8086, the length of an instruction wasn&#39;t explicit, but was how many bytes it used.&lt;/p&gt;
&lt;p&gt;The IBM 1401 computer (1959) took a completely different approach with its variable-length words.
Each character in memory had an associated &quot;word mark&quot; bit, which you can think of as a metadata bit.
Each machine instruction consisted of a variable number of characters with a word mark on the first one.
Thus, the processor could read instruction characters until it hit a word mark, which indicated the start of
the next instruction.
The word mark explicitly indicated to the processor how long each instruction was.&lt;/p&gt;
&lt;p&gt;Perhaps the worst approach for variable-length instructions was the Intel iAPX 432 processor (1981), which had instructions
with variable &lt;em&gt;bit&lt;/em&gt; lengths, from 6 to 321 bits long.
As a result, instructions weren&#39;t aligned on byte boundaries, making instruction decoding even more inconvenient.
This was just one of the reasons that the iAPX 432 ended up overly complicated, years behind schedule, and a commercial failure.&lt;/p&gt;
&lt;!-- https://www.google.com/books/edition/A_Quarter_Century_of_IFIP/BDgQAQAAIAAJ?hl=en&amp;gbpv=1&amp;bsq=iapx+432+%22321+bits%22&amp;dq=iapx+432+%22321+bits%22&amp;printsec=frontcover --&gt;

&lt;p&gt;The 8086&#39;s variable-length instructions led to the x86 architecture, with instructions from 1 to 15 bytes long.
This is particularly inconvenient with modern superscalar processors that run multiple instructions in parallel.
The problem is that the processor must break the instruction stream into individual instructions before they execute.
The Intel P6 microarchitecture used in the Pentium Pro (1995) has instruction decoders to decode the instruction stream into micro-operations.&lt;span id=&quot;fnref:p6&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:p6&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
It starts with an &quot;instruction length block&quot; that analyzes the first bytes of the instruction to determine how long it is.
(This is not a straightforward task to perform rapidly on multiple instructions in parallel.)
The &quot;instruction steering block&quot; uses this information to break the byte stream into instructions and steer instructions to
the decoders.&lt;/p&gt;
&lt;p&gt;The AMD K6 3D processor (1999) had predecode logic that associated 5 predecode bits with each instruction byte: three pointed to
the start of the next instruction, one indicated the length depended on a D bit, and one indicated the presence of a ModR/M byte.
This logic examined up to three bytes to make its decisions.
Instructions were split apart and assigned to decoders based on the predecode bits.
In some cases, the predecode logic gave up and flagged the instruction as &quot;unsuccessfully predecoded&quot;, for instance an instruction longer than 7 bytes.
These instructions were handled by a slower path.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The 8086 processor has instructions with a variety of lengths, but nothing in the processor explicitly determines the length.
Instead, an instruction uses as many bytes as it needs.
(That sounds sort of tautological, but I&#39;m not sure how else to put it.)
The Group Decode ROM makes an initial classification, the Translation ROM determines the addressing mode, and the microcode
consumes bytes as needed.&lt;/p&gt;
&lt;p&gt;While this approach gave the 8086 a flexible instruction set, it created a problem in the long run for the x86 architecture,
requiring complicated logic to determine instruction length.
One benefit of RISC-based processors such as the Apple M1 is that they have (mostly) constant instruction lengths, making instruction
decoding faster and simpler.&lt;/p&gt;
&lt;p&gt;I&#39;ve written multiple &lt;a href=&quot;https://www.righto.com/search/label/8086&quot;&gt;posts on the 8086&lt;/a&gt; so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:stackoverflow&quot;&gt;
&lt;p&gt;I was inspired to investigate instruction length based on a &lt;a href=&quot;https://stackoverflow.com/questions/25101978/how-does-the-cpu-assembler-know-the-size-of-the-next-instruction&quot;&gt;Stack Overflow question&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:stackoverflow&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:microcode&quot;&gt;
&lt;p&gt;I&#39;ll just give a brief overview of microcode here.
Each micro-instruction is 21 bits long, as shown below. A micro-instruction specifies a move between a source register and destination
register. It also has an action that depends on the micro-instruction type.
For more details, see my post on the &lt;a href=&quot;https://www.righto.com/2023/01/the-8086-processors-microcode-pipeline.html&quot;&gt;8086 microcode pipeline&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-length/microcode-format.jpg&quot;&gt;&lt;img alt=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; class=&quot;hilite&quot; height=&quot;203&quot; src=&quot;https://static.righto.com/images/8086-length/microcode-format-w700.jpg&quot; title=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The encoding of a micro-instruction into 21 bits. Based on &lt;a href=&quot;https://digitalcommons.law.scu.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=1031&amp;context=chtlj&quot;&gt;NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- --&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:microcode&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:8088&quot;&gt;
&lt;p&gt;The 8088 processor, used in the original IBM PC, has a smaller 4-byte prefetch queue.
The 8088 is almost the same as the 8086, except it has an 8-bit external bus instead of a 16-bit external bus.
This makes memory accesses (including prefetches) slower, so a smaller prefetch queue works better.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:8088&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:p6&quot;&gt;
&lt;p&gt;The book &lt;a href=&quot;https://amzn.to/3Z6UYE6&quot;&gt;Modern Processor Design&lt;/a&gt; discusses the P6 microarchitecture in detail.
The book &lt;a href=&quot;https://amzn.to/3KE94sr&quot;&gt;The Anatomy of a High-Performance Microprocessor&lt;/a&gt; discusses the AMD K5 3D processor in even
more detail; see chapter 2.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:p6&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/5529658376547613898/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=5529658376547613898' title='5 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/5529658376547613898'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/5529658376547613898'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/02/how-8086-processor-determines-length-of.html' title='How the 8086 processor determines the length of an instruction'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>5</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-8745122849902587790</id><published>2023-02-27T10:20:00.001-08:00</published><updated>2023-04-22T12:19:49.198-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="microcode"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>Reverse-engineering the ModR/M addressing microcode in the Intel 8086 processor</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;
&lt;style&gt;
  pre.microcode {font-family: courier, fixed; padding: 10px; background-color: #f5f5f5; display:inline-block;}
  pre.microcode span {color: green; font-style:italic; font-family: sans-serif; font-size: 90%;}
&lt;/style&gt;

&lt;p&gt;One interesting aspect of a computer&#39;s instruction set is its addressing modes, how the computer determines the
address for a memory access.
The Intel 8086 (1978) used the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ModR/M&quot;&gt;ModR/M&lt;/a&gt; byte, a special byte following the opcode, to select the addressing mode.&lt;span id=&quot;fnref:immediate&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:immediate&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
The ModR/M byte has persisted into the modern x86 architecture, so it&#39;s interesting to look at its roots and original implementation.&lt;/p&gt;
&lt;p&gt;In this post, I look at the hardware and microcode in the 8086 that implements ModR/M&lt;span id=&quot;fnref:modes&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:modes&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
and how the 8086 designers fit multiple addressing modes into the 8086&#39;s limited microcode ROM.
One technique was a hybrid approach that combined generic microcode with hardware logic that filled in the details for a particular instruction.
A second technique was modular microcode, with subroutines for various parts of the task.&lt;/p&gt;
&lt;p&gt;I&#39;ve been reverse-engineering the 8086 starting with the silicon die.
The die photo below shows the chip under a microscope.
The metal layer on top of the chip is visible, with the silicon and polysilicon mostly hidden underneath.
Around the edges of the die, bond wires connect pads to the chip&#39;s 40 external pins.
I&#39;ve labeled the key functional blocks; the ones that are important to this discussion are darker and will be discussed in detail below.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top and an Execution Unit (EU) below.
The BIU handles bus and memory activity as well as instruction prefetching, while the Execution Unit (EU) executes instructions and microcode.
Both units play important roles in memory addressing.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-addressing/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;622&quot; src=&quot;https://static.righto.com/images/8086-addressing/die-labeled-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;8086 addressing modes&lt;/h2&gt;
&lt;p&gt;Let&#39;s start with an addition instruction, &lt;code&gt;ADD&lt;/code&gt; &lt;em&gt;dst&lt;/em&gt;,&lt;em&gt;src&lt;/em&gt;, which adds a source value to a destination value and stores the result in the destination.&lt;span id=&quot;fnref:assembly&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:assembly&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
What are the source and destination? Memory? Registers? The addressing mode answers this question.&lt;/p&gt;
&lt;p&gt;You can use a register as the source and another register as the destination.
The instruction below uses the &lt;code&gt;AX&lt;/code&gt; register as the destination and the &lt;code&gt;BX&lt;/code&gt; register as the source. Thus, it adds &lt;code&gt;BX&lt;/code&gt; to &lt;code&gt;AX&lt;/code&gt; and puts the result
in &lt;code&gt;AX&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
ADD AX, BX           &lt;span&gt;Add the contents of the BX register to the AX register&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;A memory access is indicated with square brackets around the &quot;effective address&quot;&lt;span id=&quot;fnref:effective-address&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:effective-address&quot;&gt;4&lt;/a&gt;&lt;/span&gt; to access.
For instance, &lt;code&gt;[1234]&lt;/code&gt; means the memory location with address 1234,
while &lt;code&gt;[BP]&lt;/code&gt; means the memory location that the &lt;code&gt;BP&lt;/code&gt; register points to.
For a more complicated addressing mode, &lt;code&gt;[BP+SI+1234]&lt;/code&gt; means the memory location is determined by adding the BP and SI registers to the constant 1234 (known as the displacement).
On the 8086, you can use memory for the source or the destination, but not both.
Here are some examples of using memory as a source:&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
ADD AX, [1234]       &lt;span&gt;Add the contents of memory location 1234 to AX register&lt;/span&gt;
ADD CX, [BP]         &lt;span&gt;Add memory pointed to by BP register to CX register&lt;/span&gt;
ADD DX, [BX+SI+1234] &lt;span&gt;Source memory address is BX + SI + constant 1234&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;Here are examples with memory as the destination:&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
ADD [1234], AX       &lt;span&gt;Add AX to the contents of memory location 1234&lt;/span&gt;
ADD [BP], CX         &lt;span&gt;Add CX to memory pointed to by BP register&lt;/span&gt;
ADD [BX+SI+1234], DX &lt;span&gt;Destination memory address is BX + SI + constant 1234&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;You can also operate on bytes instead of words, using a byte register and accessing a memory byte:&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
ADD AL, [SI+1234]    &lt;span&gt;Add to the low byte of AX register&lt;/span&gt;
ADD AH, [BP+DI+1234] &lt;span&gt;Add to the high byte of AX register&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;As you can see, the 8086 supports many different addressing schemes.
To understand how they are implemented, we must first look at how instructions encode the addressing schemes in the ModR/M byte.&lt;/p&gt;
&lt;h2&gt;The ModR/M byte&lt;/h2&gt;
&lt;p&gt;The ModR/M byte follows many opcodes to specify the addressing mode.
This byte is fairly complicated but I&#39;ll try to explain it in this section.
The diagram below shows how the byte is split into three fields:&lt;span id=&quot;fnref:octal&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:octal&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
&lt;code&gt;mod&lt;/code&gt; selects the overall mode, &lt;code&gt;reg&lt;/code&gt; selects a register, and &lt;code&gt;r/m&lt;/code&gt; selects either a register or memory mode.&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
table.modrm {border-collapse:collapse; border: 2px solid #999; padding: 5px;}
table.modrm th {border: 2px solid #999;}
table.modrm th,td {padding: 2px 9px;}
table.modrm td {border-left: 2px solid #999;}
table.modrm .bl {border-left: 3px solid #999;}
table.modrm .c {text-align: center;}
table.modrm .r {color: red;}
table.modrm .g {color: green;}
table.modrm .b {color: blue;}
&lt;/style&gt;

&lt;table class=&quot;modrm&quot;&gt;
&lt;tr&gt;&lt;th class=&quot;r&quot; colspan=2&gt;mod&lt;/th&gt;&lt;th class=&quot;g&quot; colspan=3&gt;reg&lt;/th&gt;&lt;th class=&quot;b&quot; colspan=3&gt;r/m&lt;/th&gt;&lt;tr&gt;
&lt;tr&gt;&lt;td class=&quot;r&quot;&gt;7&lt;/td&gt;&lt;td class=&quot;r&quot;&gt;6&lt;/td&gt;&lt;td class=&quot;g&quot;&gt;5&lt;/td&gt;&lt;td class=&quot;g&quot;&gt;4&lt;/td&gt;&lt;td class=&quot;g&quot;&gt;3&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;2&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;1&lt;/td&gt;&lt;td class=&quot;b&quot;&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;I&#39;ll start with the register-register mode, where the &lt;code&gt;mod&lt;/code&gt; bits are &lt;span style=&quot;color:red&quot;&gt;11&lt;/span&gt; and the &lt;code&gt;reg&lt;/code&gt; and &lt;code&gt;r/m&lt;/code&gt; fields each select one of eight registers, as shown below.
The instruction &lt;code&gt;ADD AX,BX&lt;/code&gt; would use &lt;code&gt;reg&lt;/code&gt;=&lt;span style=&quot;color:green&quot;&gt;011&lt;/span&gt; to select &lt;code&gt;BX&lt;/code&gt; and &lt;code&gt;r/m&lt;/code&gt;=&lt;span style=&quot;color:blue&quot;&gt;000&lt;/span&gt; to select &lt;code&gt;AX&lt;/code&gt;, so the ModR/M byte would be
&lt;span style=&quot;color:red&quot;&gt;11&lt;/span/g&gt;&lt;span style=&quot;color:green&quot;&gt;011&lt;/span/g&gt;&lt;span style=&quot;color:blue&quot;&gt;000&lt;/span/g&gt;.
(The register assignment depends on whether the instruction operates on words, bytes, or segment registers.
For instance, in a word instruction, &lt;code&gt;001&lt;/code&gt; selects the &lt;code&gt;CX&lt;/code&gt; register, while in a byte instruction, &lt;code&gt;001&lt;/code&gt; selects the &lt;code&gt;CL&lt;/code&gt; register, the low byte of &lt;code&gt;CX&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-addressing/reg-assignments.jpg&quot;&gt;&lt;img alt=&quot;The register assignments, from MCS-86 Assembly Language Reference Guide.&quot; class=&quot;hilite&quot; height=&quot;189&quot; src=&quot;https://static.righto.com/images/8086-addressing/reg-assignments-w400.jpg&quot; title=&quot;The register assignments, from MCS-86 Assembly Language Reference Guide.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The register assignments, from &lt;a href=&quot;http://bitsavers.org/components/intel/8086/9800749-1_MCS-86_Assembly_Language_Reference_Guide_Oct78.pdf&quot;&gt;MCS-86 Assembly Language Reference Guide&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The next addressing mode specifies a memory argument and a register argument. In this case, the &lt;code&gt;mod&lt;/code&gt; bits are &lt;span style=&quot;color:red&quot;&gt;00&lt;/span&gt;, the &lt;code&gt;reg&lt;/code&gt; field specifies a
register as described above, and the &lt;code&gt;r/m&lt;/code&gt; field specifies a memory address according to the table below.
For example, the instruction &lt;code&gt;ADD [SI],CX&lt;/code&gt; would use &lt;code&gt;reg&lt;/code&gt;=&lt;span style=&quot;color:green&quot;&gt;001&lt;/span&gt; to select &lt;code&gt;CX&lt;/code&gt; and &lt;code&gt;r/m&lt;/code&gt;=&lt;span style=&quot;color:blue&quot;&gt;100&lt;/span&gt; to select &lt;code&gt;[SI]&lt;/code&gt;, so the ModR/M byte would be
&lt;span style=&quot;color:red&quot;&gt;00&lt;/span/g&gt;&lt;span style=&quot;color:green&quot;&gt;001&lt;/span/g&gt;&lt;span style=&quot;color:blue&quot;&gt;100&lt;/span/g&gt;.&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
table.rm td:first-child {color:blue}
table.rm td:nth-child(2) {padding-left: 2em;}
&lt;/style&gt;
&lt;table class=&quot;modrm rm&quot;&gt;
&lt;tr&gt;&lt;th&gt;r/m&lt;/th&gt;&lt;th&gt;Operand Address&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;000&lt;/td&gt;&lt;td&gt;[BX+SI]&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;001&lt;/td&gt;&lt;td&gt;[BX+DI]&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;010&lt;/td&gt;&lt;td&gt;[BP+SI]&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;011&lt;/td&gt;&lt;td&gt;[BP+DI]&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;100&lt;/td&gt;&lt;td&gt;[SI]&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;101&lt;/td&gt;&lt;td&gt;[DI]&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;110&lt;/td&gt;&lt;td&gt;[BP]&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;111&lt;/td&gt;&lt;td&gt;[BX]&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;The next mode, &lt;span style=&quot;color:red&quot;&gt;01&lt;/span&gt;, adds an 8-bit signed displacement to the address. This displacement consists of one byte
following the ModR/M byte. This supports addressing modes such as &lt;code&gt;[BP+5]&lt;/code&gt;.
The mode &lt;span style=&quot;color:red&quot;&gt;10&lt;/span&gt; is similar except the displacement is two bytes long,
for addressing modes such as &lt;code&gt;[BP+DI+0x1234]&lt;/code&gt;.&lt;/p&gt;
&lt;!--

![A summary of the ModR/M byte, from &lt;a href=&quot;http://bitsavers.org/components/intel/8086/9800749-1_MCS-86_Assembly_Language_Reference_Guide_Oct78.pdf&quot;&gt;MCS-86 Assembly Language Reference Guide&lt;/a&gt;.](modrm.jpg &quot;w500&quot;)



The diagram below summarizes the ModR/M byte.

&lt;table class=&quot;modrm&quot;&gt;
&lt;tr&gt;&lt;th style=&quot;vertical-align:bottom&quot; rowspan=2&gt;r/m&lt;/th&gt;&lt;th class=&quot;bl&quot; colspan=3&gt;Effective Address&lt;/th&gt;&lt;th colspan=2 class=&quot;bl&quot;&gt;Register, mod=11&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th class=&quot;bl&quot;&gt;mod=00&lt;/th&gt;&lt;th&gt;mod=01&lt;/th&gt;&lt;th&gt;mod=10&lt;/th&gt;&lt;th class=&quot;bl&quot;&gt;W=0&lt;/th&gt;&lt;th&gt;W=1&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;000&lt;/td&gt;&lt;td class=&quot;bl&quot;&gt;(BX)+(SI)&lt;/td&gt;&lt;td&gt;(BX)+(SI)+d8&lt;/td&gt;&lt;td&gt;(BX)+(SI)+d16&lt;/td&gt;&lt;td class=&quot;bl c&quot;&gt;AL&lt;/td&gt;&lt;td class=&quot;c&quot;&gt;AX&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;001&lt;/td&gt;&lt;td class=&quot;bl&quot;&gt;(BX)+(DI)&lt;/td&gt;&lt;td&gt;(BX)+(DI)+d8&lt;/td&gt;&lt;td&gt;(BX)+(DI)+d16&lt;/td&gt;&lt;td class=&quot;bl c&quot;&gt;CL&lt;/td&gt;&lt;td class=&quot;c&quot;&gt;CX&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;010&lt;/td&gt;&lt;td class=&quot;bl&quot;&gt;(BP)+(SI)&lt;/td&gt;&lt;td&gt;(BP)+(SI)+d8&lt;/td&gt;&lt;td&gt;(BP)+(SI)+d16&lt;/td&gt;&lt;td class=&quot;bl c&quot;&gt;DL&lt;/td&gt;&lt;td class=&quot;c&quot;&gt;DX&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;011&lt;/td&gt;&lt;td class=&quot;bl&quot;&gt;(BP)+(DI)&lt;/td&gt;&lt;td&gt;(BP)+(DI)+d8&lt;/td&gt;&lt;td&gt;(BP)+(DI)+d16&lt;/td&gt;&lt;td class=&quot;bl c&quot;&gt;BL&lt;/td&gt;&lt;td class=&quot;c&quot;&gt;BX&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;100&lt;/td&gt;&lt;td class=&quot;bl&quot;&gt;(SI)&lt;/td&gt;&lt;td&gt;(SI)+d8&lt;/td&gt;&lt;td&gt;(SI)+d16&lt;/td&gt;&lt;td class=&quot;bl c&quot;&gt;AH&lt;/td&gt;&lt;td class=&quot;c&quot;&gt;SP&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;101&lt;/td&gt;&lt;td class=&quot;bl&quot;&gt;(DI)&lt;/td&gt;&lt;td&gt;(DI)+d8&lt;/td&gt;&lt;td&gt;(DI)+d16&lt;/td&gt;&lt;td class=&quot;bl c&quot;&gt;CH&lt;/td&gt;&lt;td class=&quot;c&quot;&gt;BP&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;110&lt;/td&gt;&lt;td class=&quot;bl&quot;&gt;direct access&lt;/td&gt;&lt;td&gt;(BP)+d8&lt;/td&gt;&lt;td&gt;(BP)+d16&lt;/td&gt;&lt;td class=&quot;bl c&quot;&gt;DH&lt;/td&gt;&lt;td class=&quot;c&quot;&gt;SI&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;111&lt;/td&gt;&lt;td class=&quot;bl&quot;&gt;(BX)&lt;/td&gt;&lt;td&gt;(BX)+d8&lt;/td&gt;&lt;td&gt;(BX)+d16&lt;/td&gt;&lt;td class=&quot;bl c&quot;&gt;BH&lt;/td&gt;&lt;td class=&quot;c&quot;&gt;DI&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
--&gt;

&lt;p&gt;The table below shows the meaning of all 256 values for the ModR/M byte.
The &lt;code&gt;mod&lt;/code&gt; bits are colored red, the &lt;code&gt;reg&lt;/code&gt; bits green, and the &lt;code&gt;r/m&lt;/code&gt; bits blue.
Note the special case &quot;disp16&quot; to support a 16-bit fixed address.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-addressing/modrm.png&quot;&gt;&lt;img alt=&quot;The ModR/M values. Note that this table would be trivial if it used octal rather than hexadecimal. Based on Table 6-13 in the ASM386 Assembly Language Reference.&quot; class=&quot;hilite&quot; height=&quot;619&quot; src=&quot;https://static.righto.com/images/8086-addressing/modrm-w600.png&quot; title=&quot;The ModR/M values. Note that this table would be trivial if it used octal rather than hexadecimal. Based on Table 6-13 in the ASM386 Assembly Language Reference.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The ModR/M values. Note that this table would be trivial if it used octal rather than hexadecimal. Based on Table 6-13 in the &lt;a href=&quot;http://bitsavers.org/pdf/intel/iRMX/iRMX_III/iRMX_III_V2.2/469165-003_ASM386_Assembly_Language_Reference_1995.pdf&quot;&gt;ASM386 Assembly Language Reference&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The register combinations for memory accesses may seem random but they were designed to support the needs of high-level
languages, such as arrays and data structures.
The idea is to add a base register, an index register, and/or a fixed displacement to determine the address.&lt;span id=&quot;fnref:system360&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:system360&quot;&gt;6&lt;/a&gt;&lt;/span&gt;
The base register can indicate the start of an array, the index register holds the offset in the array, and the displacement provides the
offset of a field in the array entry.
The base register is &lt;code&gt;BX&lt;/code&gt; for data or &lt;code&gt;BP&lt;/code&gt; for information on the stack.
The index registers are &lt;code&gt;SI&lt;/code&gt; (Source Index) and &lt;code&gt;DI&lt;/code&gt; (Destination Index).&lt;span id=&quot;fnref:modrm&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:modrm&quot;&gt;7&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Some addressing features are handled by the opcode, not the ModR/M byte.
For instance, the ModR/M byte doesn&#39;t distinguish between
&lt;code&gt;ADD AX,[SI]&lt;/code&gt; and &lt;code&gt;ADD [SI],AX&lt;/code&gt;.
Instead, the two
variants are distinguished by bit 1 of the instruction, the &lt;code&gt;D&lt;/code&gt; or &quot;direction&quot; bit.&lt;span id=&quot;fnref:destination&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:destination&quot;&gt;8&lt;/a&gt;&lt;/span&gt;
Moreover, many instructions have one opcode that operates on words and another that operates on bytes, distinguished by bit 0 of
the opcode, the &lt;code&gt;W&lt;/code&gt; or word bit.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;D&lt;/code&gt; and &lt;code&gt;W&lt;/code&gt; bits are an example of orthogonality in the 8086 instruction set,
allowing features to be combined in various combinations.
For instance, the addressing modes combine 8 types of offset computation with three sizes of displacements and 8 target registers.
Arithmetic instructions combine these addressing modes with eight ALU operations,
each of which can act on a byte or a word, with two possible memory directions.
All of these combinations are implemented with one block of microcode, implementing a large instruction set with a small amount of microcode.
(The orthogonality of the 8086 shouldn&#39;t be overstated, though; it has many special cases and things that don&#39;t quite fit.)&lt;/p&gt;
&lt;h2&gt;An overview of 8086 microcode&lt;/h2&gt;
&lt;p&gt;Most people think of machine instructions as the basic steps that a computer performs.
However, many processors (including the 8086) have another layer of software underneath: microcode.
With microcode, instead of building the control circuitry from complex logic gates, the control logic is largely replaced with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.&lt;/p&gt;
&lt;p&gt;The 8086 uses a hybrid approach: although it uses microcode, much of the instruction functionality is implemented with gate logic.
This approach removed duplication from the microcode and kept the microcode small enough for 1978 technology.
In a sense, the microcode is parameterized.
For instance, the microcode can specify a generic Arithmetic/Logic Unit (ALU) operation and a generic register.
The gate logic examines the instruction to determine which specific operation to perform and the appropriate register.&lt;/p&gt;
&lt;p&gt;A micro-instruction in the 8086 is encoded into 21 bits as shown below.
Every micro-instruction has a move from a source register to a destination register, each specified with 5 bits.
The meaning of the remaining bits depends on the type field.
A &quot;short jump&quot; is a conditional jump within the current block of 16 micro-instructions.
An ALU operation sets up the arithmetic-logic unit to perform an operation.
Bookkeeping operations are anything from flushing the prefetch queue to ending the current instruction.
A memory operation triggers a bus cycle to read or write memory.
A &quot;long jump&quot; is a conditional jump to any of 16 fixed microcode locations (specified in an external table called the Translation ROM).
Finally, a &quot;long call&quot; is a conditional subroutine call to one of 16 locations.
For more about 8086 microcode, see my &lt;a href=&quot;https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html&quot;&gt;microcode blog post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-addressing/microcode-format.jpg&quot;&gt;&lt;img alt=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; class=&quot;hilite&quot; height=&quot;203&quot; src=&quot;https://static.righto.com/images/8086-addressing/microcode-format-w700.jpg&quot; title=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The encoding of a micro-instruction into 21 bits. Based on &lt;a href=&quot;https://digitalcommons.law.scu.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=1031&amp;context=chtlj&quot;&gt;NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Some examples of microcode for addressing&lt;/h2&gt;
&lt;p&gt;In this section, I&#39;ll take a close look at a few addressing modes and how they are implemented in microcode.
In the next section, I&#39;ll summarize all the microcode for addressing modes.&lt;/p&gt;
&lt;h3&gt;A register-register operation&lt;/h3&gt;
&lt;p&gt;Let&#39;s start by looking at a register-to-register instruction, before we get into the complications of memory accesses: &lt;code&gt;ADD BX,AX&lt;/code&gt; which adds &lt;code&gt;AX&lt;/code&gt; to &lt;code&gt;BX&lt;/code&gt;, storing the result in &lt;code&gt;BX&lt;/code&gt;.  This instruction has the opcode value 01 and ModR/M value C3 (hex). &lt;/p&gt;
&lt;p&gt;Before the microcode starts, the hardware performs some decoding of the opcode.
The Group Decode ROM (below) classifies an instruction into multiple categories:
this instruction contains a D bit, a W bit, and an ALU operation, and has a ModR/M byte.
Fields from the opcode and ModR/M bytes are extracted and stored in various internal registers.
The ALU operation type (&lt;code&gt;ADD&lt;/code&gt;) is stored in the &lt;code&gt;ALU opr&lt;/code&gt; register.
From the ModR/M byte,
the &lt;code&gt;reg&lt;/code&gt; register code (&lt;code&gt;AX&lt;/code&gt;) is stored in the &lt;code&gt;N&lt;/code&gt; register, and the &lt;code&gt;r/m&lt;/code&gt; register code
(&lt;code&gt;BX&lt;/code&gt;) is stored in the &lt;code&gt;M&lt;/code&gt; register.
(The &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; registers are internal registers that are invisible to the programmer; each holds a 5-bit register code that specifies a register.&lt;span id=&quot;fnref:mn&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:mn&quot;&gt;9&lt;/a&gt;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-addressing/group-decode-rom.jpg&quot;&gt;&lt;img alt=&quot;This diagram shows the Group Decode ROM. The Group Decode ROM is more of a PLA (programmable logic array) with two layers of NOR gates. Its input lines are at the lower left and its outputs are at the upper right.&quot; class=&quot;hilite&quot; height=&quot;482&quot; src=&quot;https://static.righto.com/images/8086-addressing/group-decode-rom-w500.jpg&quot; title=&quot;This diagram shows the Group Decode ROM. The Group Decode ROM is more of a PLA (programmable logic array) with two layers of NOR gates. Its input lines are at the lower left and its outputs are at the upper right.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This diagram shows the Group Decode ROM. The Group Decode ROM is more of a PLA (programmable logic array) with two layers of NOR gates. Its input lines are at the lower left and its outputs are at the upper right.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Once the preliminary decoding is done, the microcode below for this ALU instruction is executed.&lt;span id=&quot;fnref:microcode&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:microcode&quot;&gt;10&lt;/a&gt;&lt;/span&gt;
(There are three micro-instructions, so the instruction takes three clock cycles.)
Each micro-instruction contains a move and an action.
First, the register specified by &lt;code&gt;M&lt;/code&gt; (i.e. &lt;code&gt;BX&lt;/code&gt;) is moved to the ALU&#39;s temporary A register (&lt;code&gt;tmpA&lt;/code&gt;).
Meanwhile, the ALU is configured to perform the appropriate operation on &lt;code&gt;tmpA&lt;/code&gt;; &lt;code&gt;XI&lt;/code&gt; indicates that the ALU operation is specified by the instruction bits, i.e. &lt;code&gt;ADD&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;The second instruction moves the register specified by &lt;code&gt;N&lt;/code&gt; (i.e. &lt;code&gt;AX&lt;/code&gt;) to the ALU&#39;s &lt;code&gt;tmpB&lt;/code&gt; register.
The action &lt;code&gt;NX&lt;/code&gt; indicates that this is the next-to-last micro-instruction so
the microcode engine can start processing the next machine instruction.
The last micro-instruction stores the ALU&#39;s result (&lt;code&gt;&lt;/code&gt;) in the register indicated by &lt;code&gt;M&lt;/code&gt; (i.e. &lt;code&gt;BX&lt;/code&gt;).
The status flags are updated because of the &lt;code&gt;F&lt;/code&gt;.
&lt;code&gt;WB,RNI&lt;/code&gt; (Run Next Instruction) indicates that this is the end and the microcode engine can process the next machine instruction.
The &lt;code&gt;WB&lt;/code&gt; prefix would skip the actions if a memory writeback were pending (which is not the case).&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
  move       action
M  tmpA     XI tmpA   &lt;span&gt;&lt;b&gt;ALU rmr&lt;/b&gt;: BX to tmpA&lt;/span&gt;
N  tmpB     WB,NX      &lt;span&gt;AX to tmpB&lt;/span&gt;
  M        WB,RNI F   &lt;span&gt;result to BX, run next instruction.&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;This microcode packs a lot into three micro-instructions.
Note that it is very generic: the microcode doesn&#39;t know what ALU operation is being performed or which registers are being used.
Instead, the microcode deals with abstract registers and operations, while the hardware fills in the details using bits from the instructions.
The same microcode is used for eight different ALU operations. And as we&#39;ll see, it supports multiple addressing modes.&lt;/p&gt;
&lt;h3&gt;Using memory as the destination&lt;/h3&gt;
&lt;p&gt;Memory operations on the 8086 involve both microcode and hardware.
A memory operation uses two internal registers: &lt;code&gt;IND&lt;/code&gt; (Indirect) holds the memory address, while &lt;code&gt;OPR&lt;/code&gt; (Operand) holds the word that is read or written.
A typical memory micro-instruction is &lt;code&gt;R DS,P0&lt;/code&gt;, which starts a read from the Data Segment
with a &quot;Plus 0&quot; on the &lt;code&gt;IND&lt;/code&gt; register afterward. The Bus Interface Unit carries out this operation by adding the segment register
to compute the physical address, and then running the memory bus cycles.&lt;/p&gt;
&lt;p&gt;With that background, let&#39;s look at the instruction &lt;code&gt;ADD [SI],AX&lt;/code&gt;, which adds &lt;code&gt;AX&lt;/code&gt; to the memory location indexed by &lt;code&gt;SI&lt;/code&gt;.
As before, the hardware performs some analysis of the instruction (hex 01 04).
In the ModR/M byte, mod=00 (memory, no displacement), reg=000 (AX), and R/M=100 ([SI]).
The &lt;code&gt;N&lt;/code&gt; register is loaded with the code for &lt;code&gt;AX&lt;/code&gt; as before.
The &lt;code&gt;M&lt;/code&gt; register, however, is loaded with &lt;code&gt;OPR&lt;/code&gt; (the memory data register) since the Group Decode ROM determines that the instruction has a memory addressing mode.&lt;/p&gt;
&lt;p&gt;The microcode below starts in an effective address microcode subroutine for the &lt;code&gt;[SI]&lt;/code&gt; mode.
The first line of the microcode subroutine computes the effective address simply by loading the &lt;code&gt;tmpA&lt;/code&gt; register with &lt;code&gt;SI&lt;/code&gt;. It jumps to the micro-routine &lt;code&gt;EAOFFSET&lt;/code&gt; which ends up at &lt;code&gt;EALOAD&lt;/code&gt; (for reasons that will be described below), which loads the value from memory.
Specifically, &lt;code&gt;EALOAD&lt;/code&gt; puts the address in &lt;code&gt;IND&lt;/code&gt;, reads the value from memory, puts the value into &lt;code&gt;tmpB&lt;/code&gt;, and returns from the subroutine.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
SI  tmpA   JMP EAOFFSET &lt;span&gt;&lt;b&gt;[SI]&lt;/b&gt;: put SI in tmpA&lt;/span&gt;
tmpA  IND  R DS,P0      &lt;span&gt;&lt;b&gt;EALOAD&lt;/b&gt;: read memory&lt;/b&gt;&lt;/span&gt;
OPR  tmpB  RTN  
M  tmpA    XI tmpA      &lt;span&gt;&lt;b&gt;ALU rmr&lt;/b&gt;: OPR to tmpA&lt;/span&gt;
N  tmpB    WB,NX         &lt;span&gt;AX to tmpB&lt;/span&gt;
  M       WB,RNI F      &lt;span&gt;result to BX, run next instruction.&lt;/span&gt;
            W DS,P0 RNI   &lt;span&gt;writes result to memory&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;Microcode execution continues with the &lt;code&gt;ALU rmr&lt;/code&gt; routine described above, but with a few differences.
The &lt;code&gt;M&lt;/code&gt; register indicates &lt;code&gt;OPR&lt;/code&gt;, so the value read from memory is put into &lt;code&gt;tmpA&lt;/code&gt;.
As before, the &lt;code&gt;N&lt;/code&gt; register specifies &lt;code&gt;AX&lt;/code&gt;, so that register is put into &lt;code&gt;tmpB&lt;/code&gt;.
In this case, the &lt;code&gt;WB,NX&lt;/code&gt; determines that the result will be written back to memory so it skips the &lt;code&gt;NXT&lt;/code&gt; operation.
The ALU&#39;s result (&lt;code&gt;&lt;/code&gt;) is stored in &lt;code&gt;OPR&lt;/code&gt; as directed by &lt;code&gt;M&lt;/code&gt;.
The &lt;code&gt;WB,RNI&lt;/code&gt; is skipped so microcode execution continues.
The &lt;code&gt;W DS,P0&lt;/code&gt; micro-instruction writes the result (in &lt;code&gt;OPR&lt;/code&gt;) to the memory address in &lt;code&gt;IND&lt;/code&gt;.
At this point, &lt;code&gt;RNI&lt;/code&gt; terminates the microcode sequence.&lt;/p&gt;
&lt;p&gt;A lot is going on here to add two numbers!  The main point is that the same microcode runs as in the register case, but the results are different due to
the &lt;code&gt;M&lt;/code&gt; register and the conditional &lt;code&gt;WB&lt;/code&gt; code.
By running different subroutines, different effective address computations can be performed.&lt;/p&gt;
&lt;!--
instruction 01 04 
D bit is 0 so store in R/M field (memory)
M is OPR
N is AX

M and N are swapped if D bit is 1.
--&gt;

&lt;h3&gt;Using memory as the source&lt;/h3&gt;
&lt;p&gt;Now let&#39;s look at how the microcode uses memory as a source, as in the instruction &lt;code&gt;ADD AX,[SI]&lt;/code&gt;.
This instruction (hex 03 04) has the same
ModR/M byte as before, so the &lt;code&gt;N&lt;/code&gt; register holds &lt;code&gt;AX&lt;/code&gt; and the &lt;code&gt;M&lt;/code&gt; register holds &lt;code&gt;OPR&lt;/code&gt;.
However, because the opcode has the D bit set, the &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; registers are swapped when accessed.
Thus, when the microcode uses &lt;code&gt;M&lt;/code&gt;, it gets the value &lt;code&gt;AX&lt;/code&gt; from &lt;code&gt;N&lt;/code&gt;, and vice versa. (Yes, this is confusing.)&lt;/p&gt;
&lt;p&gt;The microcode starts the same as the previous example, reading &lt;code&gt;[SI]&lt;/code&gt; into &lt;code&gt;tmpB&lt;/code&gt; and returning to the ALU code.
However, since the meaning of &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are reversed, the AX value goes into &lt;code&gt;tmpA&lt;/code&gt; while the memory value goes into &lt;code&gt;tmpB&lt;/code&gt;.
(This switch doesn&#39;t matter for addition, but would matter for subtraction.)
An important difference is that there is no writeback to memory, so &lt;code&gt;WB,NX&lt;/code&gt; starts processing the next machine instruction.
In the last micro-instruction, the result is written to &lt;code&gt;M&lt;/code&gt;, indicating the &lt;code&gt;AX&lt;/code&gt; register. Finally, &lt;code&gt;WB,RNI&lt;/code&gt; runs the next machine instruction.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
SI  tmpA   JMP EAOFFSET &lt;span&gt;&lt;b&gt;[SI]&lt;/b&gt;: put SI in tmpA&lt;/span&gt;
tmpA  IND  R DS,P0      &lt;span&gt;&lt;b&gt;EALOAD: read memory&lt;/b&gt;&lt;/span&gt;
OPR  tmpB  RTN  
M  tmpA    XI tmpA      &lt;span&gt;&lt;b&gt;ALU rmr&lt;/b&gt;: AX to tmpA&lt;/span&gt;
N  tmpB    WB,NX         &lt;span&gt;OPR to tmpB&lt;/span&gt;
  M       WB,RNI F      &lt;span&gt;result to AX, run next instruction.&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;The main point is that the same microcode handles memory as a source and a destination, simply by setting the &lt;code&gt;D&lt;/code&gt; bit.
First, the &lt;code&gt;D&lt;/code&gt; bit reverses the operands by swapping &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt;.
Second, the &lt;code&gt;WB&lt;/code&gt; conditionals prevent the writeback to memory that happened in the previous case.&lt;/p&gt;
&lt;!--
(instruction 03 04).
mod = 00, reg = 000(AX), r/m = 04 [SI], D bit = 1
D bit is 1 so store in reg field
M is 00110 OPR from ?
N is 11000 AX from middle bits (reg field)
M-&gt;tmpA uses AX (N)
S-&gt;tmpB uses OPR
sigma-&gt;M uses AX (N)
--&gt;

&lt;!--
&amp;mdash;
Now look at 01 C1 ADD CX, AX
M = 11001 CX from R/M (end bits): this is used for M and is the destination
N = 11000 AX from reg (middle bits)

&amp;mdash;
With D bit set, look at 03 C8. This is also ADD CX, AX but the registers and the destination are reversed.
M = 11000 AX from end bits: this is used for N and is the source
N = 11001 CX from middle bits: this is used for M and is the destination
The W DS,P0 is skipped
--&gt;

&lt;h3&gt;Using a displacement&lt;/h3&gt;
&lt;p&gt;The memory addressing modes optionally support a signed displacement of one or two bytes.
Let&#39;s look at the instruction &lt;code&gt;ADD AX,[SI+0x1234]&lt;/code&gt;.
In hex, this instruction is 03 84 34 12, where the last two bytes are the displacement, reversed because the 8086 uses little-endian numbers.
The mod bits are 10, indicating a 16-bit displacement, but the other bits are the same as in the previous example.&lt;/p&gt;
&lt;p&gt;Microcode execution again starts with the &lt;code&gt;[SI]&lt;/code&gt; subroutine.
However, the jump to &lt;code&gt;EAOFFSET&lt;/code&gt; goes to &lt;code&gt;[i]&lt;/code&gt; this time, to handle the displacement offset. (I&#39;ll explain how, shortly.)
This code loads the offset as two bytes from the instruction prefetch queue (&lt;code&gt;Q&lt;/code&gt;) into the &lt;code&gt;tmpB&lt;/code&gt; register.
It adds the offset to the previous address in &lt;code&gt;tmpA&lt;/code&gt; and puts the sum  in &lt;code&gt;tmpA&lt;/code&gt;, computing the effective address. Then it jumps to &lt;code&gt;EAFINISH&lt;/code&gt; (&lt;code&gt;EALOAD&lt;/code&gt;).
From there, the code continues as earlier, reading an argument from memory and computing the sum.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
SI  tmpA   JMP EAOFFSET &lt;span&gt;&lt;b&gt;[SI]&lt;/b&gt;: put SI in tmpA&lt;/span&gt;
Q  tmpBL   JMPS MOD1 12 &lt;span&gt;&lt;b&gt;[i]&lt;/b&gt;: load from queue, conditional jump&lt;/span&gt;
Q  tmpBH     
  tmpA    JMP EAFINISH &lt;span&gt;&lt;b&gt;12&lt;/b&gt;:&lt;/span&gt;
tmpA  IND  R DS,P0      &lt;span&gt;&lt;b&gt;EALOAD: read memory&lt;/b&gt;&lt;/span&gt;
OPR  tmpB  RTN  
M  tmpA    XI tmpA      &lt;span&gt;&lt;b&gt;ALU rmr&lt;/b&gt;: AX to tmpA&lt;/span&gt;
N  tmpB    WB,NX         &lt;span&gt;OPR to tmpB&lt;/span&gt;
  M       WB,RNI F      &lt;span&gt;result to AX, run next instruction.&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;For the one-byte displacement case,
the conditional &lt;code&gt;MOD1&lt;/code&gt; will jump over the fetch of the second displacement byte.
When the first byte is loaded into the low byte of &lt;code&gt;tmpB&lt;/code&gt;, it was sign-extended into the high byte.&lt;span id=&quot;fnref:sign&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:sign&quot;&gt;14&lt;/a&gt;&lt;/span&gt;
Thus, the one-byte displacement case uses the same microcode but ends up with a sign-extended 1-byte displacement in &lt;code&gt;tmpB&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;The Translation ROM&lt;/h2&gt;
&lt;p&gt;Now let&#39;s take a closer look at the jumps to &lt;code&gt;EAOFFSET&lt;/code&gt;, &lt;code&gt;EAFINISH&lt;/code&gt;, and the effective address subroutines, which use something called the Translation ROM.
The Translation ROM converts the 5-bit jump tag in a micro-instruction into a 13-bit microcode address.
It also provides the addresses of the effective address subroutines.
As will be seen below, there are some complications.&lt;span id=&quot;fnref:translation-pla&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:translation-pla&quot;&gt;11&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-addressing/translation-rom.jpg&quot;&gt;&lt;img alt=&quot;The Translation ROM as it appears on the die. The metal layer has been removed to expose the silicon and polysilicon underneath. The left half decodes the inputs to select a row. The right half outputs the corresponding microcode address.&quot; class=&quot;hilite&quot; height=&quot;636&quot; src=&quot;https://static.righto.com/images/8086-addressing/translation-rom-w350.jpg&quot; title=&quot;The Translation ROM as it appears on the die. The metal layer has been removed to expose the silicon and polysilicon underneath. The left half decodes the inputs to select a row. The right half outputs the corresponding microcode address.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Translation ROM as it appears on the die. The metal layer has been removed to expose the silicon and polysilicon underneath. The left half decodes the inputs to select a row. The right half outputs the corresponding microcode address.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The effective address micro-routines&lt;/h2&gt;
&lt;h3&gt;Register calculations&lt;/h3&gt;
&lt;p&gt;The Translation ROM has an entry for the addressing mode calculations such as &lt;code&gt;[SI]&lt;/code&gt; and &lt;code&gt;[BP+DI]&lt;/code&gt;, generally indicated by the &lt;code&gt;r/m&lt;/code&gt; bits,
the three low bits of the ModR/M byte.
Each routine computes the effective address and puts it into the ALU&#39;s temporary A register and jumps to &lt;code&gt;EAOFFSET&lt;/code&gt;, which adds any
displacement offset.
The microcode below shows the four simplest effective address calculations, which just load the appropriate register into &lt;code&gt;tmpA&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
SI  tmpA   JMP EAOFFSET   &lt;span&gt;&lt;b&gt;[SI]&lt;/b&gt;: load SI into tmpA&lt;/span&gt;
DI  tmpA   JMP EAOFFSET   &lt;span&gt;&lt;b&gt;[DI]&lt;/b&gt;: load SI into tmpA&lt;/span&gt;
BP  tmpA   JMP EAOFFSET   &lt;span&gt;&lt;b&gt;[BP]&lt;/b&gt;: load BP into tmpA&lt;/span&gt;
BX  tmpA   JMP EAOFFSET   &lt;span&gt;&lt;b&gt;[BX]&lt;/b&gt;: load BX into tmpA&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;For the cases below, an addition is required, so the registers are loaded into the ALU&#39;s temporary A and temporary B registers.
The effective address is the sum (indicated by ), which is moved to temporary A.&lt;span id=&quot;fnref:alu-default&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:alu-default&quot;&gt;12&lt;/a&gt;&lt;/span&gt;
These routines are carefully arranged in memory so &lt;code&gt;[BX+DI]&lt;/code&gt; and &lt;code&gt;[BP+SI]&lt;/code&gt; each execute one micro-instruction and then jump into
the middle of the other routines, saving code.&lt;span id=&quot;fnref:timing&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:timing&quot;&gt;13&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
BX  tmpA         &lt;span&gt;&lt;b&gt;[BX+SI]&lt;/b&gt;: get regs&lt;/span&gt;
SI  tmpB         &lt;span&gt;&lt;b&gt;1&lt;/b&gt;:&lt;/span&gt;
  tmpA   JMP EAOFFSET  

BP  tmpA         &lt;span&gt;&lt;b&gt;[BP+DI]&lt;/b&gt;: get regs&lt;/span&gt;
DI  tmpB         &lt;span&gt;&lt;b&gt;4&lt;/b&gt;:&lt;/span&gt;
  tmpA   JMP EAOFFSET  

BX  tmpA  JMPS 4 &lt;span&gt;&lt;b&gt;[BX+DI]&lt;/b&gt;: short jump to 4&lt;/span&gt;
BP  tmpA  JMPS 1 &lt;span&gt;&lt;b&gt;[BP+SI]&lt;/b&gt;: short jump to 1&lt;/span&gt;
&lt;/pre&gt;

&lt;h3&gt;The &lt;code&gt;EAOFFSET&lt;/code&gt; and &lt;code&gt;EAFINISH&lt;/code&gt; targets&lt;/h3&gt;
&lt;p&gt;After computing the register portion of the effective address, the routines above jump to
&lt;code&gt;EAOFFSET&lt;/code&gt;, but this is not a fixed target.
Instead, the Translation ROM selects one of three target microcode addresses based on the instruction and the ModR/M byte:
&lt;br/&gt;If there&#39;s a displacement, the microcode jumps to &lt;code&gt;[i]&lt;/code&gt; to add the displacement value.
&lt;br/&gt;If there is no displacement but a memory read, the microcode otherwise jumps to &lt;code&gt;EALOAD&lt;/code&gt; to load the memory contents.
&lt;br/&gt;If there is no displacement and no memory read should take place, the microcode jumps to &lt;code&gt;EADONE&lt;/code&gt;.
&lt;br/&gt;In other words, the microcode jump is a three-way branch that is implemented by the Translation ROM and is transparent to the microcode.&lt;/p&gt;
&lt;p&gt;For a displacement, the &lt;code&gt;[i]&lt;/code&gt; immediate code below loads a 1-byte or 2-byte displacement into the &lt;code&gt;tmpB&lt;/code&gt; register and adds it to the &lt;code&gt;tmpA&lt;/code&gt; register,
as described earlier.
At the end of a displacement calculation, the microcode jumps to the &lt;code&gt;EAFINISH&lt;/code&gt; tag, which is another branching target.
Based on the instruction, the Translation ROM selects one of two microcode targets: &lt;code&gt;EALOAD&lt;/code&gt; to load from memory, or &lt;code&gt;EADONE&lt;/code&gt; to skip the load.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
Q  tmpBL   JMPS MOD1 12 &lt;span&gt;&lt;b&gt;[i]&lt;/b&gt;: get byte(s)&lt;/span&gt;
Q  tmpBH         
  tmpA    JMP EAFINISH &lt;span&gt;&lt;b&gt;12&lt;/b&gt;: add displacement&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;EALOAD&lt;/code&gt; microcode below reads the value from memory, using the effective address in &lt;code&gt;tmpA&lt;/code&gt;. It puts the result in &lt;code&gt;tmpB&lt;/code&gt;.
The &lt;code&gt;RTN&lt;/code&gt; micro-instruction returns to the microcode that implements the original machine instruction.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
tmpA  IND  R DS,P0   &lt;span&gt;&lt;b&gt;EALOAD&lt;/b&gt;: read from tmpA address&lt;/span&gt;
OPR  tmpB  RTN        &lt;span&gt;store result in tmpB, return&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;EADONE&lt;/code&gt; routine puts the effective address in &lt;code&gt;IND&lt;/code&gt;, but it doesn&#39;t read from the memory location.
This supports machine instructions such as &lt;code&gt;MOV&lt;/code&gt; (some moves) and &lt;code&gt;LEA&lt;/code&gt; (Load Effective Address) that don&#39;t read from memory&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
tmpA  IND  RTN   &lt;span&gt;&lt;b&gt;EADONE&lt;/b&gt;: store effective address in IND&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;To summarize, the microcode runs different subroutines and different paths, depending on the addressing mode, executing the appropriate code.
The Translation ROM selects the appropriate control flow path.&lt;/p&gt;
&lt;h2&gt;Special cases&lt;/h2&gt;
&lt;p&gt;There are a couple of special cases in addressing that I will discuss in this section.&lt;/p&gt;
&lt;h3&gt;Supporting a fixed address&lt;/h3&gt;
&lt;p&gt;It is common to access a fixed memory address, but the standard addressing modes use a base or index register. 
The 8086 replaces the mode of &lt;code&gt;[BP]&lt;/code&gt; with no displacement with 16-bit fixed addressing.
In other words, a ModR/M byte with the pattern &lt;code&gt;00xxx110&lt;/code&gt; is treated specially.
(This special case is the orange &lt;code&gt;disp16&lt;/code&gt; line in the ModR/M table earlier.)
This is implemented in the Translation ROM which has additional rows to
detect this pattern and execute the immediate word &lt;code&gt;[iw]&lt;/code&gt; microcode below instead.
This microcode fetches a word from the instruction prefetch queue (&lt;code&gt;Q&lt;/code&gt;) into the &lt;code&gt;tmpA&lt;/code&gt; register, a byte at a time.
It jumps to &lt;code&gt;EAFINISH&lt;/code&gt; instead of &lt;code&gt;EAOFFSET&lt;/code&gt; because it doesn&#39;t make sense to add another displacement.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
Q  tmpAL          &lt;span&gt;&lt;b&gt;[iw]&lt;/b&gt;: get bytes&lt;/span&gt;
Q  tmpAH  JMP EAFINISH  
&lt;/pre&gt;

&lt;h3&gt;Selecting the segment&lt;/h3&gt;
&lt;p&gt;Memory accesses in the 8086 are relative to one of the 64-kilobyte segments: Data Segment, Code Segment, Stack Segment, or Extra Segment.
Most addressing modes use the Data Segment by default.
However, addressing modes that use the &lt;code&gt;BP&lt;/code&gt; register use the Stack Segment by default.
This is a sensible choice since the &lt;code&gt;BP&lt;/code&gt; (Base Pointer) register is intended for accessing values on the stack. &lt;/p&gt;
&lt;p&gt;This special case is implemented in the Translation ROM.
It has an extra output bit that indicates that the addressing mode should use the Stack Segment.
Since the Translation ROM is already decoding the addressing mode to select the right microcode routine, adding
one more output bit is straightforward.
This bit goes to the segment register selection circuitry, changing the default segment.
This circuitry also handles prefixes that change the segment.
Thus, segment register selection is handled in hardware without any action by the microcode.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;I hope you have enjoyed this tour through the depths of 8086 microcode.
The effective address calculation in the 8086 uses a combination of microcode and logic circuitry to implement
a variety of addressing methods.
Special cases make the addressing modes more useful, but make the circuitry more complicated.
This shows the CISC (Complex Instruction Set Computer) philosophy of x86, making the instructions complicated but
highly functional. In contrast, the RISC (Reduced Instruction Set Computer) philosophy takes the opposite approach,
making the instructions simpler but allowing the processor to run faster.
RISC vs. CISC was a big debate of the 1980s, but isn&#39;t as relevant nowadays.&lt;/p&gt;
&lt;p&gt;People often ask if microcode could be updated on the 8086. Microcode was hardcoded into the ROM, so it could not be changed.
This became a big problem for Intel with the famous Pentium &lt;a href=&quot;https://en.wikipedia.org/wiki/Pentium_FDIV_bug&quot;&gt;floating-point division bug&lt;/a&gt;.
The Pentium chip turned out to have a bug that resulted in rare but serious errors when dividing.
Intel recalled the defective processors in 1994 and replaced them at a cost of $475 million.
Starting with the Pentium Pro (1995), microcode could be patched at boot time, a useful feature that persists in modern CPUs.&lt;/p&gt;
&lt;p&gt;I&#39;ve written multiple &lt;a href=&quot;https://www.righto.com/search/label/8086&quot;&gt;posts on the 8086&lt;/a&gt; so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:immediate&quot;&gt;
&lt;p&gt;There are additional addressing modes that don&#39;t use a ModR/M byte. For instance, immediate instructions use a constant in the
instruction. For instance &lt;code&gt;ADD AX,42&lt;/code&gt; adds 42 to the AX register. Other instructions implicitly define the addressing mode.
I&#39;m ignoring these instructions for now.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:immediate&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:modes&quot;&gt;
&lt;p&gt;The 8086 supports more addressing modes than the ModR/M byte provides, by using separate opcodes.
For instance, arithmetic instructions can take an &quot;immediate&quot; value, an 8- or 16-bit value specified as part of
the instruction.
Other instructions operate on specific registers rather than memory or access memory through the stack.
For this blog post, I&#39;m focusing on the ModR/M modes and ignoring the other instructions.
Also, although I&#39;m discussing the 8086, this blog post applies to the Intel 8088 processor as well.
The 8088 has an 8-bit bus, a smaller prefetch queue, and some minor internal changes, but for this post you can consider them to be the same.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:modes&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:assembly&quot;&gt;
&lt;p&gt;My assembly code examples are based on Intel &lt;a href=&quot;http://www.bitsavers.org/pdf/intel/ISIS_II/121703-003_ASM86_Language_Reference_Manual_Nov83.pdf&quot;&gt;ASM86 assembly&lt;/a&gt; syntax.
There&#39;s a completely different format of x86 assembly language known as &lt;a href=&quot;https://www.cs.mcgill.ca/~cs573/winter2001/AttLinux_syntax.htm&quot;&gt;AT&amp;amp;T syntax&lt;/a&gt;. Confusingly, it reverses the source and destination.
For example, in AT&amp;amp;T syntax, &lt;code&gt;addw %bx, %cx%&lt;/code&gt; stores the result in CX.  AT&amp;amp;T syntax is widely used, for instance in Linux code.
The AT&amp;amp;T syntax is based on earlier &lt;a href=&quot;https://stackoverflow.com/a/42250270/3073190&quot;&gt;PDP-11 assembly code&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:assembly&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:effective-address&quot;&gt;
&lt;p&gt;The term &quot;effective address&quot; dates back to the 1950s, when computers moved beyond fixed memory addresses and started using index registers.
The earliest uses that I could find are from 1955 for the &lt;a href=&quot;http://www.bitsavers.org/pdf/ibm/650/22-6258-0_FeaturesIdxAccum.pdf&quot;&gt;IBM 650&lt;/a&gt; data processing machine and the &lt;a href=&quot;http://bitsavers.org/pdf/ibm/704/24-6661-2_704_Manual_1955.pdf&quot;&gt;IBM 704&lt;/a&gt; mainframe.
The &quot;Load Effective Address&quot; instruction, which provides the effective address as a value instead of performing the memory access,
was perhaps introduced in the IBM System/360 (1964) under the name &quot;Load Address&quot;.
It has been a part of many subsequent processors including the 8086.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:effective-address&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:octal&quot;&gt;
&lt;p&gt;Note that the ModR/M byte has the bits grouped in threes (as do many instructions).
This is due to the octal heritage of the 8086, dating back through the 8080 and the 8008 to the Datapoint 2200 (which used TTL chips to
decode groups of three bits).
Although the 8086 instruction set is invariably described in hexadecimal, it makes much more sense when viewed in octal.
See &lt;a href=&quot;https://gist.github.com/seanjensengrey/f971c20d05d4d0efc0781f2f3c0353da&quot;&gt;x86 is an octal machine&lt;/a&gt; for details.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:octal&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:system360&quot;&gt;
&lt;p&gt;The 8086&#39;s addressing schemes are reminiscent of the IBM System/360 (1964).
In particular, System/360 had a &quot;RX&quot; instruction format that accessed memory through a base register plus an index register plus a
displacement, using another register for the other argument.
This is very similar to the 8086&#39;s base + index + displacement method.
The System/360&#39;s &quot;RR&quot; (register-register) instruction format accessed two registers, much like the register mode of the ModR/M byte.
The details are very different, though, between the two systems.
See the &lt;a href=&quot;http://bitsavers.trailing-edge.com/pdf/ibm/360/princOps/A22-6821-0_360PrincOps.pdf&quot;&gt;IBM System/360 Principles of Operation&lt;/a&gt; for more details.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:system360&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:modrm&quot;&gt;
&lt;p&gt;The motivation behind the ModR/M options is discussed in
&lt;a href=&quot;https://amzn.to/3m6VCmI&quot;&gt;The 8086/8088 Primer&lt;/a&gt; by 8086 designer Steve Morse, pages 23-33.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:modrm&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:destination&quot;&gt;
&lt;p&gt;The D bit is usually called the register direction bit, but the designer of the 8086 instruction set calls it the destination field; see &lt;a href=&quot;https://amzn.to/3m6VCmI&quot;&gt;The 8086/8088 Primer&lt;/a&gt;, Steve Morse, page 28.
To summarize:
&lt;br/&gt;If the bit is 0, the result is stored into the location indicated by the
&lt;code&gt;mod&lt;/code&gt; and &lt;code&gt;r/m&lt;/code&gt; fields while the register specified by &lt;code&gt;reg&lt;/code&gt; is the source.
&lt;br/&gt;If the bit is 1, the result is stored into the register indicated by the &lt;code&gt;reg&lt;/code&gt; field.&lt;/p&gt;
&lt;p&gt;For the &lt;code&gt;W&lt;/code&gt; word bit, 0 indicates a byte operation and 1 indicates a word operation.&lt;/p&gt;
&lt;p&gt;One curious side-effect of the D bit is that an instruction like &lt;code&gt;ADD AX,BX&lt;/code&gt; can be implemented in two ways since both
arguments are registers.
The &lt;code&gt;reg&lt;/code&gt; field can specify &lt;code&gt;AX&lt;/code&gt; while the &lt;code&gt;r/m&lt;/code&gt; field specifies &lt;code&gt;BX&lt;/code&gt; or vice versa, depending on the D bit.
Different 8086 assemblers can be &quot;fingerprinted&quot; based on their decisions in these ambiguous cases.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:destination&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:mn&quot;&gt;
&lt;p&gt;The M and N registers hold a 5-bit code. This code indicates a 16-bit register (e.g. &lt;code&gt;AX&lt;/code&gt; or &lt;code&gt;IND&lt;/code&gt;), an 8-bit register (e.g. &lt;code&gt;AL&lt;/code&gt;), or a special value
(e.g. &lt;code&gt;&lt;/code&gt;, the ALU result; &lt;code&gt;ZEROS&lt;/code&gt;, all zero bits; or &lt;code&gt;F&lt;/code&gt;, the flags). The 3-bit register specification is mapped onto the 5-bit code depending
on whether the W bit is set (byte or word register), or if the operation is specifying a segment register.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:mn&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:microcode&quot;&gt;
&lt;p&gt;The microcode listings are based on Andrew Jenner&#39;s &lt;a href=&quot;https://www.reenigne.org/blog/8086-microcode-disassembled/&quot;&gt;disassembly&lt;/a&gt;.
I have made some modifications to (hopefully) make it easier to understand.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:microcode&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:translation-pla&quot;&gt;
&lt;p&gt;You can also view the Translation ROM as a PLA (Programmable Logic Array) constructed from two layers of NOR gates.
The conditional entries make it seem more like a PLA than a ROM.
Technically, it can be considered a ROM since a single row is active at a time.
I&#39;m using the name &quot;Translation ROM&quot; because that&#39;s what Intel calls it in the patents.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:translation-pla&quot; title=&quot;Jump back to footnote 11 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:alu-default&quot;&gt;
&lt;p&gt;Normally, an ALU operation requires a micro-instruction to specify the desired ALU operation and temporary register.
For the address addition, the ALU operation is not explicitly specified because it uses the ALU&#39;s default,
of adding &lt;code&gt;tmpA&lt;/code&gt; and &lt;code&gt;tmpB&lt;/code&gt;. The ALU is reset to this default at the beginning of each machine instruction.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:alu-default&quot; title=&quot;Jump back to footnote 12 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:timing&quot;&gt;
&lt;p&gt;A microcode jump takes an extra clock cycle for the microcode address register to get updated.
This is why, for instance, &lt;code&gt;[BP+DI]&lt;/code&gt; takes 7 clock cycles but &lt;code&gt;[BX+DI]&lt;/code&gt; takes 8 clock cycles.
Thus, the 8086 implementers took the tradeoff of slowing down some addressing modes by a clock cycle in order to save a few
micro-instructions in the small microcode ROM.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-addressing/ea-timing.jpg&quot;&gt;&lt;img alt=&quot;This table shows the clock cycles required for effective address calculations. From MCS-86 Assembly Language Reference Guide.&quot; class=&quot;hilite&quot; height=&quot;162&quot; src=&quot;https://static.righto.com/images/8086-addressing/ea-timing-w400.jpg&quot; title=&quot;This table shows the clock cycles required for effective address calculations. From MCS-86 Assembly Language Reference Guide.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This table shows the clock cycles required for effective address calculations. From &lt;a href=&quot;http://bitsavers.org/components/intel/8086/9800749-1_MCS-86_Assembly_Language_Reference_Guide_Oct78.pdf&quot;&gt;MCS-86 Assembly Language Reference Guide&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- --&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:timing&quot; title=&quot;Jump back to footnote 13 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:sign&quot;&gt;
&lt;p&gt;A one-byte signed number can be sign-extended into a two-byte signed number.
This is done by copying the top bit (the sign) from the low byte and filling the top byte with that bit.
For example, 0x64 is sign-extended to 0x0064 (+100), while 0x9c is sign-extended to 0xff9c (-100).&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:sign&quot; title=&quot;Jump back to footnote 14 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/8745122849902587790/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=8745122849902587790' title='7 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/8745122849902587790'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/8745122849902587790'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/02/8086-modrm-addressing.html' title='Reverse-engineering the ModR/M addressing microcode in the Intel 8086 processor'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>7</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-6015138995640807347</id><published>2023-02-21T09:15:00.004-08:00</published><updated>2023-02-27T18:20:16.364-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="microcode"/><title type='text'>Reverse-engineering the interrupt circuitry in the Intel 8086 processor</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;

&lt;p&gt;Interrupts have been an important part of computers since the mid-1950s,&lt;span id=&quot;fnref:history&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:history&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
providing a mechanism to interrupt a program&#39;s execution.
Interrupts allows the computer to handle time-critical tasks such as I/O device operations.
In this blog post, I look at the interrupt features in the Intel 8086 (1978) and how they are implemented in
silicon, a combination of interesting circuitry and microcode.&lt;/p&gt;
&lt;p&gt;I&#39;ve been reverse-engineering the 8086 starting with the silicon die.
The die photo below shows the chip under a microscope.
The metal layer on top of the chip is visible, with the silicon and polysilicon mostly hidden underneath.
Around the edges of the die, bond wires connect pads to the chip&#39;s 40 external pins;
relevant pins are marked in yellow.
I&#39;ve labeled the key functional blocks; the ones that are important to this discussion are darker and will be discussed in detail below.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top and an Execution Unit (EU) below.
The BIU handles bus activity, while the Execution Unit (EU) executes instructions and microcode.
Both parts are extensively involved in interrupt handling.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-interrupts/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;624&quot; src=&quot;https://static.righto.com/images/8086-interrupts/die-labeled-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Interrupts in the 8086&lt;/h2&gt;
&lt;p&gt;The idea behind an interrupt is to stop the current flow of execution, run an interrupt handler to perform
a task, and then continue execution where it left off.
An interrupt is like a subroutine call in some ways; it pushes the current segment register and program counter on
the stack and continues at a new address. However, there are a few important differences.
First, the address of the interrupt handler is obtained indirectly, through an interrupt vector table.
Interrupts are numbered 0 through 255, and each interrupt has an entry in the vector table that gives the address
of the code to handle the interrupt.
Second, an interrupt pushes the processor flags to the stack, so they can be restored after the interrupt.
Finally, an interrupt clears the interrupt and trap flags, blocking more interrupts while handling the
interrupt.&lt;/p&gt;
&lt;p&gt;The 8086 provides several types of interrupts, some generated by hardware and some generated by software.
For hardware interrupts, the INTR pin on the chip generates a maskable interrupt when activated, while the NMI pin on the chip generates a higher-priority non-maskable interrupt.&lt;span id=&quot;fnref:maskable&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:maskable&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
Typically, most interrupts use the INTR pin, signaling things such as a timer, keyboard request, real-time clock,
or a disk needing service.
The NMI interrupt is designed for things such as parity error or an impending power failure, which are so critical they can&#39;t be delayed.
The 8086 also has a RESET pin that resets the CPU.
Although not technically an interrupt, the RESET action has many features in common with interrupts, so I&#39;ll discuss it here.&lt;/p&gt;
&lt;p&gt;On the software side, the 8086 has multiple types of interrupts generated by different instructions.
The &lt;code&gt;INT n&lt;/code&gt; instruction creates an interrupt of the specified type (0 to 255).
These software interrupts were used in the IBM PC to execute a function in the BIOS, the layer underneath the operating system.
These functions could be everything from a floppy disk operation to accessing the printer.
The one-byte &lt;code&gt;INT 3&lt;/code&gt; instruction creates a breakpoint interrupt for debugging.
The divide instructions generate an interrupt if a divide-by-zero or overflow occurs.
The &lt;code&gt;INTO&lt;/code&gt; instruction (Interrupt if Overflow) generates an interrupt
if the overflow flag is set.
To support single-step mode in debuggers, the Trap flag generate an interrupt on every instruction.&lt;/p&gt;
&lt;p&gt;The diagram below shows how the vector table is implemented. Each of the 256 interrupt types has an entry holding
the address of the interrupt handler (the code segment value and the instruction pointer (program counter) value).
In the next section, I&#39;ll show below how the microcode loads the vector from the table and switches execution to that
interrupt handler.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-interrupts/vector-table.jpg&quot;&gt;&lt;img alt=&quot;This diagram shows where the interrupt vectors are stored in memory.  From iAPX 86/88 User&#39;s Manual, Figure 4-18.&quot; class=&quot;hilite&quot; height=&quot;653&quot; src=&quot;https://static.righto.com/images/8086-interrupts/vector-table-w450.jpg&quot; title=&quot;This diagram shows where the interrupt vectors are stored in memory.  From iAPX 86/88 User&#39;s Manual, Figure 4-18.&quot; width=&quot;450&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This diagram shows where the interrupt vectors are stored in memory.  From &lt;a href=&quot;http://www.bitsavers.org/components/intel/_dataBooks/1981_iAPX_86_88_Users_Manual.pdf&quot;&gt;iAPX 86/88 User&#39;s Manual&lt;/a&gt;, Figure 4-18.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Microcode&lt;/h2&gt;
&lt;p&gt;Most of the operations in the 8086 are implemented in microcode,
a low-level layer of code that sits between the
machine code instructions and the chip&#39;s hardware.
I&#39;ll explain a few features of the 8086&#39;s microcode that are important for the interrupt code.
Each micro-instruction is 21 bits long, as shown below.
The first part of the micro-instruction specifies a move between a source register and a destination register;
these may be special-purpose internal registers, not just the registers visible to the programmer.
The meaning of the remaining bits depends on the type of micro-instruction, but includes
jumps within the microcode, ALU (Arithmetic/Logic Unit) operations, and memory operations.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-interrupts/microcode-format.jpg&quot;&gt;&lt;img alt=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; class=&quot;hilite&quot; height=&quot;203&quot; src=&quot;https://static.righto.com/images/8086-interrupts/microcode-format-w700.jpg&quot; title=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The encoding of a micro-instruction into 21 bits. Based on &lt;a href=&quot;https://digitalcommons.law.scu.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=1031&amp;context=chtlj&quot;&gt;NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;For a memory access, microcode issues a memory read or write micro-instruction.
Memory accesses use two internal registers: the &lt;code&gt;IND&lt;/code&gt; (Indirect) register holds the address in the segment,
while the &lt;code&gt;OPR&lt;/code&gt; (Operand) register holds the word that is read or written.
A micro-instruction such as &lt;code&gt;W SS,P2&lt;/code&gt; writes the &lt;code&gt;OPR&lt;/code&gt; register to the memory address specified by the &lt;code&gt;IND&lt;/code&gt; register
and the segment register (&lt;code&gt;SS&lt;/code&gt; indicates the stack segment). The &lt;code&gt;IND&lt;/code&gt; register can also be incremented or decremented
(&lt;code&gt;P2&lt;/code&gt; indicates &quot;Plus 2&quot;).&lt;/p&gt;
&lt;p&gt;The 8086&#39;s Bus Interface Unit (BIU) handles the memory request in hardware, while the microcode waits.
The BIU has an adder to combine the segment address and the offset to obtain the &quot;absolute&quot; address.
It also has a constant ROM to increment or decrement the &lt;code&gt;IND&lt;/code&gt; register.
Memory accesses are complicated in the 8086 and take at least four clock cycles,&lt;span id=&quot;fnref:cycles&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:cycles&quot;&gt;3&lt;/a&gt;&lt;/span&gt; called T1, T2,
T3, and T4.
An interrupt acknowledge is almost the same as a memory read, except the &lt;code&gt;IAK&lt;/code&gt; bit is set in the microcode,
causing some behavior changes.&lt;/p&gt;
&lt;p&gt;The interaction between microcode and the ALU (Arithmetic/Logic Unit) will also be important.
The ALU has three temporary registers that hold the arguments for operations, called temporary A, B, and C.
These registers are invisible to the programmer.
The first argument for, say, an addition can come from any of the three registers, while the second argument is
always from the temporary B register.
Performing an ALU operation takes at least two micro-instructions. First, the ALU is configured to perform
an operation, for example, ADD or DEC2 (decrement by 2).
The result is then read from the ALU, denoted as the &lt;code&gt;&lt;/code&gt; register.&lt;/p&gt;
&lt;h2&gt;Software interrupts&lt;/h2&gt;
&lt;p&gt;The main microcode for interrupt handling is shown below.&lt;span id=&quot;fnref:jenner&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:jenner&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
Each line specifies a move operation and an action, with my comments in green.
On entry to &lt;code&gt;INTR&lt;/code&gt; interrupt handler, the &lt;code&gt;OPR&lt;/code&gt; operand register holds the interrupt type.
This chunk of microcode looks up the interrupt handler in the vector table, pushes the status flags onto the stack,
and then branches to a routine &lt;code&gt;FARCALL2&lt;/code&gt; to perform a subroutine call the interrupt handler.&lt;/p&gt;
&lt;style&gt;
  pre.microcode {font-family: courier, fixed; padding: 10px; background-color: #f5f5f5; display:inline-block;}
  pre.microcode span {color: green; font-style:italic; font-family: sans-serif; font-size: 90%;}
&lt;/style&gt;

&lt;pre class=&quot;microcode&quot;&gt;
       move            action
19d  OPR  tmpBL     SUSP         &lt;span&gt;INTR: OPR to tmpB(low), suspend prefetch&lt;/span&gt;
19e  0  tmpbH       ADD tmpB      &lt;span&gt;0 to tmpB(high), add tmpB to tmpB&lt;/span&gt;
19f    tmpB                      &lt;span&gt;ALU sum to tmpB, add tmpB to tmpB&lt;/span&gt;
1a0    IND         R S0,P2       &lt;span&gt;ALU sum to IND, read from memory, IND+=2&lt;/span&gt;
1a1  OPR  tmpB      DEC2 tmpC     &lt;span&gt;memory to tmpB, set up decrement tmpC&lt;/span&gt;
1a2  SP  tmpC       R S0,P0       &lt;span&gt;SP to tmpC, read from memory&lt;/span&gt;
1a3  OPR  tmpA                    &lt;span&gt;memory to tmpA&lt;/span&gt;
1a4  F  OPR         CITF          &lt;span&gt;Flags to OPR, clear interrupt and trap flags&lt;/span&gt;
1a5    IND         W SS,P0       &lt;span&gt;ALU dec to IND, Write to memory&lt;/span&gt;
1a6  IND  tmpC      JMP FARCALL2  &lt;span&gt;IND to tmpC, branch to FARCALL2&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;In more detail, the microcode routine starts at 19d by moving the interrupt number from the &lt;code&gt;OPR&lt;/code&gt; register to the
low byte of the ALU&#39;s temporary B register.
The &lt;code&gt;SUSP&lt;/code&gt; action suspends instruction prefetching since we&#39;ll start executing instructions from a new location.
Next, line 19e zeros out the top byte of the temporary B register and tells the ALU to add temporary B to itself.
The next micro-instruction puts the ALU result (indicated by ) into temporary B, doubling the value.&lt;/p&gt;
&lt;p&gt;Line 1a0 calculates another sum (doubling) from the ALU and stores it in the &lt;code&gt;IND&lt;/code&gt; register.
In other words, the interrupt number has been multiplied by 4, yielding an address into the vector table.
The interrupt handle address is read from the vector table: &lt;code&gt;R S0,P2&lt;/code&gt; operation reads from memory, segment 0, and performs a &quot;Plus 2&quot; on the &lt;code&gt;IND&lt;/code&gt; register.
Line 1a1
puts the result (&lt;code&gt;OPR&lt;/code&gt;) into the temporary B register.&lt;/p&gt;
&lt;p&gt;Line 1a2 stores the current stack pointer register into temporary C. It also performs a second read to get the
handler code segment from the vector table.
Line 1a3 stores this in the temporary A register.
Line 1a4 puts the flags (&lt;code&gt;F&lt;/code&gt;) into the &lt;code&gt;OPR&lt;/code&gt; register. It also clears the interrupt and trap flags (&lt;code&gt;CITF&lt;/code&gt;), blocking further interrupts.&lt;/p&gt;
&lt;p&gt;Line 1a5 puts the ALU result (the decremented stack pointer) into the &lt;code&gt;IND&lt;/code&gt; register. (This ALU operation was set up back in line 1a1.)
To push the flags on the stack, &lt;code&gt;W SS,P0&lt;/code&gt; writes &lt;code&gt;OPR&lt;/code&gt; to the Stack segment and does a &quot;Plus 0&quot; on the &lt;code&gt;IND&lt;/code&gt; register.
Finally, line 1a6 stores the &lt;code&gt;IND&lt;/code&gt; register (the new top-of-stack) into the temporary C register and jumps to the &lt;code&gt;FARCALL2&lt;/code&gt; micro-routine.&lt;span id=&quot;fnref:jump&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:jump&quot;&gt;5&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Understanding microcode can be tricky, since it is even more low-level than machine instructions, but hopefully
this discussion gives you a feel for it.
Everything is broken down into very small steps, even more basic than machine instructions.
Microcode is a bit like a jigsaw puzzle, carefully fit together to ensure
everything is at the right place at the right time, as efficiently as possible.&lt;/p&gt;
&lt;h3&gt;Subroutine call microcode: FARCALL2&lt;/h3&gt;
&lt;p&gt;Next, I&#39;ll describe the &lt;code&gt;FARCALL2&lt;/code&gt; microcode.
Because of its segment registers, the 8086 has two types of calls (and jumps):
a near call is a subroutine call within the same code segment, while a far call is a subroutine call
to a different code segment.
A far call target is specified with two words: the new code segment register and the new program counter.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;FARCALL2&lt;/code&gt; micro-routine performs a subroutine call to a particular segment and offset.
At entry to &lt;code&gt;FARCALL2&lt;/code&gt;, the target code segment in temporary A, the offset is in temporary B, and the
decremented stack pointer will be provided by the ALU.
The microcode below pushes the code segment register to the stack, updates the code segment
register with the new value, and then jumps to &lt;code&gt;NEARCALL&lt;/code&gt; to finish the subroutine call.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
06c    IND      CORR        &lt;span&gt;FARCALL2: ALU (IND-2) to IND, correct PC&lt;/span&gt;
06d  CS  OPR     W SS,M2      &lt;span&gt;CS to OPR, write to memory, IND-=2&lt;/span&gt;
06e  tmpA  CS    PASS tmpC    &lt;span&gt;tmpA to CS, ALU passthrough&lt;/span&gt;
06f  PC  OPR     JMP NEARCALL &lt;span&gt;PC to OPR, branch to NEARCALL&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;For a subroutine call, the program counter is saved so execution can resume where it left off.
But because of prefetching, the program counter in the 8086 points to the next instruction to &lt;em&gt;fetch&lt;/em&gt;,
not the next instruction to &lt;em&gt;execute&lt;/em&gt;.
To fix this, the 
&lt;code&gt;CORR&lt;/code&gt; (Correction) micro-instruction corrects the program counter value 
by subtracting the length of the prefetch queue.
Line 06c also puts the decremented stack location into &lt;code&gt;IND&lt;/code&gt; using the ALU decrement operation set up way back at line 1a1.&lt;/p&gt;
&lt;p&gt;Line 06d puts the code segment value (&lt;code&gt;CS&lt;/code&gt;) into the &lt;code&gt;OPR&lt;/code&gt; register and then writes it to the stack segment,
performing a &quot;Minus 2&quot; on &lt;code&gt;IND&lt;/code&gt;. In other words, the CS register is pushed onto the stack.
Line 06e stores the new value (from temporary A) into the CS register. It also sets up the ALU to pass the value
of the temporary C register as its result.
Finally, line 06f puts the (corrected) program counter into the &lt;code&gt;OPR&lt;/code&gt; register and jumps to the &lt;code&gt;NEARCALL&lt;/code&gt; routine.&lt;/p&gt;
&lt;h3&gt;Subroutine call microcode: NEARCALL&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;NEARCALL&lt;/code&gt; micro-routine does a near subroutine call, updating the program counter but not the segment register.
At entry, the target address is in temporary B, the &lt;code&gt;IND&lt;/code&gt; register indicates the top of the stack, and &lt;code&gt;OPR&lt;/code&gt; holds the program counter.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
077  tmpB  PC    FLUSH      &lt;span&gt;NEARCALL: tmpB to PC, restart prefetch&lt;/span&gt;
078  IND  tmpC               &lt;span&gt;IND to tmpC&lt;/span&gt;
079    IND                  &lt;span&gt;ALU to IND&lt;/span&gt;
07a    SP       W SS,P0 RNI &lt;span&gt;ALU to SP, write PC to memory, run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;Line 077 puts temporary B into the program counter. The &lt;code&gt;FLUSH&lt;/code&gt; operation flushes the stale instructions from
the prefetch queue and starts prefetching from the new PC address.
Line 078 puts &lt;code&gt;IND&lt;/code&gt; (i.e. the new stack pointer value) into temporary C.
Line 079 puts this value into the &lt;code&gt;IND&lt;/code&gt; register and line 07a puts this value into the &lt;code&gt;SP&lt;/code&gt; register.
(The ALU was configured at line 06e to pass the temporary C value unmodified.)&lt;/p&gt;
&lt;p&gt;Line 07a pushes the PC to the stack by writing &lt;code&gt;OPR&lt;/code&gt; (the old program counter) to the stack segment.
Finally, &lt;code&gt;RNI&lt;/code&gt; (Run Next Instruction) ends this microcode sequence and causes the 8086 to
run the next machine instruction, the first instruction of the interrupt handler.&lt;/p&gt;
&lt;h3&gt;Starting an interrupt&lt;/h3&gt;
&lt;p&gt;The above microcode handles a generic interrupt. But there&#39;s one more piece: setting up the interrupt
type for the instruction.
For instance, the &lt;code&gt;INT ib&lt;/code&gt; machine instruction has the interrupt type in the second byte of the opcode.
This machine instruction has the two micro-instructions below.
The microcode loads the type from the instruction prefetch queue (&lt;code&gt;Q&lt;/code&gt;) and puts it into temporary B and then &lt;code&gt;OPR&lt;/code&gt;.
Then it jumps to the &lt;code&gt;INTR&lt;/code&gt; microcode discussed earlier.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
1a8  Q  tmpB             &lt;span&gt;INT ib: load a byte from the queue&lt;/span&gt;
1a9  tmpB  OPR  JMP INTR  &lt;span&gt;Put the byte in OPR and jump to INTR&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;Several instructions require specific interrupt numbers, and the microcode uses a tricky technique to obtain these numbers.
The numbers are obtained from a special pseudo-register called &lt;code&gt;CR&lt;/code&gt;, which is all zeros except the three low bits
come from the microcode address.&lt;span id=&quot;fnref:zero&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:zero&quot;&gt;6&lt;/a&gt;&lt;/span&gt;
The microcode is carefully arranged in memory so the micro-instruction is at the right address to generate the necessary value.
For instance, in the microcode below, entry point &lt;code&gt;INT1&lt;/code&gt; will load the number 1 into &lt;code&gt;OPR&lt;/code&gt;, entry point &lt;code&gt;INT2&lt;/code&gt; will load the number 2 into &lt;code&gt;OPR&lt;/code&gt;, and &lt;code&gt;INT0&lt;/code&gt; will load 0 into &lt;code&gt;OPR&lt;/code&gt;.
Each line then jumps to the main &lt;code&gt;INTR&lt;/code&gt; interrupt microcode.&lt;/p&gt;
&lt;!--
For instance, the `INT 3` instruction is provided as a special case, a one-byte instruction that can be inserted into
code for a breakpoint and causes a type 3 interrupt. A trap creates a type 1 interrupt while an overflow creates
a type 4 interrupt.
--&gt;

&lt;pre class=&quot;microcode&quot;&gt;
198  CR  OPR     JMP INTR      &lt;span&gt;INT1: num to OPR, branch to INTR&lt;/span&gt;
199  CR  OPR     JMP INTR      &lt;span&gt;INT2: num to OPR, branch to INTR&lt;/span&gt;
...
1a7  CR  OPR     JMP INTR      &lt;span&gt;INT0: num to OPR, branch to INTR&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;The microcode for the &lt;code&gt;INT 3&lt;/code&gt; and &lt;code&gt;INTO&lt;/code&gt; (not to be confused with &lt;code&gt;INT0&lt;/code&gt;) machine instructions has some wasted micro-instructions to ensure that the &lt;code&gt;CR  OPR&lt;/code&gt; is at the right address.
This wastes a couple of cycles and a couple of micro-instructions.&lt;span id=&quot;fnref:int3&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:int3&quot;&gt;7&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;!--
Another case is the divide-by-0 interrupt. It is triggered in the division microcode,
which simply jumps to the `INT0` microcode if there is an overflow.
--&gt;

&lt;h3&gt;Return from interrupt&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;IRET&lt;/code&gt; interrupt is used to return from interrupts.
It pops the program counter, code segment register, and flags from the stack, so execution can continue
at the point where the interrupt happened.
It calls the microcode subroutine &lt;code&gt;FARRET&lt;/code&gt; to pop the code segment register and the PC from the stack.
(I won&#39;t go into &lt;code&gt;FARRET&lt;/code&gt; in this post.)
Then it pops the flags from the stack, updates the Stack Pointer, and runs the next instruction.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
0c8               CALL FARRET &lt;span&gt;IRET: call Far Return&lt;/span&gt;
0c9               R SS,P2      &lt;span&gt;read from stack, IND+=2&lt;/span&gt;
0ca  OPR  F                   &lt;span&gt;mem to Flags&lt;/span&gt;
0cb  IND  SP     RNI          &lt;span&gt;IND to stack pointer, run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;h2&gt;External hardware interrupts&lt;/h2&gt;
&lt;p&gt;As well as software interrupts, the 8086 has hardware interrupts.
The 8086 chip has pins for INTR and NMI; pulling the pin high causes a hardware interrupt.
This section discusses the hardware circuitry and the microcode that handles these interrupts.&lt;/p&gt;
&lt;h3&gt;The interrupt pin circuit&lt;/h3&gt;
&lt;p&gt;The schematic below shows the input circuitry for the INTR pin; the NMI, RESET, and TEST pins use the same circuit.
The function of this circuit is to clean up the input and ensure that it is synchronized with the clock.
The chip&#39;s INTR pin is connected to a protection diode to drain a negative voltage to ground.
Next, the signal goes through three inverters, probably to force a marginal voltage
to either 0 or 1.
Finally, the signal goes through an edge-triggered flip-flop to synchronize it with the clock.
The flip-flop is constructed from two set-reset latches, the first gated by clk&#39; and the second gated by clk.
At the output of each stage is a &quot;superbuffer&quot;, two transistors that produce a higher-current output than a regular
inverter.
This flip-flop circuit is unusual for the 8086; most flip-flops and latches are constructed from dynamic logic
with pass transistors, which is much more compact.
The more complicated circuitry on the INTR input probably protects against metastability and other problems that
could occur with poor-quality input signals.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-interrupts/pin-input.jpg&quot;&gt;&lt;img alt=&quot;Schematic of the input circuitry for the INTR pin.&quot; class=&quot;hilite&quot; height=&quot;209&quot; src=&quot;https://static.righto.com/images/8086-interrupts/pin-input-w700.jpg&quot; title=&quot;Schematic of the input circuitry for the INTR pin.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Schematic of the input circuitry for the INTR pin.&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;The interrupt logic circuitry&lt;/h3&gt;
&lt;p&gt;The chip has a block of interrupt logic to receive interrupts, handle interrupt priorities, and execute an
interrupt at the appropriate time.
This circuitry is in the top right part of the chip, on the opposite side of the chip from the interrupt pins.
The schematic below shows this circuitry.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-interrupts/interrupt-logic.jpg&quot;&gt;&lt;img alt=&quot;The interrupt logic circuitry activates the microcode interrupt code at the appropriate time.&quot; class=&quot;hilite&quot; height=&quot;422&quot; src=&quot;https://static.righto.com/images/8086-interrupts/interrupt-logic-w600.jpg&quot; title=&quot;The interrupt logic circuitry activates the microcode interrupt code at the appropriate time.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The interrupt logic circuitry activates the microcode interrupt code at the appropriate time.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The top chunk of logic latches an NMI (non-maskable interrupt) until it runs or it is cleared by a reset.&lt;span id=&quot;fnref:nmi&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:nmi&quot;&gt;8&lt;/a&gt;&lt;/span&gt;
The first flip-flop helps convert an NMI input into a one-clock pulse.
The second flip-flop holds the NMI until it runs.&lt;/p&gt;
&lt;p&gt;The middle chunk of logic handles traps. If the trap flag is high, the latch will hold the trap request until
it can take place.
The latch is loaded on First Clock (FC), which indicates the start of a new instruction.
The NOR gate blocks the trap if there is an interrupt or NMI, which has higher priority.&lt;span id=&quot;fnref:simultaneous&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:simultaneous&quot;&gt;9&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The third chunk of logic schedules the interrupt.
Three things can delay an interrupt: an interrupt delay micro-instruction, an instruction that modifies a
segment register, or an instruction prefix.&lt;span id=&quot;fnref:delay&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:delay&quot;&gt;10&lt;/a&gt;&lt;/span&gt;
If not delayed, the interrupt (NMI, trap, or INTR pin) will run at the start of the next instruction (i.e. &lt;code&gt;FC&lt;/code&gt;).&lt;span id=&quot;fnref:fc&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:fc&quot;&gt;11&lt;/a&gt;&lt;/span&gt;
The microcode interrupt code is run for these cases as well as a reset.
Note that the reset is not gated by First Clock, but can run at any time.&lt;/p&gt;
&lt;p&gt;The interrupt signal from this circuitry loads a hardcoded interrupt
address into the microcode address latches, depending on the type of interrupt.&lt;span id=&quot;fnref:mc-addr&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:mc-addr&quot;&gt;12&lt;/a&gt;&lt;/span&gt;
This happens for an interrupt at First Clock, while a reset can happen any time in the instruction cycle.
A trap goes to the &lt;code&gt;INT1&lt;/code&gt; microcode routine described earlier, while an NMI interrupt goes to &lt;code&gt;INT2&lt;/code&gt; microcode routine.
The microcode for the &lt;code&gt;INTR&lt;/code&gt; interrupt will be discussed in the next section.&lt;/p&gt;
&lt;p&gt;The interrupt signal also goes to the Group Decode ROM (via the instruction register), where it blocks regular
instruction decoding.
Finally, the interrupt signal goes to a circuit called the loader, where it prevents fetching of the next instruction from the prefetch
queue.&lt;/p&gt;
&lt;h2&gt;The external INTR interrupt&lt;/h2&gt;
&lt;p&gt;The INTR interrupt has some special behavior to communicate with the device that triggered the interrupt:
the 8086 performs two bus cycles to acknowledge the interrupt and to
obtain the interrupt number from the device.
This is implemented with a combination of microcode and the bus interface logic.
The bus cycles are similar to memory read cycles, but with some behavior specific to interrupts.&lt;/p&gt;
&lt;p&gt;The INTR interrupt has its own microcode, shown below.
The first micro-instruction zeros the &lt;code&gt;IND&lt;/code&gt; memory address register and then performs a special &lt;code&gt;IAK&lt;/code&gt; bus cycle.&lt;span id=&quot;fnref:iak&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:iak&quot;&gt;13&lt;/a&gt;&lt;/span&gt;
This is similar to a memory read but asserts the &lt;code&gt;INTA&lt;/code&gt; interrupt acknowledge line so the device knows that
its interrupt has been received.
Next, prefetching is suspended.
The third line performs a second &lt;code&gt;IAK&lt;/code&gt; bus cycle and the external device puts the interrupt
number onto the bus. The interrupt number is read into the &lt;code&gt;ORD&lt;/code&gt; register, just like a memory read.
At this point, the code falls through into the interrupt microcode described previously.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
19a  0  IND   IAK S0,P0  &lt;span&gt;IRQ: 0 to IND, run interrupt bus cycle&lt;/span&gt;
19b            SUSP        &lt;span&gt;suspend prefetch&lt;/span&gt;
19c            IAK S0,P0   &lt;span&gt;run interrupt bus cycle&lt;/span&gt;
19d            ...        &lt;span&gt;The INTR routine discussed earlier&lt;/span&gt;
&lt;/pre&gt;

&lt;h3&gt;The bus cycle&lt;/h3&gt;
&lt;p&gt;The diagram below provides timing details of the two interrupt acknowledge bus cycles. Each cycle is
similar to a memory read bus cycle, going through the T1 through T4 states, starting with an
&lt;code&gt;ALE&lt;/code&gt; (Address Latch Enable) signal.
The main difference is the interrupt acknowledge bus cycle also raises the &lt;code&gt;INTA&lt;/code&gt; (Interrupt Acknowledge) to
let the requesting device know that its interrupt has been acknowledged.&lt;span id=&quot;fnref:minimum&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:minimum&quot;&gt;14&lt;/a&gt;&lt;/span&gt;
On the second cycle, the device provides an 8-bit type vector that provides the interrupt number.
The 8086 also issues a &lt;code&gt;LOCK&lt;/code&gt; signal to lock the bus from other uses during this sequence.
The point of this is that the 8086 goes through a fairly complex bus sequence when handling a hardware interrupt.
The microcode triggers these two bus cycles with the &lt;code&gt;IAK&lt;/code&gt; micro-operation, but the bus interface circuitry
goes through the various states of the bus cycle in hardware, without involving the microcode.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-interrupts/int-ack.jpg&quot;&gt;&lt;img alt=&quot;This diagram shows the interrupt acknowledge sequence. From Intel 8086 datasheet.&quot; class=&quot;hilite&quot; height=&quot;308&quot; src=&quot;https://static.righto.com/images/8086-interrupts/int-ack-w600.jpg&quot; title=&quot;This diagram shows the interrupt acknowledge sequence. From Intel 8086 datasheet.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This diagram shows the interrupt acknowledge sequence. From &lt;a href=&quot;https://www.electro-tech-online.com/datasheets/8086_intel.pdf&quot;&gt;Intel 8086 datasheet&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The circuitry to control the bus cycle is complicated with many flip-flops and logic gates; the diagram below shows the flip-flops.
I plan to write about the bus cycle circuitry in detail later, but for now, I&#39;ll give an extremely simplified description.
Internally, there is a T0 state before T1 to provide a cycle to set up the bus operation.
The bus timing states are controlled by a chain of flip-flops configured like a shift register with additional logic: the output from the T0 flip-flop is connected to the input of the T1 flip-flop and likewise with T2 and T3, forming a chain.
A bus cycle is started by putting a 1 into the input of the T0 flip-flop.
When the CPU&#39;s clock transitions, the flip-flop latches this signal, indicating the (internal) T0 bus state.
On the next clock cycle, this 1 signal goes from the T0 flip-flop to the T1 flip-flop, creating the externally-visible T1 state.
Likewise, the signal passes to the T2 and T3 flip-flops in sequence, creating the bus cycle.
Some special-case logic changes the behavior for an interrupt versus a read.&lt;span id=&quot;fnref:bus-logic&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:bus-logic&quot;&gt;15&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-interrupts/mem-ctrl.jpg&quot;&gt;&lt;img alt=&quot;The read/write control circuitry on the die with the flip-flops labeled. Metal and polysilicon were removed to show the underlying silicon.&quot; class=&quot;hilite&quot; height=&quot;509&quot; src=&quot;https://static.righto.com/images/8086-interrupts/mem-ctrl-w600.jpg&quot; title=&quot;The read/write control circuitry on the die with the flip-flops labeled. Metal and polysilicon were removed to show the underlying silicon.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The read/write control circuitry on the die with the flip-flops labeled. Metal and polysilicon were removed to show the underlying silicon.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Reset&lt;/h2&gt;
&lt;p&gt;The reset pin resets the CPU to an initial state.
This isn&#39;t an interrupt, but much of the circuitry is the same, so I&#39;ll describe it for completeness.
The reset microcode below initializes the segment registers, program counter, and flags to 0, except the
code segment is initialized to 0xffff.
Thus, after a reset, instruction execution will start at absolute address 0xffff0.
The reset line is also connected to numerous flip-flops and circuits in the 8086 to ensure that they are initialized to the proper state. These initializations happen outside of the microcode.&lt;/p&gt;
&lt;pre class=&quot;microcode&quot;&gt;
1e4  0  DS     SUSP   &lt;span&gt;RESET: 0 to DS, suspend prefetch&lt;/span&gt;
1e5  ONES  CS          &lt;span&gt;FFFF to CS&lt;/span&gt;
1e6  0  PC     FLUSH   &lt;span&gt;0 to PC, start prefetch&lt;/span&gt;
1e7  0  F              &lt;span&gt;0 to Flags&lt;/span&gt;
1e8  0  ES             &lt;span&gt;0 to ES&lt;/span&gt;
1e9  0  SS     RNI     &lt;span&gt;0 to SS, run next instruction&lt;/span&gt;
&lt;/pre&gt;

&lt;h2&gt;A bit of history&lt;/h2&gt;
&lt;p&gt;The 8086&#39;s interrupt system inherits a lot from the Intel 8008 processor.
Interrupts were a bit of an afterthought on the 8008 so the interrupt handling was primitive and designed to simplify implementation.&lt;span id=&quot;fnref:8008&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:8008&quot;&gt;17&lt;/a&gt;&lt;/span&gt;
In particular, an interrupt response acts like an instruction fetch except the interrupting device &quot;jams&quot;
an instruction on the bus.
To support this, the 8008 provided one-byte &lt;code&gt;RST&lt;/code&gt; (Restart) instructions that would call a fixed location.
The Intel 8080 improved the 8008, but kept this model of performing an instruction fetch cycle that received a &quot;jammed&quot; instruction for an interrupt.
With more pins available, the 8080 added the &lt;code&gt;INTA&lt;/code&gt; Interrupt Acknowledge pin.&lt;/p&gt;
&lt;p&gt;The approach of &quot;jamming&quot; an instruction onto the bus for an interrupt is rather unusual.
Other contemporary microprocessors such as the 6800, 6502, or Intel 8048 used an interrupt vector approach, which
is much more standard:
an interrupt vector table held pointers to the interrupt service routines.&lt;/p&gt;
&lt;p&gt;The 8086 switched to an interrupt vector table, but retained some 8080 interrupt characteristics for backward compatibility.
In particular, the 8086 performs a memory cycle very much like an instruction fetch, but instead of an
instruction, it receives an interrupt number.
The 8086 performs two interrupt ack bus cycles but ignores the first one, which lets the same hardware work with
the 8080 and 8086.&lt;span id=&quot;fnref:8259A&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:8259A&quot;&gt;16&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;This is another blog post that I expected would be quick and easy, but there&#39;s a lot going on in the 8086&#39;s
interrupt system, both in hardware and microcode.
The 8086 has some strange characteristics, such as acknowledging interrupts twice, but these features make
more sense when looking at the 8086&#39;s history and what it inherited from the 8008 and 8080.&lt;/p&gt;
&lt;p&gt;I&#39;ve written multiple &lt;a href=&quot;https://www.righto.com/search/label/8086&quot;&gt;posts on the 8086&lt;/a&gt; so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.
Thanks to &lt;a href=&quot;https://news.ycombinator.com/item?id=34495797&quot;&gt;pwg&lt;/a&gt; on HN for suggesting interrupts as a topic.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:history&quot;&gt;
&lt;p&gt;The first computer to provide interrupts was probably the UNIVAC 1103A (1956).
The book &quot;Computer Architecture&quot; by Blaauw and Brooks discusses different approaches to interrupts in great
detail, pages 418-434.
A history of interrupts is in &lt;a href=&quot;http://www.cap-lore.com/Hardware/int.html&quot;&gt;this article&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:history&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:maskable&quot;&gt;
&lt;p&gt;The maskable interrupt can be blocked in software, while the non-maskable interrupt cannot be blocked.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:maskable&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:cycles&quot;&gt;
&lt;p&gt;A typical memory access takes four clock cycles. However, slow memory can add wait states, adding as many
clock cycles as necessary.  Moreover, accessing a word from an unaligned (odd) address results in two complete
bus cycles to access the two bytes, since the bus can only read an aligned word at a time. Thus, memory accesses
can take much more than four cycles.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:cycles&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:jenner&quot;&gt;
&lt;p&gt;The 8086&#39;s microcode was disassembled by Andrew Jenner (&lt;a href=&quot;https://www.reenigne.org/blog/8086-microcode-disassembled/&quot;&gt;link&lt;/a&gt;) from my die photos, so the microcode listings are based on his disassembly.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:jenner&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:jump&quot;&gt;
&lt;p&gt;The microcode jumps use a level of indirection because there isn&#39;t room in the micro-instruction for the
   full micro-address.
   Instead, the micro-instruction has a four-bit tag specifying the desired routine. The Translation ROM holds
   the corresponding micro-address for the routine, which is loaded into the microcode address register.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:jump&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:zero&quot;&gt;
&lt;p&gt;The &lt;code&gt;CR&lt;/code&gt; transfer source loads the low three bits of the microcode address. Its implementation is almost the
same as the &lt;code&gt;ZERO&lt;/code&gt; source, which loads zero. A signal zeroes bits 15-3 for both sources.
The bottom 3 bits are pulled low for the ZERO source or if the corresponding microcode bit is 0.
By the time this load happens, the microcode counter has incremented, so the value is one more than the address
with the micro-instruction.
Also note that it uses the raw 13-bit microcode address which is 9 bits plus four counter bits.
The address decoder converts this to the 9-bit &quot;physical&quot; microcode address that I&#39;m showing.
The point is that the 3 lower bits from my microcode listing won&#39;t give the right value.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:zero&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:int3&quot;&gt;
&lt;p&gt;The jump in the microcode is why the one-byte &lt;code&gt;INT 3&lt;/code&gt; instruction takes 52 clocks while the two-byte &lt;code&gt;INT nn&lt;/code&gt; instruction takes 51 clocks.
You&#39;d expect &lt;code&gt;INT nn&lt;/code&gt; to be slower because it has an extra byte to execute, but the microcode layout for &lt;code&gt;INT 3&lt;/code&gt;
makes it slower.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:int3&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:nmi&quot;&gt;
&lt;p&gt;There&#39;s a subtle difference between the NMI and the INTR interrupts. Once the NMI pin goes high, the interrupt
is scheduled, even if the pin goes low. For a regular interrupt, the INTR pin must be high at the start of
an instruction. Thus, NMI is latched but INTR is not.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:nmi&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:simultaneous&quot;&gt;
&lt;p&gt;Since the 8086 has multiple interrupt sources, you might wonder how multiple interrupts are handled at the
same time. The chip makes sure the interrupts are handled correctly, according to their priorities. The diagram below shows what happens
if trapping (single-step) is enabled, a divide causes a divide-by-0 exception, and an external interrupt arrives.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-interrupts/simultaneous-interrupts.jpg&quot;&gt;&lt;img alt=&quot;Processing simultaneous interrupts. From iAPX 86/88 User&#39;s Manual, Figure 2-31.&quot; class=&quot;hilite&quot; height=&quot;798&quot; src=&quot;https://static.righto.com/images/8086-interrupts/simultaneous-interrupts-w400.jpg&quot; title=&quot;Processing simultaneous interrupts. From iAPX 86/88 User&#39;s Manual, Figure 2-31.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Processing simultaneous interrupts. From &lt;a href=&quot;http://www.bitsavers.org/components/intel/_dataBooks/1981_iAPX_86_88_Users_Manual.pdf&quot;&gt;iAPX 86/88 User&#39;s Manual&lt;/a&gt;, Figure 2-31.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- --&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:simultaneous&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:delay&quot;&gt;
&lt;p&gt;The interrupt delay micro-instruction is used for the &lt;code&gt;WAIT&lt;/code&gt; machine instruction.
I think that a long string of prefix instructions will delay an interrupt (even an NMI) for an arbitrarily long
time.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:delay&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:fc&quot;&gt;
&lt;p&gt;Interrupts usually happen after the end of a machine instruction, rather than interrupting an instruction during
execution.
There are a couple of exceptions, however, for instructions that can take a very long time
to complete (block copies) or could take forever (&lt;code&gt;WAIT&lt;/code&gt;).
The solution is that the microcode for these instructions checks to see if an interrupt is pending, so the
instruction can explicitly stop and the interrupt can be handled.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:fc&quot; title=&quot;Jump back to footnote 11 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:mc-addr&quot;&gt;
&lt;p&gt;The microcode address is 13 bits long: a special bit, 8 instruction bits, and four counter bits.
For an interrupt, it is set to &lt;code&gt;1r0000000.00ab&lt;/code&gt;, where &lt;code&gt;r&lt;/code&gt; indicates a reset and &lt;code&gt;ab&lt;/code&gt; indicate an interrupt
of various types:
&lt;br/&gt;
Trap: goes to vector 1, INT1 addr 198 10000000.00
&lt;br/&gt;
NMI: goes to vector 2, INT2 addr 199 100000000.01 (Bit &lt;code&gt;b&lt;/code&gt; is NMI)
&lt;br/&gt;
INTR: goes to IRQ addr 19a 100000000.10, vector specified by device. Bit &lt;code&gt;a&lt;/code&gt; is intr-enable&#39;, blocked by NMI.
&lt;br/&gt;
This logic takes into account the relative priorities of the different interrupts.
This address is initialized through a special multiplexer path for interrupts that loads bits directly into
the microcode address latch.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:mc-addr&quot; title=&quot;Jump back to footnote 12 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:iak&quot;&gt;
&lt;p&gt;The &lt;code&gt;IAK&lt;/code&gt; micro-instruction is the same as a read micro-instruction except the &lt;code&gt;IAK&lt;/code&gt; (Interrupt Acknowledge) bit is set.
This bit controls the differences between a read micro-instruction and an interrupt acknowledge micro-instruction.&lt;/p&gt;
&lt;p&gt;The logic that makes the bus cycle an interrupt acknowledge rather than a read is a bit strange.
A signal indicates that the cycle is an I/O operation or an interrupt acknowledge.
This is determined by the instruction decoder (for I/O) or bit &lt;code&gt;P&lt;/code&gt; of the microcode (for an interrupt acknowledge).
This signal is used for the S2 status pin.
Later, this signal is ANDed with the read/write signal to determine that it is an interrupt acknowledge and
not an I/O. 
This probably optimized signal generation, but it seems inconvenient to merge two signals together and then
split them out later.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:iak&quot; title=&quot;Jump back to footnote 13 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:minimum&quot;&gt;
&lt;p&gt;The 8086 has two different modes, giving its pins different meanings in the different modes.
In &quot;Minimum&quot; mode, the control pins have simple functions. In particular, the interrupt is acknowledged using the INTA pin.
In &quot;Maximum&quot; mode, the control pins are encoded to provide more state information to a bus controller.
In this mode, the interrupt acknowledge state is encoded and signaled over the S2, S1, and S0 state pins.
I&#39;m discussing minimum mode; the sequence is the same in maximum mode but uses different pins.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:minimum&quot; title=&quot;Jump back to footnote 14 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:bus-logic&quot;&gt;
&lt;p&gt;To prevent another device from grabbing the bus during interrupt acknowledgement, the LOCK pin is activated.
The hardware for this LOCK signal toggles the internal lock latch on each of the interrupt ALE signals, so the lock is enabled on the first one and disabled on the second.
The interrupt ack signal also prevents the address lines from being enabled during the interrupt ack.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:bus-logic&quot; title=&quot;Jump back to footnote 15 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:8259A&quot;&gt;
&lt;p&gt;An 8086/8088 system will typically use an external chip, the &lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2017/readings/hardware/8259A.pdf&quot;&gt;8259A&lt;/a&gt; Programmable Interrupt Controller.
This chip extends the interrupt functionality of the 8086 by providing 8 priority-based hardware interrupts.&lt;/p&gt;
&lt;p&gt;The Intel 8259A Programmable Interrupt Controller chip was designed to receive interrupt
requests from multiple devices, prioritize interrupts, and direct the 8080 or 8086 processor accordingly.
When used with the 8080, the interrupt controller chip will issue a &lt;code&gt;CALL&lt;/code&gt; instruction to execute the
specified interrupt handler.
In particular, when the 8080 responds to an interrupt with &lt;code&gt;INTA&lt;/code&gt; pulses, the interrupt controller chip will
first put a &lt;code&gt;CALL&lt;/code&gt; instruction on the bus, and then will respond to the next two &lt;code&gt;INTA&lt;/code&gt; pulses with the
address.
For the 8086, the interrupt controller ignores the first &lt;code&gt;INTA&lt;/code&gt; pulse and responds to the second &lt;code&gt;INTA&lt;/code&gt; pulse with the 8-bit pointer.
The point of this is that for both processors, the interrupt controller freezes its state on the first &lt;code&gt;INTA&lt;/code&gt; and sends the interrupt-specific byte on the second &lt;code&gt;INTA&lt;/code&gt;.
Thus, even though the interrupt controller responds to the 8080 with an instruction and responds to the 8086 with an interrupt code,
the underlying timing and logic are mostly the same.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:8259A&quot; title=&quot;Jump back to footnote 16 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:8008&quot;&gt;
&lt;p&gt;The article &lt;a href=&quot;https://stevemorse.org/8086history/8086history.pdf&quot;&gt;Intel Microprocessors: 8008 to 8086&lt;/a&gt;
provides some history on interrupts in the 8008.
Also see &lt;a href=&quot;https://archive.computerhistory.org/resources/access/text/2012/07/102657982-05-01-acc.pdf&quot;&gt;Intel 8008 Microprocessor Oral History Panel&lt;/a&gt;, pages 5-6.
Most of the 8008&#39;s features were inherited from the Datapoint 2200 desktop computer, but the interrupts were
not part of the Datapoint 2200. Instead, Intel decided to add interrupt functionality.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:8008&quot; title=&quot;Jump back to footnote 17 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/6015138995640807347/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=6015138995640807347' title='4 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/6015138995640807347'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/6015138995640807347'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/02/8086-interrupt.html' title='Reverse-engineering the interrupt circuitry in the Intel 8086 processor'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-7081929788601606905</id><published>2023-02-13T09:30:00.002-08:00</published><updated>2023-02-18T11:22:41.167-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="analog"/><category scheme="http://www.blogger.com/atom/ns#" term="cadc"/><category scheme="http://www.blogger.com/atom/ns#" term="electronics"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>Reverse-engineering an electromechanical Central Air Data Computer</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
&lt;/style&gt;
&lt;script src=&quot;https://polyfill.io/v3/polyfill.min.js?features=es6&quot;&gt;&lt;/script&gt;
&lt;script id=&quot;MathJax-script&quot; async src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
MathJax = {
  tex: {
    inlineMath: [[&#39;$&#39;, &#39;$&#39;], [&#39;\\(&#39;, &#39;\\)&#39;]]
  },
  svg: {
    fontCache: &#39;global&#39;
  },
        chtml: { displayAlign: &#39;left&#39; }
};
&lt;/script&gt;
&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    &quot;HTML-CSS&quot;: { scale: 175}
  });
&lt;/script&gt;
&lt;style type=&quot;text/css&quot;&gt;
.MathJax {font-size: 1em !important}
&lt;/style&gt;

&lt;p&gt;Determining the airspeed and altitude of a fighter plane is harder than you&#39;d expect.
At slower speeds, pressure measurements can give the altitude, air speed, and other &quot;air data&quot;.
But as planes approach the speed of sound, complicated equations
are needed to accurately compute these values.
The Bendix Central Air Data Computer (CADC) solved this problem for
military planes such as the F-101 and the F-111 fighters, and the B-58 bomber.&lt;span id=&quot;fnref:uses&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:uses&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
This electromechanical marvel was crammed full of 1955 technology: gears, cams, synchros, and magnetic amplifiers.
In this blog post I look inside the CADC, describe the calculations it performed, and explain how it performed
these calculations mechanically.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/cadc-opened.jpg&quot;&gt;&lt;img alt=&quot;The Bendix MG-1A Central Air Data Computer with the case removed, showing the complex mechanisms inside. Click this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;740&quot; src=&quot;https://static.righto.com/images/bendix-overview/cadc-opened-w450.jpg&quot; title=&quot;The Bendix MG-1A Central Air Data Computer with the case removed, showing the complex mechanisms inside. Click this image (or any other) for a larger version.&quot; width=&quot;450&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Bendix MG-1A Central Air Data Computer with the case removed, showing the complex mechanisms inside. Click this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;This analog computer performs calculations using rotating shafts and gears, where the angle of rotation indicates a numeric value.
Differential gears perform addition and subtraction, while cams implement functions.
The CADC is electromechanical, with magnetic amplifiers providing feedback signals and three-phase synchros providing electrical outputs.
It is said to contain 46 synchros, 511 gears, 820 ball bearings, and a total of 2,781 major parts.
The photo below shows a closeup of the gears.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/gears.jpg&quot;&gt;&lt;img alt=&quot;A closeup of the complex gears inside the CADC,&quot; class=&quot;hilite&quot; height=&quot;367&quot; src=&quot;https://static.righto.com/images/bendix-overview/gears-w600.jpg&quot; title=&quot;A closeup of the complex gears inside the CADC,&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A closeup of the complex gears inside the CADC,&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;What it does&lt;/h2&gt;
&lt;p&gt;For over a &lt;a href=&quot;https://patents.google.com/patent/US1290875A&quot;&gt;century&lt;/a&gt;, aircraft have determined airspeed from
air pressure.
A port in the side of the plane provides the static air pressure,&lt;span id=&quot;fnref:static&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:static&quot;&gt;2&lt;/a&gt;&lt;/span&gt; which is the air pressure outside the aircraft.
A pitot tube points forward and receives the &quot;total&quot; air pressure, a higher pressure due to the speed of the airplane
forcing air into the tube.
(In the photo below, you can see the long pitot tube sticking out from the nose of a F-101.)
The airspeed can be determined from the ratio of these two pressures, while the altitude can be determined
from the static pressure.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/f-101.jpg&quot;&gt;&lt;img alt=&quot;The F-101 &amp;quot;Voodoo&amp;quot;, USAF photo. &quot; class=&quot;hilite&quot; height=&quot;313&quot; src=&quot;https://static.righto.com/images/bendix-overview/f-101-w500.jpg&quot; title=&quot;The F-101 &amp;quot;Voodoo&amp;quot;, USAF photo. &quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The F-101 &quot;Voodoo&quot;, &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:McDonnell_F-101_Voodoo.jpg&quot;&gt;USAF photo&lt;/a&gt;. &lt;/div&gt;&lt;/p&gt;
&lt;p&gt;But as you approach the speed of sound, the fluid dynamics of air change and the calculations become very complicated.
With the development of supersonic fighter planes in the 1950s, simple mechanical instruments were no longer
sufficient.
Instead, an analog computer to calculate the &quot;air data&quot; (airspeed, altitude, and so forth) from the pressure measurements.
One option would be for each subsystem (instruments, weapons control, engine control, etc) to compute the air data separately.
However, it was more efficient to have one central system perform the computation and provide the data electrically
to all the subsystems that need it.
This system was called a Central Air Data Computer or CADC.&lt;/p&gt;
&lt;p&gt;The Bendix CADC has two pneumatic inputs through tubes:
the static pressure&lt;span id=&quot;fnref:pec&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:pec&quot;&gt;3&lt;/a&gt;&lt;/span&gt; and the total pressure.
It also receives the total temperature from a platinum temperature probe.
From these, it computes many outputs: true air speed, Mach number, log static pressure, differential pressure, air density, air density &amp;times; the speed of sound, total temperature, and log true free air temperature.&lt;/p&gt;
&lt;p&gt;The CADC implemented a surprisingly complex set of functions derived from fluid dynamics equations describing the behavior of air at various speeds and conditions.
First, the Mach number is computed from the ratio of total pressure to static pressure.
Different equations are required for subsonic and supersonic flight.
Although this equation looks difficult to solve mathematically, fundamentally M is a function of one variable ($P_t / P_s$),
and this function is encoded in the shape of a cam.
(You are not expected to understand the equations below. They are just to illustrate the complexity of what the CADC does.)&lt;/p&gt;
&lt;p&gt;\[M&amp;lt;1:\]
\[~~~\frac{P_t}{P_s} = ( 1+.2M^2)^{3.5}\]&lt;/p&gt;
&lt;p&gt;\[M &amp;gt; 1:\]&lt;/p&gt;
&lt;p&gt;\[~~~\frac{P_t}{P_s} = \frac{166.9215M^7}{( 7M^2-1)^{2.5}}\]&lt;/p&gt;
&lt;p&gt;Next, the temperature is determined from the Mach number and the temperature indicated by a temperature probe.&lt;/p&gt;
&lt;p&gt;\[T = \frac{T_{ti}}{1 + .2 M^2} \]&lt;/p&gt;
&lt;!--
\\[V = 38.94 M \sqrt{T} \\]
--&gt;

&lt;p&gt;The indicated airspeed and other outputs are computed in turn, but I won&#39;t go through all the equations.
Although these equations may seem &lt;em&gt;ad hoc&lt;/em&gt;, they can be derived from fluid dynamics principles.
These equations were standardized in the 1950s by various government organizations including the National
Bureau of Standards and NACA (the precursor of NASA).
While the equations are complicated, they can be computed with mechanical means.&lt;/p&gt;
&lt;!-- Problems at Mach before Air Data Computer: https://www.f-16.net/forum/viewtopic.php?f=2&amp;t=52492 --&gt;

&lt;h2&gt;How it is implemented&lt;/h2&gt;
&lt;p&gt;The Air Data Computer is an analog computer that determines various functions of the static pressure, total pressure and temperature.
An analog computer was selected for this application because the inputs are analog and the outputs are analog, so
it seemed simplest to keep the computations analog and avoid conversions.
The computer performs its computations mechanically, using the rotation angle of shafts to indicate values.
For the most part, values are represented logarithmically, which allows multiplication and division to be implemented
by adding and subtracting rotations.
A differential gear mechanism provides the underlying implementation of addition and subtraction.
Specially-shaped cams provide the logarithmic and exponential conversions as necessary.
Other cams implement various arbitrary functions.&lt;/p&gt;
&lt;p&gt;The diagram below, from &lt;a href=&quot;https://patents.google.com/patent/US2969910A&quot;&gt;patent 2,969,210&lt;/a&gt;, shows some of the operations.
At the left, transducers convert the pressure and temperature inputs from physical quantities into shaft rotations,
applying a log function in the process.
Subtracting the two pressures with a differential gear mechanism (X-in-circle symbol) produces the log of the pressure ratios.
Cam &quot;CCD 12&quot; generates the Mach number from this log pressure ratio, still expressed as a shaft rotation.
A synchro transmitter converts the shaft rotation into a three-phase electrical output from the CADC.
The remainder of the diagram uses more cams and differentials to produce the other outputs.
Next, I&#39;ll discuss how these steps are implemented.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/patent-diagram.png&quot;&gt;&lt;img alt=&quot;A diagram showing how values are computed by the CADC. Source: Patent 2969910A&amp;quot;&amp;gt;Patent 2969910.&quot; class=&quot;hilite&quot; height=&quot;348&quot; src=&quot;https://static.righto.com/images/bendix-overview/patent-diagram-w700.png&quot; title=&quot;A diagram showing how values are computed by the CADC. Source: Patent 2969910A&amp;quot;&amp;gt;Patent 2969910.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A diagram showing how values are computed by the CADC. Source: &lt;a href=&quot;https://patents.google.com/patent/US2969910A&lt;/a&gt;Patent 2969910A&quot;&gt;Patent 2969910&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;The pressure transducer&lt;/h3&gt;
&lt;p&gt;The CADC receives the static and total pressure through tubes connected to the front of the CADC.
(At the lower right, one of these tubes is visible.)
Inside the CADC, two pressure transducers convert the pressures into rotational signals.
The pressure transducers are the black domed cylinders at the top of the CADC.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/pressure-transducers.jpg&quot;&gt;&lt;img alt=&quot;The pressure transducers are the two black domes at the top. The circuit boards next to each pressure transducer are the amplifiers. The yellowish transformer-like devices with three windings are the magnetic amplifiers.&quot; class=&quot;hilite&quot; height=&quot;535&quot; src=&quot;https://static.righto.com/images/bendix-overview/pressure-transducers-w450.jpg&quot; title=&quot;The pressure transducers are the two black domes at the top. The circuit boards next to each pressure transducer are the amplifiers. The yellowish transformer-like devices with three windings are the magnetic amplifiers.&quot; width=&quot;450&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The pressure transducers are the two black domes at the top. The circuit boards next to each pressure transducer are the amplifiers. The yellowish transformer-like devices with three windings are the magnetic amplifiers.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Each pressure transducer contains a pair of bellows that
expand and contract as the applied pressure changes. They are connected to opposite sides of a shaft so they
cause small rotations of the shaft.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/bellows.jpg&quot;&gt;&lt;img alt=&quot;Inside the pressure transducer. The two disc-shaped bellows are connected to opposite sides of a shaft so the shaft rotates as the bellows expand or contract.&quot; class=&quot;hilite&quot; height=&quot;375&quot; src=&quot;https://static.righto.com/images/bendix-overview/bellows-w500.jpg&quot; title=&quot;Inside the pressure transducer. The two disc-shaped bellows are connected to opposite sides of a shaft so the shaft rotates as the bellows expand or contract.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Inside the pressure transducer. The two disc-shaped bellows are connected to opposite sides of a shaft so the shaft rotates as the bellows expand or contract.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The pressure transducer has a tricky job: it must measure tiny pressure changes, but it must also provide a
rotational signal that has enough torque to rotate all the gears in the CADC.
To accomplish this, the pressure transducer uses a servo loop.
The bellows produce a small shaft motion that is detected by an inductive pickup.
This signal is amplified and drives a motor with enough power to move all the gears.
The motor is also geared to counteract the movement of the bellows.
This creates a feedback loop so the motor&#39;s rotation tracks the air pressure, but provides much more force.
A cam is used so the output corresponds to the log of the input pressure.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/transducer-diagram.jpg&quot;&gt;&lt;img alt=&quot;This diagram shows the structure of the transducer. From &amp;quot;Air Data Computer Mechanization.&amp;quot;&quot; class=&quot;hilite&quot; height=&quot;327&quot; src=&quot;https://static.righto.com/images/bendix-overview/transducer-diagram-w500.jpg&quot; title=&quot;This diagram shows the structure of the transducer. From &amp;quot;Air Data Computer Mechanization.&amp;quot;&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This diagram shows the structure of the transducer. From &quot;Air Data Computer Mechanization.&quot;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Each transducer signal is amplified by three circuit boards centered around a &lt;a href=&quot;https://spectrum.ieee.org/the-vacuum-tubes-forgotten-rival&quot;&gt;magnetic amplifier&lt;/a&gt;,
a transformer-like amplifier circuit that was popular before high-power transistors came along.
The photo below shows how the amplifier boards are packed next to the transducers.
The boards are complex, filled with resistors, capacitors, germanium transistors, diodes, relays, and other components.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/end-view.jpg&quot;&gt;&lt;img alt=&quot;This end-on view of the CADC shows the pressure transducers, the black cylinders. Next to each pressure transducer is a complex amplifier consisting of multiple boards with transistors and other components. The magnetic amplifiers are the yellowish transformer-like components.&quot; class=&quot;hilite&quot; height=&quot;460&quot; src=&quot;https://static.righto.com/images/bendix-overview/end-view-w500.jpg&quot; title=&quot;This end-on view of the CADC shows the pressure transducers, the black cylinders. Next to each pressure transducer is a complex amplifier consisting of multiple boards with transistors and other components. The magnetic amplifiers are the yellowish transformer-like components.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This end-on view of the CADC shows the pressure transducers, the black cylinders. Next to each pressure transducer is a complex amplifier consisting of multiple boards with transistors and other components. The magnetic amplifiers are the yellowish transformer-like components.&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;Temperature&lt;/h3&gt;
&lt;p&gt;The external temperature is an important input to the CADC since it affects the air density.
A platinum temperature probe provides a resistance&lt;span id=&quot;fnref:ohms&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:ohms&quot;&gt;4&lt;/a&gt;&lt;/span&gt; that varies with temperature.
The resistance is converted to rotation by an electromechanical transducer mechanism.
Like the pressure transducer, the temperature transducer uses a servo mechanism with an amplifier and feedback loop.
For the temperature transducer, though, the feedback signal is generated by a resistance bridge using a potentiometer driven
by the motor.
By balancing the potentiometer&#39;s resistance with the platinum probe&#39;s resistance, a shaft rotation is produced that
corresponds to the temperature. The cam is configured to produce the log of the temperature as output.&lt;/p&gt;
&lt;!-- https://navyaviation.tpub.com/14009/Figure-2-36-Test-Set-Ttu-205C-E-68.html --&gt;

&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/temperature-transducer.jpg&quot;&gt;&lt;img alt=&quot;This diagram shows the structure of the temperature transducer. From &amp;quot;Air Data Computer Mechanization.&amp;quot;&quot; class=&quot;hilite&quot; height=&quot;304&quot; src=&quot;https://static.righto.com/images/bendix-overview/temperature-transducer-w500.jpg&quot; title=&quot;This diagram shows the structure of the temperature transducer. From &amp;quot;Air Data Computer Mechanization.&amp;quot;&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This diagram shows the structure of the temperature transducer. From &quot;Air Data Computer Mechanization.&quot;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The temperature transducer section of the CADC is shown below. The feedback potentiometer is the red cylinder at the lower right.
Above it is a metal-plate adjustment cam, which will be discussed below.
The CADC is designed in a somewhat modular way, with the temperature section implemented as a removable wedge-shaped unit, the lower two-thirds of the photo.
The temperature transducer, like the pressure transducer, has three boards of electronics to implement the feedback amplifier and drive the motor.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/temperature2.jpg&quot;&gt;&lt;img alt=&quot;The temperature transducer section of the CADC.&quot; class=&quot;hilite&quot; height=&quot;356&quot; src=&quot;https://static.righto.com/images/bendix-overview/temperature2-w500.jpg&quot; title=&quot;The temperature transducer section of the CADC.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The temperature transducer section of the CADC.&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;The differential&lt;/h3&gt;
&lt;p&gt;The differential gear assembly is a key component of the CADC&#39;s calculations, as it performs addition or subtraction of rotations: the rotation of the output shaft is the sum or difference of the input shafts, depending on the direction of rotation.&lt;span id=&quot;fnref:differential&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:differential&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
When rotations are expressed logarithmically, addition and subtraction correspond to multiplication and division.
This differential is constructed as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Differential_(mechanical_device)#Spur-gear_differential&quot;&gt;spur-gear differential&lt;/a&gt;.
It has inputs at the top and bottom, while the body of the differential rotates to produce the sum.
The two visible gears in the body mesh with the internal input gears, which are not visible.
The output is driven by the body through a concentric shaft.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/differential-closeup.png&quot;&gt;&lt;img alt=&quot;A closeup of a differential mechanism.&quot; class=&quot;hilite&quot; height=&quot;380&quot; src=&quot;https://static.righto.com/images/bendix-overview/differential-closeup-w400.png&quot; title=&quot;A closeup of a differential mechanism.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A closeup of a differential mechanism.&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;The cams&lt;/h3&gt;
&lt;p&gt;The CADC uses cams to implement various functions. Most importantly, cams perform logarithms and exponentials.
Cams also implement more complex functions of one variable such as ${M}/{\sqrt{1 + .2 M^2}}$.
The photo below shows a cam (I think exponential) with the follower arm in front. As the cam rotates, the follower
moves in and out according to the cam&#39;s radius, providing the function value.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/cam.jpg&quot;&gt;&lt;img alt=&quot;A cam inside the CADC implements a function.&quot; class=&quot;hilite&quot; height=&quot;444&quot; src=&quot;https://static.righto.com/images/bendix-overview/cam-w500.jpg&quot; title=&quot;A cam inside the CADC implements a function.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A cam inside the CADC implements a function.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The cams are combined with a differential in a clever way to make the cam shape more practical, as shown below.&lt;span id=&quot;fnref:cam-shape&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:cam-shape&quot;&gt;6&lt;/a&gt;&lt;/span&gt;
The input (23) drives the cam (30) and the
differential (37-41). The follower (32) tracks the cam and provides a second input (35) to the differential.
The sum from the differential produces the output (26).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/differential-patent.png&quot;&gt;&lt;img alt=&quot;This diagram, from Patent 2969910, shows how the cam and follower are connected to a differential.&quot; class=&quot;hilite&quot; height=&quot;312&quot; src=&quot;https://static.righto.com/images/bendix-overview/differential-patent-w350.png&quot; title=&quot;This diagram, from Patent 2969910, shows how the cam and follower are connected to a differential.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This diagram, from &lt;a href=&quot;https://patents.google.com/patent/US2969910A&quot;&gt;Patent 2969910&lt;/a&gt;, shows how the cam and follower are connected to a differential.&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;The warped plate cam&lt;/h3&gt;
&lt;p&gt;Some functions are implemented by warped metal plates acting as cams.
This type of cam can be adjusted by turning the 20 setscrews to change the shape of the plate.
A follower rides on the surface of the cam and provides an input to a differential underneath the plate.
The differential adds the cam position to the input rotation, producing a modified rotation, as with the solid cam.
The pressure transducer, for instance, uses a cam to generate the desired output function from the bellows deflection.
By using a cam, the bellows can be designed for good performance without worrying about its deflection function.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/plate.jpg&quot;&gt;&lt;img alt=&quot;A closeup of a warped-plate cam.&quot; class=&quot;hilite&quot; height=&quot;462&quot; src=&quot;https://static.righto.com/images/bendix-overview/plate-w500.jpg&quot; title=&quot;A closeup of a warped-plate cam.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A closeup of a warped-plate cam.&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;The synchro outputs&lt;/h3&gt;
&lt;p&gt;Most of the outputs from the CADC are synchro signals.&lt;span id=&quot;fnref:synchros&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:synchros&quot;&gt;7&lt;/a&gt;&lt;/span&gt;
A synchro is an interesting device that can transmit a rotational position electrically over three wires.
In appearance, a synchro is similar to an electric motor, but its internal construction is different, as shown below.
In use, two synchros have their stator windings connected together, while the rotor windings are driven with
AC.
Rotating the shaft of one synchro causes the other to rotate to the same position.
I have a video showing synchros in action &lt;a href=&quot;https://twitter.com/kenshirriff/status/1602741647032606720&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/synchro-cutaway.png&quot;&gt;&lt;img alt=&quot;Cross-section diagram of a synchro showing the rotor and stators.&quot; class=&quot;hilite&quot; height=&quot;306&quot; src=&quot;https://static.righto.com/images/bendix-overview/synchro-cutaway-w350.png&quot; title=&quot;Cross-section diagram of a synchro showing the rotor and stators.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Cross-section diagram of a synchro showing the rotor and stators.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Internally, a synchro has a moving rotor winding and three fixed stator windings.
When AC is applied to the rotor, voltages are developed on the stator windings depending on the position of the rotor.
These voltages produce a torque that rotates the synchros to the same position.
In other words, the rotor receives power (26 V, 400 Hz in this case), while the three stator wires transmit the position.
The diagram below shows how a synchro is represented schematically, with rotor and stator coils.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/synchro-symbol.jpg&quot;&gt;&lt;img alt=&quot;The schematic symbol for a synchro.&quot; class=&quot;hilite&quot; height=&quot;240&quot; src=&quot;https://static.righto.com/images/bendix-overview/synchro-symbol-w250.jpg&quot; title=&quot;The schematic symbol for a synchro.&quot; width=&quot;250&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The schematic symbol for a synchro.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Before digital systems, synchros were very popular for transmitting signals electrically through an aircraft.
For instance, a synchro could transmit an altitude reading to a cockpit display or a targeting system.
For the CADC, most of the outputs are synchro signals, which convert the rotational values of the CADC
to electrical signals. The three stator windings from the synchro inside the CADC are wired to an external
synchro that receives the rotation.
For improved resolution, many of these outputs use two synchros: a coarse synchro and a fine synchro.
The two synchros are typically geared in an 11:1 ratio, so the fine synchro rotates 11 times as fast as the coarse
synchro.
Over the output range, the coarse synchro may turn 180&amp;deg;, providing the approximate output, while the fine
synchro spins multiple times to provide more accuracy.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/top.jpg&quot;&gt;&lt;img alt=&quot;The front of the CADC has multiple output synchros with anti-backlash springs.&quot; class=&quot;hilite&quot; height=&quot;498&quot; src=&quot;https://static.righto.com/images/bendix-overview/top-w600.jpg&quot; title=&quot;The front of the CADC has multiple output synchros with anti-backlash springs.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The front of the CADC has multiple output synchros with anti-backlash springs.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The air data system&lt;/h2&gt;
&lt;p&gt;The CADC is one of several units in the system, as shown in the block diagram below.&lt;span id=&quot;fnref:symbols&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:symbols&quot;&gt;8&lt;/a&gt;&lt;/span&gt;
The outputs of the CADC go to another box called the Air Data Converter, which is the interface between
the CADC and the aircraft systems that require the air data values: fire control, engine control, navigation system,
cockpit display instruments, and so forth.
The motivation for this separation is that different aircraft types
have different requirements for signals: the CADC remains the same and only the converter needed to be customized.
Some aircraft required &quot;up to 43 outputs including potentiometers, synchros, digitizers, and switches.&quot;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/system-diagram.jpg&quot;&gt;&lt;img alt=&quot;This block diagram shows how the Air Data Computer integrates with sensors and other systems. The unlabeled box on the right is the converter. From MIL-C-25653C(USAF).&quot; class=&quot;hilite&quot; height=&quot;489&quot; src=&quot;https://static.righto.com/images/bendix-overview/system-diagram-w500.jpg&quot; title=&quot;This block diagram shows how the Air Data Computer integrates with sensors and other systems. The unlabeled box on the right is the converter. From MIL-C-25653C(USAF).&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This block diagram shows how the Air Data Computer integrates with sensors and other systems. The unlabeled box on the right is the converter. From MIL-C-25653C(USAF).&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The CADC was also connected to a cylindrical unit called the &quot;Static pressure and angle of attack compensator.&quot;
This unit compensates for errors in static pressure measurements due to the shape of the aircraft by producing the
&quot;position error correction&quot;.
Since the compensation factor depended on the specific aircraft type, the compensation was computed outside
the Central Air Data Computer, again keeping the CADC generic.
This correction factor depends on the Mach number and angle of attack, and was implemented as a three-dimensional
cam.
The cam&#39;s shape (and thus the correction function) was determined empirically, rather than from fundamental equations.&lt;/p&gt;
&lt;p&gt;The CADC was wired to other components through five electrical connectors as shown in the photo below.&lt;span id=&quot;fnref:connectors&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:connectors&quot;&gt;9&lt;/a&gt;&lt;/span&gt;
At the bottom are the pneumatic connections for static pressure and total pressure.
At the upper right is a small elapsed time meter.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/front.jpg&quot;&gt;&lt;img alt=&quot;The front of the CADC has many mil-spec round connectors.&quot; class=&quot;hilite&quot; height=&quot;502&quot; src=&quot;https://static.righto.com/images/bendix-overview/front-w500.jpg&quot; title=&quot;The front of the CADC has many mil-spec round connectors.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The front of the CADC has many mil-spec round connectors.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The Bendix MG-1A Central Air Data Computer is an amazingly complex piece of electromechanical hardware.
It&#39;s hard to believe that this system of tiny gears was able to perform reliable computations in the hostile
environment of a jet plane, subjected to jolts, accelerations, and vibrations.
But it was the best way to solve the problem at the time,&lt;span id=&quot;fnref:sliderule&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:sliderule&quot;&gt;10&lt;/a&gt;&lt;/span&gt; showing the ingenuity of the engineers who
developed it.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/exterior.jpg&quot;&gt;&lt;img alt=&quot;The CADC inside its case. From the outside, its mechanical marvels are hidden.&quot; class=&quot;hilite&quot; height=&quot;470&quot; src=&quot;https://static.righto.com/images/bendix-overview/exterior-w300.jpg&quot; title=&quot;The CADC inside its case. From the outside, its mechanical marvels are hidden.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The CADC inside its case. From the outside, its mechanical marvels are hidden.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;I plan to continue reverse-engineering the Bendix CADC and hope to get it operational,&lt;span id=&quot;fnref:refs&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:refs&quot;&gt;11&lt;/a&gt;&lt;/span&gt;
so follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.
Until then, you can check out CuriousMarc&#39;s video below to see more of the CADC.
Thanks to Joe for providing the CADC. Thanks to Nancy Chen for obtaining a hard-to-find document for me.&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/D-wHIDnnQwQ&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&gt;&lt;/iframe&gt;

&lt;!--
![The Bendix MG-1A Central Air Data Computer with the case removed, showing the complex mechanisms inside.](opened1.jpg &quot;w500&quot;)

![The CADC with the cover removed but the front panel in place.](opened2.jpg &quot;w500&quot;)
--&gt;

&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:uses&quot;&gt;
&lt;p&gt;I haven&#39;t found a definitive list of which planes used this CADC.
Based on various sources, I believe it was used in the
F-86, F-101, F-104, F-105, F-106, and F-111, and the B-58 bomber.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:uses&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:static&quot;&gt;
&lt;p&gt;The static air pressure can also be provided by holes in the side of the pitot tube.
I couldn&#39;t find information indicating exactly how these planes received static pressure.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:static&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:pec&quot;&gt;
&lt;p&gt;The CADC also has an input for the &quot;position error correction&quot;.
This provides a correction factor because the measured static pressure may not
exactly match the real static pressure. The problem is that the static pressure is measured from a port on the
aircraft. Distortions in the airflow may cause errors in this measurement.
A separate box, the &quot;compensator&quot;, determines the correction factor based on the angle of attack.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:pec&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:ohms&quot;&gt;
&lt;p&gt;The platinum temperature probe is type MA-1, defined by specification MIL-P-25726. It apparently has a resistance of 50 &amp;Omega; at 0 &amp;deg;C.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:ohms&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:differential&quot;&gt;
&lt;p&gt;Strictly speaking, the output of the differential is the sum of the inputs divided by two.
I&#39;m ignoring the factor of 2 because the gear ratios can easily cancel it out.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:differential&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:cam-shape&quot;&gt;
&lt;p&gt;Cams are extensively used in the CADC to implement functions of one variable, including exponentiation and logarithms.
The straightforward way to use a cam is to read the value of the function off the cam directly, with the radius
of the cam at each angle representing the value.
This approach encounters a problem when the cam wraps around, since the cam&#39;s profile will suddenly jump from
one value to another.
This poses a problem for the cam follower, which may get stuck on this part of the cam unless there is a smooth transition zone.
Another problem is that the cam may have a large range between the minimum and maximum outputs.
(Consider an exponential output, for instance.) Scaling the cam to a reasonable size will lose accuracy in the
small values. The cam will also have a steep slope for the large values, making it harder to track the profile.&lt;/p&gt;
&lt;p&gt;The solution is to record the &lt;em&gt;difference&lt;/em&gt; between the input and the output in the cam. A differential then
adds the input value to the cam value to produce the desired value.
The clever part is that by scaling the input so it matches the output at the start and end of the range,
the difference function drops to zero at both ends.
Thus, the cam profile matches when the angle wraps around, avoiding the sudden transition.
Moreover, the difference between the input and the output is much smaller than the raw output, so the cam
values can be more accurate.
(This only works because the output functions are increasing functions; this approach wouldn&#39;t work for
a sine function, for instance.)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/cam-diagram.jpg&quot;&gt;&lt;img alt=&quot;This diagram, from Patent 2969910, shows how a cam implements a complex function.&quot; class=&quot;hilite&quot; height=&quot;439&quot; src=&quot;https://static.righto.com/images/bendix-overview/cam-diagram-w350.jpg&quot; title=&quot;This diagram, from Patent 2969910, shows how a cam implements a complex function.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This diagram, from &lt;a href=&quot;https://patents.google.com/patent/US2969910A&quot;&gt;Patent 2969910&lt;/a&gt;, shows how a cam implements a complex function.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The diagram above shows how this works in practice. The input is \(log~ dP/P_s\)
and the output is \(log~M / \sqrt{1+.2KM^2}\).
(This is a function of Mach number used for the temperature computation; K is 1.)
The small humped curve at the bottom is the cam correction.
Although the input and output functions cover a wide range, the difference that is encoded in the cam is much
smaller and drops to zero at both ends.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:cam-shape&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:synchros&quot;&gt;
&lt;p&gt;The US Navy made heavy use of synchros for transmitting signals throughout ships.
The synchro diagrams are from two US Navy publications:
&lt;a href=&quot;https://maritime.org/doc/pdf/synchros.pdf&quot;&gt;US Navy Synchros&lt;/a&gt; (1944) and
&lt;a href=&quot;http://www.compatt.com/Tutorials/NEETS/New_PDF/14187A.pdf&quot;&gt;Principles of Synchros, Servos, and Gyros&lt;/a&gt; (2012).
These are good documents if you want to learn more about synchros.
The diagram below shows how synchros could be used on a ship.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/bendix-overview/navy-gun.jpg&quot;&gt;&lt;img alt=&quot;A Navy diagram illustrating synchros controlling a gun on a battleship. &quot; class=&quot;hilite&quot; height=&quot;309&quot; src=&quot;https://static.righto.com/images/bendix-overview/navy-gun-w600.jpg&quot; title=&quot;A Navy diagram illustrating synchros controlling a gun on a battleship. &quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A Navy diagram illustrating synchros controlling a gun on a battleship. &lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- --&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:synchros&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:symbols&quot;&gt;
&lt;p&gt;To summarize the symbols, the outputs are:
log T&lt;sub&gt;FAT&lt;/sub&gt;: true free air temperature (the ambient temperature without friction and compression);
log P&lt;sub&gt;s&lt;/sub&gt;: static pressure;
M: Mach number;
Q&lt;sub&gt;c&lt;/sub&gt;: differential pressure;
&amp;rho;: air density;
&amp;rho;a: air density times the speed of sound;
V&lt;sub&gt;t&lt;/sub&gt;: true airspeed.
T&lt;sub&gt;t&lt;/sub&gt;: &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_air_temperature&quot;&gt;total temperature&lt;/a&gt; (higher due to compression of the air).
Inputs are:
T&lt;sub&gt;T&lt;/sub&gt;: &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_air_temperature&quot;&gt;total temperature&lt;/a&gt; (higher due to compression of the air).
P&lt;sub&gt;ti&lt;/sub&gt;: indicated &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_pressure&quot;&gt;total pressure&lt;/a&gt; (higher due to velocity);
P&lt;sub&gt;si&lt;/sub&gt;: indicated static pressure;
log P&lt;sub&gt;si&lt;/sub&gt;/P&lt;sub&gt;s&lt;/sub&gt;: the position error correction from the compensator.
The compensator uses input &amp;alpha;&lt;sub&gt;i&lt;/sub&gt;: angle of attack;
and produces &amp;alpha;&lt;sub&gt;T&lt;/sub&gt;: true angle of attack;
a&lt;sub&gt;T&lt;/sub&gt;: speed of sound.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:symbols&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:connectors&quot;&gt;
&lt;p&gt;The electrical connectors on the CADC have the following functions:
J614: outputs to the converter,
J601: outputs  to the converter,
J603: AC power (115 V, 400 Hz),
J602: to/from the compensator,
and J604: input from the temperature probe.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:connectors&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:sliderule&quot;&gt;
&lt;p&gt;An interesting manual way to calculate air data was with a circular slide rule, designed for navigation and air data calculation.
It gave answers for various combinations of pressure, temperature, Mach number, true airspeed, and so forth.
See the &lt;a href=&quot;https://www.sliderulemuseum.com/Manuals/AF_Type_MB-2A_AirNavigationComputer_Instructions.pdf&quot;&gt;MB-2A Air Navigation Computer instructions&lt;/a&gt; for details.
Also see &lt;a href=&quot;https://patents.google.com/patent/US2528518A&quot;&gt;patent 2528518&lt;/a&gt;.
I&#39;ll also point out that from the late 1800s through the 1940s and on, the term &quot;computer&quot; was used for any sort of device that computed a value, from an adding machine to a slide rule (or even a person). The meaning is very different from the modern usage of &quot;computer&quot;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:sliderule&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:refs&quot;&gt;
&lt;p&gt;It was very difficult to find information about the CADC.
The official military specification is MIL-C-25653C(USAF). After searching everywhere, I was finally able to
get a copy from the Technical Reports &amp;amp; Standards unit of the Library of Congress.
The other useful document was in an obscure conference proceedings from 1958:
&quot;Air Data Computer Mechanization&quot; (Hazen), Symposium on the USAF Flight Control Data Integration Program, Wright Air Dev Center US Air Force, Feb 3-4, 1958, pp 171-194.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:refs&quot; title=&quot;Jump back to footnote 11 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/7081929788601606905/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=7081929788601606905' title='6 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/7081929788601606905'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/7081929788601606905'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/02/bendix-central-air-data-computer-cadc.html' title='Reverse-engineering an electromechanical Central Air Data Computer'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://img.youtube.com/vi/D-wHIDnnQwQ/default.jpg" height="72" width="72"/><thr:total>6</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-3839508062709299408</id><published>2023-02-11T09:14:00.001-08:00</published><updated>2023-02-27T18:19:56.635-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="microcode"/><title type='text'>Silicon reverse-engineering: the Intel 8086 processor&#39;s flag circuitry</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
  pre {border: none;}
&lt;/style&gt;

&lt;p&gt;Status flags are a key part of most processors, indicating if an arithmetic result
is negative, zero, or has a carry, for instance.
In this post, I take a close look at the flag circuitry in the Intel 8086 processor (1978), the chip that launched the PC revolution.&lt;span id=&quot;fnref:8088&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:8088&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
Looking at the silicon die of the 8086 reveals how its flags are implemented.
The 8086&#39;s flag circuitry is surprisingly complicated, full of corner cases and special handling.
Moreover, I found an undocumented zero register that is used by the microcode.&lt;/p&gt;
&lt;p&gt;The die photo below shows the 8086 microprocessor under a microscope.
The metal layer on top of the chip is visible, with the silicon and polysilicon mostly hidden underneath.
Around the edges of the die, bond wires connect pads to the chip&#39;s 40 external pins.
I&#39;ve labeled the key functional blocks; the ones that are important to this discussion are darker and will be discussed in detail below.
The Arithmetic/Logic Unit (ALU, lower left) is split in two. The circuitry for the flags is in the middle, giving it access to the ALU&#39;s results
for the low byte and the high byte.
I&#39;ve marked each flag latch in red in the diagram below.
They appear to be randomly scattered, but there are reasons for this layout.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-flags/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;588&quot; src=&quot;https://static.righto.com/images/8086-flags/die-labeled-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Flags and arithmetic operations&lt;/h2&gt;
&lt;p&gt;The 8086 supports three types of arithmetic: unsigned arithmetic, signed arithmetic, and BCD (Binary-Coded Decimal) and this is a key to
understanding the flags.
Unsigned arithmetic uses standard binary values: a byte holds an integer value from 0 to 255, while a 16-bit word holds a value from 0 to 65535.
When adding, a carry indicates that the result is too big to fit in a byte or word.
(I&#39;ll use byte operations to keep the examples small; operations on words are similar.)
For instance, suppose you add hex 0x60 + 0x30. The result, 0x90, fits in a byte so there is no carry.
But adding 0x90 + 0x90 yields 0x120. This result doesn&#39;t fit in a byte, so the result is 0x20 with
the carry flag set to 1.
The carry allows additions to be chained together, like doing long decimal addition on paper.
For subtraction, the carry bit indicates a borrow.&lt;/p&gt;
&lt;!--
If you use an add-with-carry (ADC) instruction
on the next higher byte, any carry will be automatically added in. Thus, the carry bit allows adding arbitrarily long numbers.
--&gt;

&lt;p&gt;The second type of arithmetic is 2&#39;s complement, which supports negative numbers. In a signed byte, 0x00 to 0x7f represent 0 to 127, while
0x80 to 0xff represent -128 to -1.
If the top bit of a signed value is set, the value is negative; this is what the sign flag indicates.
The clever thing about 2&#39;s complement arithmetic is that the same instructions are used for unsigned arithmetic and 2&#39;s complement
arithmetic. The only thing that changes is the interpretation.
As an example of signed arithmetic, 0xff + 0x05 = 0x04 corresponds to -1 + 5 = 4.
Signed arithmetic can result in overflow, though.
For example, suppose you add 112 + 112: 0x70 + 0x70 = 0xe0. Although that is fine in unsigned arithmetic, in signed arithmetic that result
is unexpectedly -32.
The problem is that the result doesn&#39;t fit in a single signed byte. In this case, the overflow flag is set to indicate that the
result overflowed.
In other words, the carry flag indicates that an unsigned result doesn&#39;t fit in a byte or word, while the overflow flag indicates that a signed
result doesn&#39;t fit.&lt;/p&gt;
&lt;p&gt;The third type of arithmetic is BCD (Binary-Coded Decimal), which stores a decimal digit as a 4-bit binary value.
Thus, two digits can be packed into a byte.
For instance, adding 12 + 34 = 46 corresponds to 0x12 + 0x34 = 0x46 with BCD.
After adding or subtracting BCD values, a special instruction is needed to perform any necessary adjustment.&lt;span id=&quot;fnref:bcd&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:bcd&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
This instruction needs to know if there was
a carry from the lower digit to the upper digit, i.e. a carry from bit 4 to bit 3.
Many systems call this a half-carry, since it is the carry out of a half-byte, but Intel calls it the auxiliary carry flag.&lt;/p&gt;
&lt;p&gt;The diagram below summarizes the 8086&#39;s flags.
The overflow, sign, auxiliary carry, and carry flags were discussed above.
The zero flag simply indicates that the result of an operation was zero.
The parity flag counts the number of 1 bits in a result byte and the flag is set if the number of 1 bits is even.
At the left are the three control flags. The trap flag turns on single-stepping mode.
The direction flag controls the direction of string operations.
Finally, the interrupt flag enables interrupts.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-flags/flag-diagram.jpg&quot;&gt;&lt;img alt=&quot;The control and status flags in the 8086. Diagram from iAPX 86/88 Users Manual fig 2.9.&quot; class=&quot;hilite&quot; height=&quot;230&quot; src=&quot;https://static.righto.com/images/8086-flags/flag-diagram-w400.jpg&quot; title=&quot;The control and status flags in the 8086. Diagram from iAPX 86/88 Users Manual fig 2.9.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The control and status flags in the 8086. Diagram from &lt;a href=&quot;http://www.bitsavers.org/components/intel/_dataBooks/1981_iAPX_86_88_Users_Manual.pdf&quot;&gt;iAPX 86/88 Users Manual&lt;/a&gt; fig 2.9.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The status flags are often used with the &lt;code&gt;CMP&lt;/code&gt; (Compare) instruction, which performs a subtraction without storing the result.
Although this may seem pointless, the status flags show the relationship between the values.
For instance, the zero flag will be set if the two values are equal. Other flag combinations indicate &quot;less than&quot;, &quot;greater than&quot;, and other
useful conditions.
Loops and &lt;code&gt;if&lt;/code&gt; statements use conditional jump instructions that test these flags.
(I wrote more about 8086 conditional jumps &lt;a href=&quot;https://www.righto.com/2023/01/reverse-engineering-conditional-jump.html&quot;&gt;here&lt;/a&gt;.)&lt;/p&gt;
&lt;h2&gt;Microcode and flags&lt;/h2&gt;
&lt;p&gt;Most people think of machine instructions as the basic steps that a computer performs.
However, many processors (including the 8086) have another layer of software underneath: microcode.
Instead of building the processor&#39;s control logic out of flip-flops and gates,
microcode replaces much of the control logic with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.
The main advantage of microcode is that it turns the design of control circuitry into a programming task instead of a difficult logic design task.&lt;/p&gt;
&lt;p&gt;An 8086 micro-instruction is encoded into 21 bits as shown below.
Every micro-instruction contains a move from a source register to a destination register, each specified with 5 bits.
The meaning of the remaining bits depends on the type field, which is two or three bits long.
For the current discussion, the most relevant part of the microcode is the Flag bit &lt;code&gt;F&lt;/code&gt; at the end, which indicates that the micro-instruction will update the flags.&lt;span id=&quot;fnref:not&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:not&quot;&gt;3&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-flags/microcode-format.jpg&quot;&gt;&lt;img alt=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; class=&quot;hilite&quot; height=&quot;203&quot; src=&quot;https://static.righto.com/images/8086-flags/microcode-format-w700.jpg&quot; title=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The encoding of a micro-instruction into 21 bits. Based on &lt;a href=&quot;https://digitalcommons.law.scu.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=1031&amp;context=chtlj&quot;&gt;NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
pre.mc {border: none;}
&lt;/style&gt;

&lt;p&gt;As an example, the microcode below implements the &lt;code&gt;INC&lt;/code&gt; (increment) and &lt;code&gt;DEC&lt;/code&gt; (decrement) instructions.
The first micro-instruction moves a word from the register specified by the instruction (indicated by &lt;code&gt;M&lt;/code&gt;) to the ALU&#39;s temporary B register.
It sets up the ALU to perform the operation specified by the instruction (indicated by &lt;code&gt;XI&lt;/code&gt;), and indicates that the next micro-instruction (&lt;code&gt;NX&lt;/code&gt;)
is the last for this machine instruction.
The second micro-instruction moves the ALU result (&lt;code&gt;&lt;/code&gt;) to the specified register (&lt;code&gt;M&lt;/code&gt;), tells the system to run the next instruction &lt;code&gt;RNI&lt;/code&gt;, and
causes the flags (&lt;code&gt;F&lt;/code&gt;) to be updated from the ALU result. Thus, the flags are updated with the results of the increment
or decrement.&lt;/p&gt;
&lt;pre class=&quot;mc&quot;&gt;
   move       action
1 Mtmpb   XI    tmpb, NX
2 M      RNI   F
&lt;/pre&gt;

&lt;p&gt;This microcode is rather generic: it doesn&#39;t explicitly specify the register or the ALU operation.
Instead, the gate logic determines them from the machine instruction.
This illustrates the 8086&#39;s hybrid approach: although the 8086 uses microcode, the microcode is parameterized and much of the instruction functionality is implemented with gate logic.
When the microcode specifies a generic Arithmetic/Logic Unit (ALU) operation, the gate logic determines from the instruction which ALU (Arithmetic/Logic Unit) operation to perform (in this case, increment or decrement).
The gate logic also determines from the instruction bits which register to modify.
Finally, the microcode says to update the flags, but the ALU determines how to update the flags.
This hybrid approach kept
the microcode small enough for 1978 technology; the microcode above supports 16 different increment and decrement instructions.&lt;/p&gt;
&lt;p&gt;Microcode can also read or write the flags as a whole, treating the flags as a register. The
first micro-instruction below stores the flags to memory (via the OPerand Register),
while the second micro-instruction below loads the flags from memory.
The first micro-instruction is part of the microcode for &lt;code&gt;PUSHF&lt;/code&gt; (push flags to the stack) and interrupt handling. 
The second micro-instruction is used for &lt;code&gt;POPF&lt;/code&gt; (pop flags from the stack), the interrupt return code, and the reset code.
Similar micro-instructions are used for &lt;code&gt;LAHF&lt;/code&gt; (Load AH from Flags) and &lt;code&gt;SAHF&lt;/code&gt; (Store AH to Flags).&lt;/p&gt;
&lt;pre class=&quot;mc&quot;&gt;
  FOPR
  OPRF
&lt;/pre&gt;

&lt;p&gt;Microcode can also modify some flags directly with the micro-operations
&lt;code&gt;CCOF&lt;/code&gt; (Clear Carry and Overflow Flags),
&lt;code&gt;SCOF&lt;/code&gt; (Set Carry and Overflow Flags), and
&lt;code&gt;CITF&lt;/code&gt; (Clear Interrupt and Trap Flags).
The first two are used in the microcode for multiplication and division, while the third is used in the interrupt handler.&lt;/p&gt;
&lt;p&gt;Finally, some machine instructions are implemented directly in logic and do not use microcode at all.
The &lt;code&gt;CMC&lt;/code&gt; (Complement Carry),
&lt;code&gt;CLC&lt;/code&gt; (Clear Carry), &lt;code&gt;STC&lt;/code&gt; (Set Carry),
&lt;code&gt;CLI&lt;/code&gt; (Clear Interrupt), &lt;code&gt;STI&lt;/code&gt; (Set Interrupt),
&lt;code&gt;CLD&lt;/code&gt; (Clear Direction), and &lt;code&gt;STD&lt;/code&gt; (Set Direction) instructions modify the flags directly without running any microcode.
(During instruction decoding, the Group Decode ROM indicates that these instructions are implemented with logic, not microcode.)&lt;/p&gt;
&lt;h2&gt;The latch circuit that stores flags&lt;/h2&gt;
&lt;p&gt;Each flag is stored in a latch circuit that holds the flag&#39;s value until it is updated.
A typical flag latch has two inputs for updates: the flag value generated by the ALU, and a value from the bus when storing to all the flags.
The latch also has a &quot;hold&quot; input to keep the existing value.
(Some flags, such as carry, have more inputs, as will be described below.)
A multiplexer (built from pass transistors) selects one of the inputs for the latch.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-flags/latch.jpg&quot;&gt;&lt;img alt=&quot;A typical latch to hold a flag. The latch is constructed from NMOS transistors and inverters. A &amp;quot;1&amp;quot; input turns on a transistor, letting its input pass through it.&quot; class=&quot;hilite&quot; height=&quot;223&quot; src=&quot;https://static.righto.com/images/8086-flags/latch-w450.jpg&quot; title=&quot;A typical latch to hold a flag. The latch is constructed from NMOS transistors and inverters. A &amp;quot;1&amp;quot; input turns on a transistor, letting its input pass through it.&quot; width=&quot;450&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A typical latch to hold a flag. The latch is constructed from NMOS transistors and inverters. A &quot;1&quot; input turns on a transistor, letting its input pass through it.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The latch is based on pass transistors and two inverters forming a loop.
To see how it works, suppose &lt;code&gt;select 1&lt;/code&gt; is high. This turns on the transistor letting the &lt;code&gt;in 1&lt;/code&gt; value flow through the transistor and the
first inverter. When &lt;code&gt;clk&#39;&lt;/code&gt; is high, the signal will flow through the second inverter and the output.
While &lt;code&gt;hold&lt;/code&gt; is high, the output is fed back from the output to the input, causing the latch to &quot;remember&quot; its value.
The latch is controlled by the CPU&#39;s clock and it will only update the output when &lt;code&gt;clk&#39;&lt;/code&gt; is high.
While &lt;code&gt;clk&#39;&lt;/code&gt; is low, the output will remain unchanged; the capacitance of the wire is enough to provide an input to the second inverter, a bit like dynamic RAM.&lt;span id=&quot;fnref:latch&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:latch&quot;&gt;4&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The diagram below shows how one of these latches looks on the die. The pinkish regions are doped silicon, while the brownish lines are polysilicon.
A transistor gate is formed where polysilicon crosses over doped silicon. Each inverter consists of two transistors.
The signal flows through the latch in roughly a counterclockwise circle, starting with one of the inputs on the right.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-flags/latch-die.jpg&quot;&gt;&lt;img alt=&quot;The latch for the Sign Flag. The metal layer was removed for this image.&quot; class=&quot;hilite&quot; height=&quot;411&quot; src=&quot;https://static.righto.com/images/8086-flags/latch-die-w400.jpg&quot; title=&quot;The latch for the Sign Flag. The metal layer was removed for this image.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The latch for the Sign Flag. The metal layer was removed for this image.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Implementation of the flags&lt;/h2&gt;
&lt;p&gt;In this section, I&#39;ll discuss each flag in detail.
But first, I&#39;ll explain the circuitry common to all the flags.
As explained above, microcode can treat the flags as a register, reading or writing all the flags in parallel.
When the microcode specifies flags as the destination for a move, a signal is generated that I call &lt;code&gt;flags-load&lt;/code&gt;.
This signal enables the multiplexer inputs (described above) that connect the ALU bus to the flag latches, loading the bits into the latches.
Conversely, when microcode specifies the flags as the source for a move, a signal is generated that
I call &lt;code&gt;flags-read&lt;/code&gt;.&lt;span id=&quot;fnref:flag-read&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:flag-read&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
This signal connects the outputs of the flag latches to the ALU bus through pass transistors, loading the value of the flags onto the bus.&lt;/p&gt;
&lt;!--
The interrupt, trap, and direction flags are updated separately.
Among the arithmetic operations, there are various special cases. Increment and decrement don&#39;t affect the carry flag.
Multiplication, division, the BCD operations (AAS, DAS, DAA, AAA) have various effects on the flags.
Logical operations typically set sign, zero, and parity based on the operation while clearing overflow and carry and leaving auxiliary carry undefined.
Shift operations set sign, zero, and parity based on the operation, while the carry is the last bit shifted out and overflow indicates the
value changed sign.
Rotates, on the other hand, only affect carry and overflow.
Several instructions affect flags directly: CLC (clear carry), STC (set carry), CMC (complement carry), CLD (clear direction), STD (set direction),
CLI (clear interrupt), STI (set interrupt).
Interrupts clear the interrupt and trap flags.
--&gt;

&lt;h3&gt;Sign flag&lt;/h3&gt;
&lt;p&gt;The sign flag is pretty simple: it stores the top bit of the ALU result, indicating a negative result. For a byte operation, this is bit 7 and for a word operation, bit 15, so some logic selects the right bit based on the instruction.
(This is another example of how logic circuitry looks after the details that microcode ignores.)
The output from the sign flag goes to the condition evaluation circuitry to support conditional jumps, as do the other arithmetic flags. I wrote about that &lt;a href=&quot;https://www.righto.com/2023/01/reverse-engineering-conditional-jump.html&quot;&gt;recently&lt;/a&gt;, so I won&#39;t go into details here.&lt;/p&gt;
&lt;p&gt;The six arithmetic status flags are updated by arithmetic operations when the microcode &lt;code&gt;F&lt;/code&gt; bit is set.
This bit generates a signal that I call &lt;code&gt;arith-flag-load&lt;/code&gt;, indicating that the flags should be updated based on the ALU result.
This signal enables the multiplexer inputs between the ALU circuitry and the flag latches.
There is an inconvenient special case: rotate instructions only update the overflow and carry flags for compatibility with the 8080 processor.&lt;span id=&quot;fnref:rotate&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:rotate&quot;&gt;6&lt;/a&gt;&lt;/span&gt;
To support this, a rotate instruction blocks the &lt;code&gt;arith-flag-load&lt;/code&gt; signal for the sign, parity, zero, and auxiliary carry flags.
Again, this is handled by gates, rather than microcode.&lt;/p&gt;
&lt;h3&gt;Zero flag&lt;/h3&gt;
&lt;p&gt;The zero flag is also straightforward. It indicates that the result byte or word is all zeros, for a byte or word operation respectively.
An 8-input NOR gate at the top of the flags circuitry determines if the lower byte is all zeros, while an 8-input NOR gate at the bottom of
the flags circuitry tests the upper byte. These NOR gates are spread out and span the width of the ALU, essentially a wire that is pulled low by any result bits that are high.
The zero flag is set based on the low byte or the whole word, for a byte instruction or word instruction respectively.&lt;/p&gt;
&lt;p&gt;There is a second zero flag, hidden from the programmer. This zero flag always tests the full 16-bit result, so I&#39;ll call it Z16.
The other key difference is that the Z16 flag is updated on every ALU micro-operation, rather than under the control
of the &lt;code&gt;F&lt;/code&gt; bit.
Thus, the Z16 flag can be updated without interfering with the programmer-visible zero flag.
This makes it useful for internal microcode operations, such as loops.&lt;/p&gt;
&lt;h3&gt;Parity flag&lt;/h3&gt;
&lt;p&gt;The parity flag is conceptually simple, but it is fairly expensive to implement in hardware as it requires exclusive-oring the eight bits of the result byte together.
This is implemented with seven XOR circuits.&lt;span id=&quot;fnref:xor&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:xor&quot;&gt;7&lt;/a&gt;&lt;/span&gt;
Since each XOR circuit is implemented with two logic gates, the raw parity calculation requires 14 gates.
Only 8-bit parity is supported, even if a word operation is performed.&lt;span id=&quot;fnref:parity&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:parity&quot;&gt;8&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The schematic below shows how an XOR circuit is implemented. It uses two gates; due to the properties of NMOS transistors, the AND-NOR gate is
implemented as a single gate.
To see how it works, suppose A and B are 0. The first NOR gate will output 1, forcing the output to 0.
If A and B are both 1, the AND gate will force the output to 0. Otherwise the output is 1, providing the XOR function.
The key point is that XOR is fairly costly compared to other logic functions.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-flags/xor.jpg&quot;&gt;&lt;img alt=&quot;Schematic of an XOR circuit.&quot; class=&quot;hilite&quot; height=&quot;118&quot; src=&quot;https://static.righto.com/images/8086-flags/xor-w350.jpg&quot; title=&quot;Schematic of an XOR circuit.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Schematic of an XOR circuit.&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;Auxiliary carry flag&lt;/h3&gt;
&lt;p&gt;The auxiliary carry starts off simple, but is complicated by the decimal adjust instructions.
In most cases, the auxiliary carry is carry-out from bit 3 of the ALU (i.e. the half-carry).
For subtraction, the flag must be inverted to indicate a borrow, so the half-carry is exclusive-or&#39;d with a subtraction signal.&lt;/p&gt;
&lt;p&gt;However, the decimal adjust instructions (DAA, DAS, AAA, AAS) use the auxiliary carry and also modify the auxiliary carry when performing
a decimal adjust.
After an addition or subtraction, the decimal adjust instructions produce a correction value if necessary. 
If the lower digit is more than 9 or the auxiliary carry is set, the value 6 is added (or subtracted) from the accumulator.&lt;span id=&quot;fnref:daa-9&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:daa-9&quot;&gt;9&lt;/a&gt;&lt;/span&gt;
The &lt;code&gt;DAA&lt;/code&gt; and &lt;code&gt;AAA&lt;/code&gt; instructions also test if a correction of 0x60 is needed for the upper digit.
The correction signals are wired to the ALU bus to generate the correction factor of 0x06, 0x60, or 0x66 for an adjustment ALU operation.
The correction signal for the low digit is stored as the auxiliary carry flag.&lt;/p&gt;
&lt;h3&gt;Carry flag&lt;/h3&gt;
&lt;p&gt;The carry flag is surprisingly complex, with five inputs to the carry flag input multiplexer.
The first input is the carry value for an ALU operation:&lt;span id=&quot;fnref:inc&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:inc&quot;&gt;10&lt;/a&gt;&lt;/span&gt; the top bit of the ALU result (bit 7 or 15 for a byte or word operation).
However, for a subtraction the carry is inverted to form the borrow.
But for a &lt;code&gt;DAA&lt;/code&gt; or &lt;code&gt;DAS&lt;/code&gt; decimal adjust operation, the carry comes from the high-digit correction signal.
And for an &lt;code&gt;AAA&lt;/code&gt; or &lt;code&gt;AAS&lt;/code&gt; ASCII adjust operation, the carry comes from the low-digit correction signal.
These cases are determined with logic gates and fed into a single multiplexer input.&lt;/p&gt;
&lt;p&gt;Another multiplexer input supports the &lt;code&gt;CMC&lt;/code&gt; (Complement Carry) instruction by feeding in the current flag value but inverted.
The &lt;code&gt;STC&lt;/code&gt; and &lt;code&gt;CLC&lt;/code&gt; (Set Carry and Clear Carry) instructions are implemented by feeding the low bit of the instruction into a different multiplexer input.
This input also supports the micro-instructions &lt;code&gt;SCOF&lt;/code&gt; (Set Carry, Overflow Flags), &lt;code&gt;CCOF&lt;/code&gt; (Clear Carry, Overflow Flags), and &lt;code&gt;RCY&lt;/code&gt; (Reset Carry).&lt;/p&gt;
&lt;!-- See INC in Intel 64 and IA-32 Architectures Software Developers Manual vol 2, 3-506 --&gt;

&lt;p&gt;The rotate and shift instructions have complex interactions with the carry flag, since bits are shifted in and out of the carry flag.
For a shift or rotate, a separate multiplexer input provides the bit for the carry flag latch.
For a right shift or rotate, the lowest bit of the ALU argument is fed into the carry flag.
For a left shift or rotate, the carry out of bit 15 or bit 7 is fed into the carry flag; this was the highest bit for a word or byte operation respectively.&lt;/p&gt;
&lt;p&gt;The output from the carry flag is fed into the ALU&#39;s carry-in for the &lt;code&gt;ADC&lt;/code&gt; (Add with Carry), &lt;code&gt;SBB&lt;/code&gt; (Subtract with Borrow), and &lt;code&gt;RCL&lt;/code&gt; (Rotate through Carry, Left) instructions; the carry is inverted for &lt;code&gt;SBB&lt;/code&gt; to form the borrow.
For an &lt;code&gt;RCR&lt;/code&gt; (Rotate through Carry, Right), the carry is fed into the ALU&#39;s output bit 7 or 15 (for a byte or word operation respectively).&lt;/p&gt;
&lt;h3&gt;Overflow flag&lt;/h3&gt;
&lt;p&gt;The circuitry for the overflow flag is fairly complicated, as there are multiple cases.
For an arithmetic operation, the overflow flag indicates a signed overflow.
The overflow is computed as the exclusive-or of the carry-in to the top bit and the carry-out from the top bit, selected for a byte or word operation.
(I explained the mathematics behind this &lt;a href=&quot;https://www.righto.com/2012/12/the-6502-overflow-flag-explained.html&quot;&gt;earlier&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;For a shift or rotate, however, the overflow flag indicates that the shifted value changed sign.
The ALU implements left shifts and rotates by passing bits as carries so the old sign bit is the carry-out from the top bit, while the new sign bit is the carry-in to the top bit. Thus, the standard arithmetic overflow circuit also handles left shifts and rotates.
On the other hand, for a shift or rotate right, the top two bits of the result are exclusive-or&#39;d together to see if they are different: bits 6 and 7 for a byte shift and bits 14 and 15 for a word shift.
(The second-from-the-top bit was the sign bit before the shift.)&lt;/p&gt;
&lt;p&gt;Finally, two micro-instructions affect the flag: &lt;code&gt;CCOF&lt;/code&gt; (Clear Carry and Overflow Flags) and &lt;code&gt;SCOF&lt;/code&gt; (Set Carry and Overflow Flags). 
All these different sources for the overflow flag are combined in logic gates, rather than a complex multiplexer like the carry flag used.&lt;/p&gt;
&lt;h3&gt;Direction flag&lt;/h3&gt;
&lt;p&gt;The three remaining flags are &quot;control&quot; flags: rather than storing the status of an ALU operation, these flags control the CPU&#39;s behavior.
The direction flag controls the direction of string operations that scan through memory: auto-incrementing or auto-decrementing.
This is implemented by feeding the direction flag into the Constant ROM to determine the increment value applied to the SI and DI registers.
The direction flag is set or cleared through the &lt;code&gt;STD&lt;/code&gt; and &lt;code&gt;CLD&lt;/code&gt; instructions (Set Direction and Clear Direction).
For these instructions, the low bit of the instruction is passed into the flag to set or clear it as appropriate.&lt;/p&gt;
&lt;h3&gt;Interrupt flag&lt;/h3&gt;
&lt;p&gt;The output from the interrupt flag goes to the interrupt handling circuitry to enable or disable interrupts.
This flag is set or cleared by a programmer through the &lt;code&gt;STI&lt;/code&gt; and &lt;code&gt;CLI&lt;/code&gt; instructions.
For the &lt;code&gt;STI&lt;/code&gt; and &lt;code&gt;CLI&lt;/code&gt; instructions, the low bit of the instruction is passed into the flag to set or clear it as appropriate.
Microcode can clear the interrupt flag and the trap flag (discussed below) with the &lt;code&gt;CITF&lt;/code&gt; (Clear Interrupt and Trap Flag) micro-instruction.
This is used in the interrupt handler to disable subsequent interrupts and traps.
The &lt;code&gt;CITF&lt;/code&gt; micro-instruction is implemented with a separate input to the flag latch.&lt;/p&gt;
&lt;h3&gt;Trap flag&lt;/h3&gt;
&lt;p&gt;The trap flag turns on single-stepping for debugging. With the trap flag on, every instruction generates an interrupt.
This flag doesn&#39;t have machine instructions to modify it directly.
Instead, the programmer must mess around with the &lt;code&gt;PUSHF&lt;/code&gt; and &lt;code&gt;POPF&lt;/code&gt; instructions to put all the flags on the stack and modify the flag bit there
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Trap_flag#Setting&quot;&gt;details&lt;/a&gt;).
Like the interrupt flag, the trap flag has an input to clear it if the &lt;code&gt;CITF&lt;/code&gt; micro-instruction is active.&lt;/p&gt;
&lt;h2&gt;Layout of the flag circuitry&lt;/h2&gt;
&lt;p&gt;The diagram below shows the circuitry for the flags on the die, with the approximate location of each flag indicated.
ALU bits 7 through 0 are above this circuitry and ALU bits 15 through 8 are below.
The zero gates stretch the length of the ALU at the top and bottom, while the parity gates are near the low byte of the ALU.
The flag circuitry appears highly irregular on the die because each flag has different circuitry.
However, the circuitry for a flag is generally near the appropriate bit that receives the flag, so the layout is not as arbitrary as it may seem.
For instance, the sign flag is affected by bit 7 or 15 of the ALU result and is loaded or stored to bit 7, so it is at the left.
The trap and interrupt flags are outside the ALU, to the right of this image.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-flags/flags-die.jpg&quot;&gt;&lt;img alt=&quot;Closeup of the circuitry on the die that implements the flags. The metal layer has been removed to show the polysilicon and silicon underneath.&quot; class=&quot;hilite&quot; height=&quot;429&quot; src=&quot;https://static.righto.com/images/8086-flags/flags-die-w700.jpg&quot; title=&quot;Closeup of the circuitry on the die that implements the flags. The metal layer has been removed to show the polysilicon and silicon underneath.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Closeup of the circuitry on the die that implements the flags. The metal layer has been removed to show the polysilicon and silicon underneath.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The history behind the 8086 flags&lt;span id=&quot;fnref:blaauw&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:blaauw&quot;&gt;11&lt;/a&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&quot;https://bitsavers.org/pdf/datapoint/2200/2200_Programmers_Man_Aug71.pdf&quot;&gt;Datapoint 2200&lt;/a&gt; (1970) is a desktop computer that was sold as a &quot;programmable terminal&quot;.
Although mostly forgotten now, the Datapoint 2200 is one of the most influential computers ever, as it led to the 8086 processor and thus the modern x86 architecture.
For flags, the Datapoint 2200 had four &quot;control flip-flops&quot;: carry/borrow,&lt;span id=&quot;fnref:borrow&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:borrow&quot;&gt;12&lt;/a&gt;&lt;/span&gt; zero, sign, and parity.
These were not bits in a register and could not be accessed directly. Instead, conditional jumps, subroutine calls, or subroutine returns could
be performed based on the status of one of these flip-flops.
Because the Datapoint 2200 was used as a terminal, and terminal protocols often used parity, implementing parity in hardware was a useful feature.&lt;/p&gt;
&lt;p&gt;But how did the Datapoint 2200 lead to the 8086?
The Datapoint 2200 was created before the microprocessor, so its processor was a large board of TTL chips.
Datapoint asked Intel and Texas Instruments if they could replace this TTL processor with a single chip.
Texas Instruments created the TMX 1795, the first 8-bit microprocessor.
Intel created the 8008 shortly after. Both chips copied the instruction set and architecture of the 2200.
Datapoint didn&#39;t like either chip and stuck with TTL. Texas Instruments couldn&#39;t find a customer for the TMX 1795 and abandoned it. Intel, on the other hand, marketed the 8008 as a general-purpose microprocessor, essentially creating the microprocessor industry.
Since the 8008 copied the Datapoint 2200, it kept the four status flip-flops.&lt;/p&gt;
&lt;p&gt;In 1974, Intel created the 8080 microprocessor, an improvement of the 8008.
The 8080 kept the flags from the 8008 and added the auxiliary carry.
Moreover, the flags could be accessed as a byte, making the flags appear like a register.
The 8080 defined specific values for the unused flag bits.
These decisions have persisted into the modern x86 architecture.&lt;span id=&quot;fnref:8080&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:8080&quot;&gt;13&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;!--
(The `PUSH PSW` and `POP PSW` instructions saved and restored Processor Status Word (i.e. the A register and flags) on the stack.)
--&gt;

&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-flags/8080-flags.jpg&quot;&gt;&lt;img alt=&quot;Structure of the 8080 flags when saved on the stack. From 8080 Assembly Language Programming Manual.&quot; class=&quot;hilite&quot; height=&quot;204&quot; src=&quot;https://static.righto.com/images/8086-flags/8080-flags-w400.jpg&quot; title=&quot;Structure of the 8080 flags when saved on the stack. From 8080 Assembly Language Programming Manual.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Structure of the 8080 flags when saved on the stack. From &lt;a href=&quot;http://www.nj7p.org/Manuals/PDFs/Intel/9800004C.pdf&quot;&gt;8080 Assembly Language Programming Manual&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The 8086 was designed to be backward compatible with the 8080, at least at the assembly language level.&lt;span id=&quot;fnref:8080-compat&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:8080-compat&quot;&gt;14&lt;/a&gt;&lt;/span&gt;
To support this, the 8086 kept the 8080&#39;s flag byte unchanged, putting additional flags in the high byte, as shown below.
Thus, the selection, layout, and behavior of the 8086 flags (and thus x86) are largely historical accidents going back to
the 8080, 8008, and Datapoint 2200 processors.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-flags/flag-word.jpg&quot;&gt;&lt;img alt=&quot;Arrangement of the 8086 flags in the word. The shaded flags match the 8080/8085 flags. Diagram from iAPX 86/88 Users Manual fig 2.10.&quot; class=&quot;hilite&quot; height=&quot;49&quot; src=&quot;https://static.righto.com/images/8086-flags/flag-word-w400.jpg&quot; title=&quot;Arrangement of the 8086 flags in the word. The shaded flags match the 8080/8085 flags. Diagram from iAPX 86/88 Users Manual fig 2.10.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Arrangement of the 8086 flags in the word. The shaded flags match the 8080/8085 flags. Diagram from &lt;a href=&quot;http://www.bitsavers.org/components/intel/_dataBooks/1981_iAPX_86_88_Users_Manual.pdf&quot;&gt;iAPX 86/88 Users Manual&lt;/a&gt; fig 2.10.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;You might expect flags to be a simple part of a CPU, but the 8086&#39;s flags are surprisingly complex.
About 1/3 of the ALU is devoted to flag computation and storage.
Each flag is implemented with completely different circuitry.
The 8086 is a CISC processor (Complex Instruction Set Computer), where the instruction set is designed to be powerful and to minimize the
gap between machine language and high-level languages.&lt;span id=&quot;fnref:cisc&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:cisc&quot;&gt;15&lt;/a&gt;&lt;/span&gt;
This can be seen in the implementation of the flags, which are full of special cases to increase their utility with different instructions.&lt;span id=&quot;fnref:morse&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:morse&quot;&gt;16&lt;/a&gt;&lt;/span&gt;
In contrast, a RISC (Reduced Instruction Set Computer) simplifies the instruction set to make each instruction faster.
This philosophy also affects the flags: for example, the &lt;a href=&quot;http://www.bitsavers.org/pdf/acorn/ARM_DDI_0004D_ARM610_Data_Sheet_Aug93.pdf&quot;&gt;ARM-1&lt;/a&gt; processor (1985) has four arithmetic flags compared to the 8086&#39;s six flags.
The behavior of the ARM flags is simpler, and the ARM doesn&#39;t deal with byte versus word operations.
It also doesn&#39;t have instructions like decimal adjust that have complex flag behavior.
This simplicity is reflected in the simpler and more regular circuitry of the ARM-1 flags, which I reverse-engineered &lt;a href=&quot;https://www.righto.com/2016/02/the-arm1-processors-flags-reverse.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I&#39;ve written multiple &lt;a href=&quot;https://www.righto.com/search/label/8086&quot;&gt;posts on the 8086&lt;/a&gt; so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:8088&quot;&gt;
&lt;p&gt;Strictly speaking, the Intel 8088 launched the PC revolution as it was the processor in the first IBM PC. But internally the 
8086 and 8088 are almost identical, so everything in this post applies to the 8088 as well.
(The 8088 has an 8-bit bus compared to the 8086&#39;s 16-bit bus. As a result, the bus interface circuitry is different.
The 8088 has a 4-byte prefetch queue compared to the 8086&#39;s 6-byte prefetch queue. And there are a few microcode changes.
Apart from these changes, the dies are essentially identical.)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:8088&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:bcd&quot;&gt;
&lt;p&gt;Since BCD arithmetic is performed using the binary addition and subtraction instructions, an adjustment may be required.
For instance, consider adding 19 + 18 = 37 using BCD: 0x19 + 0x18 = 0x31 rather than the desired 0x37.
Adding an adjustment factor of 6 yields the desired answer, taking into account the carry from the low digit.
The BCD adjustment instructions are
&lt;code&gt;DAA&lt;/code&gt; (Decimal Adjust after Addition),
&lt;code&gt;DAS&lt;/code&gt; (Decimal Adjust after Subtraction),
&lt;code&gt;AAA&lt;/code&gt; (ASCII Adjust after Addition),
and &lt;code&gt;AAS&lt;/code&gt; (ASCII Adjust after Subtraction).
(I wrote about the DAA instruction in detail &lt;a href=&quot;https://www.righto.com/2023/01/understanding-x86s-decimal-adjust-after.html&quot;&gt;here&lt;/a&gt;.)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:bcd&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:not&quot;&gt;
&lt;p&gt;Unlike other arithmetic and logic instructions, the &lt;code&gt;NOT&lt;/code&gt; instruction does not change any of the flags. The designer of the 8086 states that this was an oversight.
(See page 98 in &quot;The 8086/8088 Primer&quot;.)
Looking at the microcode shows that the microcode &lt;code&gt;F&lt;/code&gt; bit was omitted in the implementation of &lt;code&gt;NOT&lt;/code&gt;.
I think that this &quot;goof&quot; also prevented the &lt;code&gt;NOT&lt;/code&gt; and &lt;code&gt;NEG&lt;/code&gt; microcode from being merged, wasting four micro-instructions.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:not&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:latch&quot;&gt;
&lt;p&gt;Most of the latches in the 8086 have two pass transistors: one driven by &lt;code&gt;clk&lt;/code&gt; and one driven by &lt;code&gt;clk&#39;&lt;/code&gt;. This makes the circuit function
like an edge-triggered flip-flop, only transitioning on the edge of the clock.
The flag latches, on the other hand, gate the multiplexer input controls so they are only active when &lt;code&gt;clk&lt;/code&gt; is high.
Thus, the two inverters are connected alternately during &lt;code&gt;clk&lt;/code&gt; and &lt;code&gt;clk&#39;&lt;/code&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:latch&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:flag-read&quot;&gt;
&lt;p&gt;The connection from flag outputs to the ALU bus is more complex than simple pass transistors.
For performance reasons, the ALU bus is charged high during the clock&#39; phase of the clock. Then, any bits that should be 0 are pulled low during
the high clock phase.
(The motivation is that NMOS transistors can pull a line low faster than they can pull it high.)
To support this, each inverted flag output drives a transistor connected to ground, and the output from this transistor is connected to the
ALU bus through a pass transistor.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:flag-read&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:rotate&quot;&gt;
&lt;p&gt;The 8080 processor has four rotate instructions, while the 8086 adds three shift instructions.
The new shift instructions update the arithmetic flags according to the result.
However, the 8080&#39;s rotate instructions only updated the carry flag, leaving the other flags unchanged.
For backward compatibility, the 8086 preserves this behavior for the rotate instructions, not modifying the other flags inherited from the 8080.
Since the 8086&#39;s overflow flag didn&#39;t exist in the 8080, the 8086 can update the overflow flag for rotate instructions without breaking
compatibility, even though it&#39;s not obvious what &quot;overflow&quot; means in the case of a rotate.
(The 8080&#39;s behavior of only updating the carry flag for shifts dates back to the Datapoint 2200.)&lt;/p&gt;
&lt;p&gt;Curiously, &lt;a href=&quot;https://bitsavers.org/components/intel/8086/9800722-03_The_8086_Family_Users_Manual_Oct79.pdf&quot;&gt;The 8086 Family User&#39;s Manual&lt;/a&gt;
shows SHR and SAL/SHL as updating just the overflow and carry flags (pages 2-265 and 2-66), contradicting the text (page 2-39).&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:rotate&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:xor&quot;&gt;
&lt;p&gt;The 8086 implements the parity computation by XORing pairs of bits. The pairs are then combined in sequence:
   &lt;code&gt;(((bit0bit1)(bit2bit3))(bit4bit5))(bit6bit7)&lt;/code&gt;.
Combining the terms in a tree-like arrangement would have saved gate delays, but apparently wasn&#39;t necessary.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:xor&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:parity&quot;&gt;
&lt;p&gt;The parity flag only examines the low byte of the result, even for a 16-bit operation, making it unusual compared to the other flags.
The motivation is probably that the parity flag was only supported for backward compatibility and not considered particularly useful.
Even in modern 64-bit Intel processors, the parity flag only examines the least-significant byte.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:parity&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:daa-9&quot;&gt;
&lt;p&gt;The decimal adjust circuitry uses a gate circuit to test if the lower digit is greater than nine.
Specifically, it uses the expression: &lt;code&gt;bit3(bit2+bit1)&lt;/code&gt;. In other words, if the ALU input has 8 and either 4 or 2 or both.&lt;/p&gt;
&lt;p&gt;The logic to determine if the upper digit needs a correction is more complex:
&lt;code&gt;carry+bit7(bit6+bit5+bit4af9)&lt;/code&gt;, where &lt;code&gt;af9&lt;/code&gt; indicates that AF is not set and the lower digit is more than 9.
This tests if the upper digit is greater than nine, but also handles the case where the upper digit is 9 and adjusting the lower
digit will increase it.&lt;/p&gt;
&lt;p&gt;The DAA instruction on the 8086 has slightly different behavior from the DAA instruction on x86 in a few cases.
For example, 0x9a + 0x02 = 0x9c; DAA converts this to 0xa2 on the 8086, but 0x02 on x86.
Since 0x9a is not a valid BCD value, this is technically an undefined case, but it is interesting that there is a difference.
Perhaps this behavior was inherited from the 8080; if anyone has an 8080 available, perhaps they can test this case.
(I wrote about the x86 DAA behavior in detail &lt;a href=&quot;https://www.righto.com/2023/01/understanding-x86s-decimal-adjust-after.html&quot;&gt;here&lt;/a&gt;.)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:daa-9&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:inc&quot;&gt;
&lt;p&gt;One special case is that the
increment and decrement instructions affect all the arithmetic flags except for carry.
This is implemented by blocking the carry-flag update for an increment or decrement instruction.
The motivation is to allow a loop counter to be updated without disturbing the carry flag.
This behavior was first implemented in the 8008 processor.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:inc&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:blaauw&quot;&gt;
&lt;p&gt;The book &quot;Computer Architecture&quot;, Blaauw and Brooks, contains a detailed discussion of different approaches for condition flags, pages 353-358.
Some processors, such as the IBM 704 (1954), don&#39;t explicitly store flags, but test and branch in a single instruction.
Storing conditions as 1-bit values (as in the 8086) is called an &quot;indicator&quot;.
An alternative is the &quot;condition code&quot;, which encodes mutually-exclusive condition values into a smaller number of bits, as in System/360 (1964).
For example, addition stores four conditions (zero, negative, positive, or overflow) encoded into two bits, rather than separate zero, sign,
and overflow flags.
Other alternatives are where to store the conditions: in &quot;working store&quot; (i.e. a regular register), in memory, in a unique indicator (i.e. a
flags register), or in a shared condition register (e.g. System/360).
The point is that while the typical microprocessor approach of storing flags in a flag register may seem natural, many alternatives have been tried in different systems.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:blaauw&quot; title=&quot;Jump back to footnote 11 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:borrow&quot;&gt;
&lt;p&gt;For subtraction, a borrow flag can be defined in different ways.
The Datapoint 2200 and descendants store the borrow bit in the carry flag.
This approach was also used by the 6800 and 68000 processors.
The alternative is to store
the &lt;em&gt;complement&lt;/em&gt; of the borrow bit in the carry flag, since this maps more naturally onto twos-complement arithmetic.
This approach was used by the IBM System/360 mainframe and the 6502 and ARM processors.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:borrow&quot; title=&quot;Jump back to footnote 12 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:8080&quot;&gt;
&lt;p&gt;The positions of the 8080&#39;s flags in the byte are not arbitrary but have some logic.
When performing multi-byte additions, the carry flag gets added into the low bit of the next byte, so it makes sense to put the carry
flag in bit 0.
Likewise, the auxiliary carry flag is in bit 4, since that is the bit it is added into.
The sign bit is bit 7 of the result, so it makes sense to put the sign bit in bit 7 of the flags.
As for the zero and parity flags, and the values of the unused flag bits, I don&#39;t have an explanation for those.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:8080&quot; title=&quot;Jump back to footnote 13 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:8080-compat&quot;&gt;
&lt;p&gt;The 8086 was designed to provide an upgrade path from the 8080, so it inherited many instructions and architectural features along with the change from 8 bits to 16 bits.
The two processors were not binary compatible or even directly compatible at the assembly code level.
Instead, assembly code for the 8080 could be converted to 8086 assembly via a program called &lt;a href=&quot;https://archive.org/details/bitsavers_intel80869lyUsersManualOct79_62967963/page/n113/mode/2up&quot;&gt;CONV-86&lt;/a&gt;, which would usually require manual cleanup afterward.
Many of the early programs for the 8086 were conversions of 8080 programs.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:8080-compat&quot; title=&quot;Jump back to footnote 14 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:cisc&quot;&gt;
&lt;p&gt;The terms RISC and CISC are vague, and there are many different definitions. I&#39;m not looking to debate definitions.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:cisc&quot; title=&quot;Jump back to footnote 15 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:morse&quot;&gt;
&lt;p&gt;The motivation behind how 8086 instructions affect the flags is given in &lt;a href=&quot;https://amzn.to/3DCUTPN&quot;&gt;The 8086/8088 Primer&lt;/a&gt;, by Stephen Morse, the creator
of the 8086 instruction set. It turns out that there are good reasons for the flags to have special-case behavior for various instructions.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:morse&quot; title=&quot;Jump back to footnote 16 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/3839508062709299408/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=3839508062709299408' title='6 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/3839508062709299408'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/3839508062709299408'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/02/silicon-reverse-engineering-intel-8086.html' title='Silicon reverse-engineering: the Intel 8086 processor&#39;s flag circuitry'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>6</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-1529067761550380331</id><published>2023-01-30T10:24:00.000-08:00</published><updated>2023-02-27T18:20:06.189-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="microcode"/><title type='text'>Understanding the x86&#39;s Decimal Adjust after Addition (DAA) instruction</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;

&lt;p&gt;I&#39;ve been looking at the DAA machine instruction on x86 processors, a special instruction for binary-coded decimal arithmetic.
Intel&#39;s manuals document each instruction in detail, but the DAA description doesn&#39;t make much sense.
I ran an extensive assembly-language test of DAA on a real machine to determine exactly how the instruction behaves.
In this blog post, I explain how the instruction works, in case anyone wants a better understanding.&lt;/p&gt;
&lt;h2&gt;The &lt;code&gt;DAA&lt;/code&gt; instruction&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;DAA&lt;/code&gt; (Decimal Adjust &lt;code&gt;AL&lt;/code&gt;&lt;span id=&quot;fnref:al&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:al&quot;&gt;1&lt;/a&gt;&lt;/span&gt; after Addition) instruction is designed for use with packed BCD (Binary-Coded Decimal) numbers.
The idea behind BCD is to store decimal numbers in groups of four bits, with each group encoding a digit 0-9 in
binary.
You can fit two decimal digits in a byte; this format is called packed BCD.
For instance, the decimal number 23 would be stored as hex 0x23
(which turns out to be decimal 35).&lt;/p&gt;
&lt;p&gt;The 8086 doesn&#39;t implement BCD addition directly. Instead, you use regular binary addition and then
&lt;code&gt;DAA&lt;/code&gt; fixes the result.
For instance, suppose you&#39;re adding decimal 23 and 45. In BCD these are 0x23 and 0x45 with the binary sum 0x68, so everything seems straightforward.
But, there&#39;s a problem with carries. For instance, suppose you add decimal 26 and 45 in BCD.
Now, 0x26 + 0x45 = 0x6b, which doesn&#39;t match the desired answer of 0x71.
The problem is that a 4-bit value has a carry at 16, while a decimal digit has a carry at 10. The solution is to add
a correction factor of the difference, 6, to get the correct BCD result: 0x6b + 6 = 0x71.&lt;/p&gt;
&lt;p&gt;Thus, if a sum has a digit greater than 9, it needs to be corrected by adding 6. However, there&#39;s another problem.
Consider adding decimal 28 and decimal 49 in BCD: 0x28 + 0x49 = 0x71.
Although this looks like a valid BCD result, it is 6 short of the correct answer, 77, and needs a correction factor.
The problem is the carry out of the low digit caused the value to wrap around.
The solution is for the processor to track the carry out of the low digit, and add a correction if a carry happens.
This flag is usually called a half-carry, although Intel calls it the Auxiliary Carry Flag.&lt;span id=&quot;fnref:ascii&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:ascii&quot;&gt;2&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;For a packed BCD value, a similar correction must be done for the upper digit.
This is accomplished by the &lt;code&gt;DAA&lt;/code&gt; (Decimal Adjust AL after Addition) instruction.
Thus, to add a packed BCD value, you perform an &lt;code&gt;ADD&lt;/code&gt; instruction followed by a &lt;code&gt;DAA&lt;/code&gt; instruction.&lt;/p&gt;
&lt;h2&gt;Intel&#39;s explanation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-daa/manuals.jpg&quot;&gt;&lt;img alt=&quot;The Intel Software Developer&#39;s Manuals. These are from 2004, back when Intel would send out manuals on request.&quot; class=&quot;hilite&quot; height=&quot;419&quot; src=&quot;https://static.righto.com/images/8086-daa/manuals-w500.jpg&quot; title=&quot;The Intel Software Developer&#39;s Manuals. These are from 2004, back when Intel would send out manuals on request.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Intel Software Developer&#39;s Manuals. These are from 2004, back when Intel would send out manuals on request.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html&quot;&gt;Intel 64 and IA-32 Architectures Software Developer Manuals&lt;/a&gt; provide detailed pseudocode specifying exactly what each machine instruction does.
However, in the case of &lt;code&gt;DAA&lt;/code&gt;, the pseudocode is confusing and the description is ambiguous.
To verify the operation of the &lt;code&gt;DAA&lt;/code&gt; instruction on actual hardware, I wrote a short
assembly program to perform &lt;code&gt;DAA&lt;/code&gt; on all input values (0-255) and all four combinations of the carry and auxiliary flags.&lt;span id=&quot;fnref:test&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:test&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
I tested the pseudocode against this test output.
I determined that Intel&#39;s description is technically correct, but can be significantly simplified.&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
.daa span {color: green; font-style:italic;}
&lt;/style&gt;

&lt;p&gt;The manual gives the following pseudocode; my comments are in green.&lt;/p&gt;
&lt;pre class=&quot;daa&quot;&gt;
IF 64-Bit Mode
  THEN
    #UD;  &lt;span&gt;Undefined opcode in 64-bit mode&lt;/span&gt;
  ELSE
    old_AL := AL; &lt;span&gt;AL holds input value&lt;/span&gt;
    old_CF := CF; &lt;span&gt;CF is the carry flag&lt;/span&gt;
    CF := 0;
    IF (((AL AND 0FH) &gt; 9) or AF = 1) &lt;span&gt;AF is the auxiliary flag&lt;/span&gt;
      THEN
        AL := AL + 6;
        CF := old_CF or (Carry from AL := AL + 6); &lt;span&gt;dead code&lt;/span&gt;
        AF := 1;
      ELSE
        AF := 0;
      FI;
    IF ((old_AL &gt; 99H) or (old_CF = 1))
      THEN
        AL := AL + 60H;
        CF := 1;
      ELSE
        CF := 0;
    FI;
FI;
&lt;/pre&gt;

&lt;p&gt;Removing the unnecessary code yields the version below, which makes it much clearer what is going on.
The low digit is corrected if it exceeds 9 or if the auxiliary flag is set on entry.
The high digit is corrected if it exceeds 9 or if the carry flag is set on entry.&lt;span id=&quot;fnref:99&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:99&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
At completion, the auxiliary and carry flags are set if an adjustment happened to the corresponding digit.&lt;span id=&quot;fnref:carry&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:carry&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
(Because these flags force a correction, the operation never clears them if they were set at entry.)&lt;/p&gt;
&lt;pre class=&quot;daa&quot;&gt;
IF 64-Bit Mode
  THEN
    #UD;
  ELSE
    old_AL := AL;
    IF (((AL AND 0FH) &gt; 9) or AF = 1)
      THEN
        AL := AL + 6;
        AF := 1;
      FI;
    IF ((old_AL &gt; 99H) or CF = 1)
      THEN
        AL := AL + 60H;
        CF := 1;
    FI;
FI;
&lt;/pre&gt;

&lt;h2&gt;History of BCD&lt;/h2&gt;
&lt;p&gt;The use of binary-coded decimal may seem strange from the modern perspective, but it makes more sense looking at
some history.
In 1928, IBM introduced the 80-column punch card, which became very popular for business data processing.
These cards store one decimal digit per column, with each digit indicated by a single hole in row 0 through 9.&lt;span id=&quot;fnref:cards&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:cards&quot;&gt;6&lt;/a&gt;&lt;/span&gt;
Even before digital computers, businesses could perform fairly complex operations on punch-card data using electromechanical equipment such
as sorters and collators. Tabulators, programmed by wiring panels, performed arithmetic on punch cards using
electromechanical counting wheels and printed business reports.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-daa/example-card.jpg&quot;&gt;&lt;img alt=&quot;Example card, from IBM 29 Card Punch Reference Manual.&quot; class=&quot;hilite&quot; height=&quot;272&quot; src=&quot;https://static.righto.com/images/8086-daa/example-card-w600.jpg&quot; title=&quot;Example card, from IBM 29 Card Punch Reference Manual.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Example card, from &lt;a href=&quot;http://bitsavers.org/pdf/ibm/punchedCard/Keypunch/029/A24-3332-3_29_Reference_Man.pdf&quot;&gt;IBM 29 Card Punch Reference Manual&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;These calculations were performed in decimal.
Decimal fields were read off punch cards, added with decimal counting wheels,
and printed as decimal digits. 
Numbers were not represented in binary, or even binary-coded decimal. Instead, digits were represented by the
position of the hole in the card, which controlled the timing of pulses inside the machinery. These pulses
rotated counting wheels, which stored their totals as angular rotations, a bit like an odometer.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-daa/counter-wheel.jpg&quot;&gt;&lt;img alt=&quot;A counter unit from an IBM accounting machine (tabulator). The two wheels held two digits. The electromagnets (white) engaged and disengaged the clutch so the wheel would advance the desired number of positions.&quot; class=&quot;hilite&quot; height=&quot;426&quot; src=&quot;https://static.righto.com/images/8086-daa/counter-wheel-w600.jpg&quot; title=&quot;A counter unit from an IBM accounting machine (tabulator). The two wheels held two digits. The electromagnets (white) engaged and disengaged the clutch so the wheel would advance the desired number of positions.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A counter unit from an IBM accounting machine (tabulator). The two wheels held two digits. The electromagnets (white) engaged and disengaged the clutch so the wheel would advance the desired number of positions.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;With the rise of electronic digital computers in the 1950s, you might expect binary to take over.
Scientific computers used binary for their calculations, such as the IBM 701 (1952).
However, business computers such as the IBM 702 (1955) and the IBM 1401 (1959) operated on decimal digits, typically
stored as binary-coded decimal in 6-bit characters.
Unlike the scientific computers, these business computers performed arithmetic operation in decimal.&lt;/p&gt;
&lt;p&gt;The main advantage of decimal arithmetic was compatibility with decimal fields stored in punch cards.
Second, decimal arithmetic avoided time-consuming conversions between binary and decimal, a benefit for applications
that were primarily input and output rather than computation.
Finally, decimal arithmetic avoided the rounding and truncation problems that can happen if you use floating-point numbers for accounting calculations.&lt;/p&gt;
&lt;p&gt;The importance of decimal arithmetic to business can be seen in its influence on the COBOL programming language,
very popular for business applications.
A data field was specified with the PICTURE clause, which specified exactly how many decimal digits each
field contained.
For instance &lt;code&gt;PICTURE S999V99&lt;/code&gt; specified a five-digit number (five 9&#39;s) with a sign (S) and implied decimal point (V).
(Binary fields were an optional feature.)&lt;/p&gt;
&lt;p&gt;In 1964, IBM introduced the
System/360 line of computers,  designed for both scientific and business use, the whole
360&amp;deg; of applications.
The System/360 architecture was based on 32-bit binary words.
But to support business applications, it also provided decimal data structures.
Packed decimal provided variable-length decimal fields by putting two binary-coded decimal digits per byte.
A special set of arithmetic instructions supported addition, subtraction, multiplication, and division of decimal values.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-daa/model-50-ibm.jpg&quot;&gt;&lt;img alt=&quot;The System/360 Model 50 in a datacenter. The console and processor are at the left. An IBM 1442 card reader/punch is behind the IBM 1052 printer-keyboard that the operator is using. At the back, another operator is loading a tape onto an IBM 2401 tape drive. Photo from IBM.&quot; class=&quot;hilite&quot; height=&quot;396&quot; src=&quot;https://static.righto.com/images/8086-daa/model-50-ibm-w500.jpg&quot; title=&quot;The System/360 Model 50 in a datacenter. The console and processor are at the left. An IBM 1442 card reader/punch is behind the IBM 1052 printer-keyboard that the operator is using. At the back, another operator is loading a tape onto an IBM 2401 tape drive. Photo from IBM.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The System/360 Model 50 in a datacenter. The console and processor are at the left. An IBM 1442 card reader/punch is behind the IBM 1052 printer-keyboard that the operator is using. At the back, another operator is loading a tape onto an IBM 2401 tape drive. Photo from IBM.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;With the introduction of microprocessors, binary-coded decimal remained important.
The Intel 4004 microprocessor (1971) was designed for a calculator, so it needed decimal arithmetic, provided
by Decimal Adjust Accumulator (&lt;code&gt;DAA&lt;/code&gt;) instruction.
Intel implemented BCD in the Intel 8080 (1974).&lt;span id=&quot;fnref:datapoint&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:datapoint&quot;&gt;7&lt;/a&gt;&lt;/span&gt; This processor implemented an Auxiliary Carry (or half carry) flag and a &lt;code&gt;DAA&lt;/code&gt; instruction.
This was the source of the 8086&#39;s &lt;code&gt;DAA&lt;/code&gt; instruction, since the 8086 was designed to be somewhat compatible with the 8080.&lt;span id=&quot;fnref:translation&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:translation&quot;&gt;8&lt;/a&gt;&lt;/span&gt;
The Motorola 6800 (1974) has a similar &lt;code&gt;DAA&lt;/code&gt; instruction, while the 68000 had several BCD instructions.
The MOS 6502 (1975), however, took a more convenient approach: its decimal mode flag automatically performed BCD corrections.
This on-the-fly correction approach was &lt;a href=&quot;https://patents.google.com/patent/US3991307&quot;&gt;patented&lt;/a&gt;, which may explain
why it didn&#39;t appear in other processors.&lt;span id=&quot;fnref:2a03&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:2a03&quot;&gt;9&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The use of BCD in microprocessors was probably motivated by applications that interacted with the user in decimal,
from scales to video games.
These motivations also applied to microcontrollers.
The popular Texas Instruments TMS-1000 (1974) didn&#39;t support BCD directly, but it had special case instructions like
A6AAC (Add 6 to accumulator) to make BCD arithmetic easier.
The Intel 8051 microcontroller (1980) has a &lt;code&gt;DAA&lt;/code&gt; instruction.
The Atmel AVR (1997, used in Arduinos) has a half-carry flag to assist with BCD.&lt;/p&gt;
&lt;p&gt;Binary-coded decimal has lost popularity in newer microprocessors, probably because the conversion time between
binary and decimal is now insignificant.
The ill-fated Itanium, for instance, didn&#39;t support decimal arithmetic.
RISC processors, with their reduced instruction sets, cast aside less-important
instructions such as decimal arithmetic;
examples are ARM 1985), MIPS (1985), SPARC (1987), PowerPC (1992), and RISC-V (2010).
Even Intel&#39;s x86 processors are moving away from the &lt;code&gt;DAA&lt;/code&gt; instruction; it generates an invalid opcode exception in x86-64 mode.
Rather than BCD, IBM&#39;s POWER6 processor (2007) supports decimal floating point for business applications that use decimal arithmetic.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The DAA instruction is complicated and confusing as described in Intel documentation. Hopefully the simplified
code and explanation in this post make the instruction a bit easier to understand.&lt;/p&gt;
&lt;p&gt;Follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.
I wrote about the 8085&#39;s decimal adjust circuitry in &lt;a href=&quot;https://www.righto.com/2013/08/reverse-engineering-8085s-decimal.html&quot;&gt;this blog post&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:al&quot;&gt;
&lt;p&gt;The &lt;code&gt;AL&lt;/code&gt; register is the low byte of the processor&#39;s AX register. The DAA instruction only operates on a byte; there are no
16-bit or 32-bit versions.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:al&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:ascii&quot;&gt;
&lt;p&gt;The AAA (ASCII Adjust after Addition) and AAS (ASCII Adjust after Subtraction) instructions perform
corrections for unpacked BCD: a single digit per byte.
Dealing with a single digit, these instructions are considerably simpler.
These operations don&#39;t have much to do with ASCII except that they ignore and clear the upper 4 bits.
Since ASCII represents the characters 0 through 9 with the values 0x30 through 0x39, ASCII characters can
be used as input and the result will be a BCD digit.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;DAS&lt;/code&gt; (Decimal Adjust AL after Subtraction) instruction is similar to &lt;code&gt;DAA&lt;/code&gt; except that it
applies the correction after subtraction, subtracting the correction.
I&#39;m going to focus on &lt;code&gt;DAA&lt;/code&gt; in this article since the other instructions are similar.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:ascii&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:test&quot;&gt;
&lt;p&gt;My test code and results are on &lt;a href=&quot;https://github.com/shirriff/DAA&quot;&gt;GitHub&lt;/a&gt;.
The results should be the same on any x86 processor, but I did the test on a Pentium Dual-Core E5300 CPU.&lt;/p&gt;
&lt;p&gt;My &lt;code&gt;DAA&lt;/code&gt; test cases include values that couldn&#39;t result from a &quot;real&quot; BCD addition.
For example, the input 0x04 with AF set can&#39;t be generated by adding two BCD numbers because even 9+9 doesn&#39;t get
the result up to carry + 4. Not surprisingly, &lt;code&gt;DAA&lt;/code&gt; doesn&#39;t return a valid BCD result in this case, yielding 0x0a.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:test&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:99&quot;&gt;
&lt;p&gt;You might wonder why the code tests if &lt;code&gt;old_AL&amp;gt;99H&lt;/code&gt;, rather than simply checking the upper digit.
The reason is that the low digit can cause a half-carry during correction, messing up the upper digit.
This half-carry can only happen if the lower digit is greater than nine. The upper digit would only become
too big if it were 9. Thus, this case only happens if the old AL is more than 0x99.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:99&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:carry&quot;&gt;
&lt;p&gt;The carry flag value produced by DAA may seem arbitrary, but it is the value necessary for performing
multi-byte additions, where the carry from one addition is added to the next addition.
(This is just like handling carries when performing long addition by hand.)
Specifically, you want the carry set if the result has a carry-out (result &amp;gt; 99).
This happens if the original addition produces a carry, or if the &lt;code&gt;DAA&lt;/code&gt; operation generates a result &amp;gt; 99.
The latter case corresponds to an adjustment of the upper digit.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:carry&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:cards&quot;&gt;
&lt;p&gt;Punch cards were introduced in the late 1800s for the US Census and went through various formats until most
companies standardized on the 80-column card.
Support for alphanumeric values was added around 1932, but I&#39;m not going to go into that.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:cards&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:datapoint&quot;&gt;
&lt;p&gt;The earlier Intel 8008 microprocessor didn&#39;t have decimal 
arithmetic support because its instruction set and architecture copied the Datapoint 2200 desktop computer (1971), which
did not provide decimal arithmetic.
Since the Datapoint 2200 was designed as a &quot;programmable terminal&quot;, it primarily dealt with characters and BCD
was irrelevant to it.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:datapoint&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:translation&quot;&gt;
&lt;p&gt;The 8086 was designed to provide an upgrade path from the 8080, so it inherited many instructions and architectural
features along with the change from 8 bits to 16 bits.
The two processors were not binary compatible or even directly compatible at the assembly code level.
Instead, assembly code for the 8080 could be converted to 8086 assembly via a program called &lt;a href=&quot;https://archive.org/details/bitsavers_intel80869lyUsersManualOct79_62967963/page/n113/mode/2up&quot;&gt;CONV-86&lt;/a&gt;, which would usually require manual cleanup afterward. Many of the early programs for the 8086 were conversions of 8080 programs. &amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:translation&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:2a03&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Ricoh_2A03&quot;&gt;Ricoh 2A03&lt;/a&gt; (1983) was a microprocessor created for the NES video game
system. It was a clone of the 6502 except that it omitted the decimal adjust feature, presumably to avoid patent
infringement.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:2a03&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/1529067761550380331/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=1529067761550380331' title='10 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/1529067761550380331'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/1529067761550380331'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/01/understanding-x86s-decimal-adjust-after.html' title='Understanding the x86&#39;s Decimal Adjust after Addition (DAA) instruction'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>10</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-861830249857923940</id><published>2023-01-25T22:24:00.008-08:00</published><updated>2023-02-27T18:20:27.907-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="chips"/><category scheme="http://www.blogger.com/atom/ns#" term="microcode"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>Reverse-engineering the Intel 8086 processor&#39;s HALT circuits</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;

&lt;p&gt;The 8086 processor was introduced in 1978 and has greatly influenced modern computing through the x86 architecture.
One unusual instruction in this processor is HLT, which stops the processor and puts it in a halt state.
In this blog post, I explain in detail how the halt circuitry is implemented and how it interacts with the 8086&#39;s architecture.&lt;/p&gt;
&lt;p&gt;The die photo below shows the 8086 microprocessor under a microscope.
The metal layer on top of the chip is visible, with the silicon and polysilicon mostly hidden underneath.
Around the edges of the die, bond wires connect pads to the chip&#39;s 40 external pins.
I&#39;ve labeled the key functional blocks; the ones that are important to this discussion are darker and will be discussed in detail below.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top and an Execution Unit (EU) below.
The BIU handles memory accesses, while the Execution Unit (EU) executes instructions.
Both are stopped by a halt instruction.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-halt/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;624&quot; src=&quot;https://static.righto.com/images/8086-halt/die-labeled-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Halt processing in the Execution Unit&lt;/h2&gt;
&lt;p&gt;In this section, I&#39;ll explain how the HLT instruction is decoded and handled in the Execution Unit.
The 8086 uses a combination of lookup ROMs, logic, and microcode to implement instructions.
The process starts with the loader, a state machine that provides synchronization between the prefetch queue and
the decoding circuitry.
When an instruction byte is available, the loader provides a signal called First Clock that loads the instruction into the Instruction Register and starts the instruction decoding process.&lt;/p&gt;
&lt;p&gt;Before microcode gets involved, the Group Decode ROM classifies instructions by producing about 15 signals, indicating
properties such as instructions with a Mod R/M byte, instructions with a byte/word bit, instructions that always
act on a byte, and so forth.
For the HLT instruction, the Group Decode ROM provides two important signals. 
The first is one-byte logic (1BL), indicating that the instruction is one byte long and is implemented with logic
circuitry rather than microcode.&lt;span id=&quot;fnref:logic&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:logic&quot;&gt;1&lt;/a&gt;&lt;/span&gt; The second signal is produced for the HLT instruction specifically and generates the
internal HALT signal.
This signal travels to various parts of the 8086 to halt the processor.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-halt/group-rom.jpg&quot;&gt;&lt;img alt=&quot;The Group Decode ROM. The yellow rectangle detects the HLT instruction, with an output at the bottom. The red rectangle generates the 1BL (one-byte logic) signal.&quot; class=&quot;hilite&quot; height=&quot;470&quot; src=&quot;https://static.righto.com/images/8086-halt/group-rom-w500.jpg&quot; title=&quot;The Group Decode ROM. The yellow rectangle detects the HLT instruction, with an output at the bottom. The red rectangle generates the 1BL (one-byte logic) signal.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Group Decode ROM. The yellow rectangle detects the HLT instruction, with an output at the bottom. The red rectangle generates the 1BL (one-byte logic) signal.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;In the Execution Unit, the HALT signal blocks the reading of new instructions from the prefetch queue.
This causes the loader to wait indefinitely and stops execution of new instructions.
Since no new instruction replaces HLT, the Group Decode ROM continues to generate the HALT signal.
The HALT signal also blocks most of the other outputs from the Group Decode ROM, preventing other decoding actions.&lt;/p&gt;
&lt;p&gt;Thus, the Execution Unit sits idle as a result of the HLT instruction, unable to start a new instruction.
Modern processors often have low-power halt modes, where part of the processor is shut down or a clock domain is
stopped to reduce power consumption.
The 8086, however, doesn&#39;t do anything clever to minimize power consumption in the halt mode, since this wasn&#39;t
a concern for processors in the 1970s.&lt;/p&gt;
&lt;h2&gt;Halt processing in the Bus Interface Unit&lt;/h2&gt;
&lt;p&gt;Memory and I/O devices are connected to the 8086 chip through a bus that transmits address, data, and control information.
The 8086&#39;s Bus Interface Unit handles reads and writes over this bus, running independently from the Execution Unit.
A complete bus cycle for a read or write takes four clock periods, called T1, T2, T3, and T4,&lt;span id=&quot;fnref:Tw&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:Tw&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
with specific signals on the bus for each time state.&lt;/p&gt;
&lt;p&gt;A HLT instruction stops the Bus Interface Unit, but this takes several steps.
First, the Bus Interface Unit must complete any currently-running bus cycle. Any new bus cycle must be blocked.
Finally, 
the processor indicates the HALT state to any devices on the bus by issuing a special T1 cycle over the bus.&lt;/p&gt;
&lt;p&gt;The main HALT control signal inside the Bus Interface Unit is something I call &lt;code&gt;halt-not-hold&lt;/code&gt;, indicating a HALT is active,
but not a HOLD. (Ignore the HOLD part for now.)
This signal is activated by the HLT instruction signal from the Group Decode ROM, except it is blocked by
any bus operations in progress. Once any current bus operation reaches T2, &lt;code&gt;halt-not-hold&lt;/code&gt; gets activated and
starts the halt process while the current bus cycle finishes up.&lt;/p&gt;
&lt;p&gt;To prevent new bus activity,
the &lt;code&gt;halt-not-hold&lt;/code&gt; signal blocks new prefetch requests.
The only other source of bus activity is an instruction that performs reads or writes.
But the current instruction is HLT, so it won&#39;t generate any bus traffic.
Thus, the Bus Interface Unit will remain idle.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-halt/mem-ctrl.jpg&quot;&gt;&lt;img alt=&quot;The read/write control circuitry on the die with the flip-flops labeled. Metal and polysilicon were removed to show the underlying silicon.&quot; class=&quot;hilite&quot; height=&quot;424&quot; src=&quot;https://static.righto.com/images/8086-halt/mem-ctrl-w500.jpg&quot; title=&quot;The read/write control circuitry on the die with the flip-flops labeled. Metal and polysilicon were removed to show the underlying silicon.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The read/write control circuitry on the die with the flip-flops labeled. Metal and polysilicon were removed to show the underlying silicon.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The circuitry to control the bus cycle is complicated with many flip-flops and logic gates;
the diagram above shows the flip-flops.
I plan to write about the bus cycle circuitry in detail later, but for now, I&#39;ll give an extremely simplified description.
Internally, there is a T0 state before T1 to provide a cycle to set up the bus operation.
The bus timing states are controlled by a chain of flip-flops configured like
a shift register with additional logic:
the output from the T0 flip-flop is connected to the input of the T1 flip-flop and likewise with T2 and T3, forming
a chain.
A bus cycle is started by putting a 1 into the input of the T0 flip-flop.&lt;span id=&quot;fnref:inverted&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:inverted&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
When the CPU&#39;s clock transitions, the
flip-flop latches this signal, indicating the (internal) T0 bus state.
On the next clock cycle, this 1 signal goes from the T0 flip-flop to the T1 flip-flop, creating the externally-visible
T1 state.
Likewise, the signal passes to the T2 and T3 flip-flops in sequence, creating the bus cycle.&lt;/p&gt;
&lt;p&gt;A slightly different path is used to generate the special T1 signal that indicates a HALT.
Once any bus activity is completed, the &lt;code&gt;halt-not-hold&lt;/code&gt; signal puts a 1 into the T1 flip-flop through some gates.
This generates the T1 signal, bypassing T0.
Moreover, this signal does not propagate to the T2 flip-flop because it is blocked by &lt;code&gt;halt-not-hold&lt;/code&gt; and some gates.
Another flip-flop blocks this T1 cycle after the first cycle so &lt;code&gt;halt-not-hold&lt;/code&gt; doesn&#39;t repeately trigger it.
Overall, this special HALT T1 state looks like a special case that was hacked into the circuitry.&lt;/p&gt;
&lt;p&gt;One complication is the bus hold feature.
The 8086 supports complex bus configurations, where external devices may take control of the bus.
For instance, peripherals may use the bus for
direct memory access, bypassing the CPU.
A device can request control of the bus, a &quot;bus hold&quot;, through the 8086&#39;s HOLD pin.&lt;span id=&quot;fnref:hold&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:hold&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
This causes the 8086 to electrically stop putting signals on the bus
(i.e. a high-impedance, tri-state off state). This allows another device to use the bus until it releases HOLD.&lt;/p&gt;
&lt;p&gt;Even when the CPU is halted, the CPU still has &quot;ownership&quot; of the bus and drives the bus with idle signals.&lt;span id=&quot;fnref:floating&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:floating&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
If a device requests a bus hold when the CPU is halted, the &lt;code&gt;halt-not-hold&lt;/code&gt; signal is blocked.
When the device releases the hold, &lt;code&gt;halt-not-hold&lt;/code&gt; is unblocked.
This causes the 8086 to go through the special T1 cycle again, using the same flip-flop process described above.
This lets listeners on the bus know that the CPU is still halted.&lt;/p&gt;
&lt;h2&gt;Exiting the halt state&lt;/h2&gt;
&lt;p&gt;The processor exits the halt state when it receives a reset, interrupt, or non-maskable interrupt.
To implement this, an interrupt unblocks the instruction decoder by overriding the queue-unavailable signal.
This causes the loader, which controls instruction decoding, to move into the First Clock state.
Meanwhile, the interrupt causes the microcode address register to be loaded with the hardcoded microcode address
of the appropriate interrupt routine.
Thus, the microcode engine starts running the interrupt handler microcode.&lt;/p&gt;
&lt;p&gt;The Instruction Register holds the 8-bit opcode that is currently being processed.
It has a ninth bit that indicates if an interrupt is being processed.
The Instruction Register (including the interrupt bit) is loaded on First Clock (described above).
It outputs the instruction and interrupt bit to the Group Decode ROM one clock cycle later.
The interrupt bit blocks regular instruction decoding by the Group Decode ROM.
In particular, the HLT instruction will no longer be decoded, dropping the HALT signal throughout the CPU.
In the Execution Unit, this reactivates the prefetch queue. This will allow instruction execution once
the microcode finishes executing the interrupt handling code.
In the Bus Interface Unit, dropping the HALT signal causes &lt;code&gt;halt-not-hold&lt;/code&gt; to drop.
This enables bus activity from the Bus Interface Unit.&lt;span id=&quot;fnref:prefetch&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:prefetch&quot;&gt;6&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;History of HALT and x86&lt;/h2&gt;
&lt;p&gt;Historically, computers usually had some sort of &quot;stop&quot; or &quot;wait&quot; instruction to stop execution at the end of a program.
This goes back to the electromechanical Harvard Mark I (1944), EDSCAC (1949), and Univac I (1951), among other machines.
Most (but not all) mainframes and minicomputers continued this approach.&lt;span id=&quot;fnref:blaauw&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:blaauw&quot;&gt;7&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;!-- https://bitsavers.org/pdf/datapoint/2200/2200_Programmers_Man_Aug71.pdf p1-18 --&gt;

&lt;p&gt;The HLT instruction in the 8086, like many other features, derives from the Datapoint 2200, and there&#39;s an
interesting story behind that.
The Datapoint 2200 was a desktop computer announced in 1970, and sold as a &quot;programmable terminal&quot;.
The processor of the Datapoint 2200 was implemented with a board of TTL integrated circuits,
since this was before microprocessors.
The Datapoint manufacturer talked to Intel and Texas Instruments about replacing the board of
chips with a single processor chip.
Texas Instruments produced the &lt;a href=&quot;http://www.righto.com/2015/05/the-texas-instruments-tmx-1795-first.html&quot;&gt;TMX 1795&lt;/a&gt; microprocessor chip and Intel produced the 8008 shortly after,&lt;span id=&quot;fnref:4004&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:4004&quot;&gt;8&lt;/a&gt;&lt;/span&gt; both copying the Datapoint 2200&#39;s architecture and instruction set.
Datapoint didn&#39;t like the performance of these chips and decided to stick with a TTL-based processor.
Texas Instruments couldn&#39;t find a customer for the TMX 1795 and abandoned it.
Intel, on the other hand, sold the 8008 as an 8-bit microprocessor, creating the microprocessor market in the process.
Intel improved the 8008 to create the popular 8080 microprocessor (1974). Zilog produced the more powerful Z80 (1976), backward-compatible
with the 8080.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-halt/datapoint-2200.jpg&quot;&gt;&lt;img alt=&quot;The Datapoint 2200. This is the later Model II with an improved TTL processor using the 74181 ALU chip.&quot; class=&quot;hilite&quot; height=&quot;439&quot; src=&quot;https://static.righto.com/images/8086-halt/datapoint-2200-w600.jpg&quot; title=&quot;The Datapoint 2200. This is the later Model II with an improved TTL processor using the 74181 ALU chip.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Datapoint 2200. This is the later Model II with an improved TTL processor using the 74181 ALU chip.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Intel started designing the iAPX 432 in 1975 to be their high-end 32-bit processor, a &quot;micromainframe&quot; that supported garbage
collection and objects in the processor. 
The iAPX 432 was too complex for the time and as the schedule slipped, Intel decided to produce a stopgap 16-bit
processor to compete with Zilog and Motorola:
this processor became the 8086.
To make it easier for Intel customers to move to the 8086, the processor was designed for compatibility with 8080 assembly language so it inherited much of the architecture and instruction set, although extended from 8 bits to 16 bits.&lt;span id=&quot;fnref:translation&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:translation&quot;&gt;9&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The consequence of this history is that the 8086 inherited many features from the Datapoint 2200.
The Datapoint 2200 used cheaper shift-register memory so it had a serial processor
that operated on one bit at a time.
This required the Datapoint 2200 to be little-endian, a feature that lives on in the x86 architecture.
Since the Datapoint 2200 was marketed as a programmable terminal, it had parity calculation built into the hardware.
Thus, the 8008 and descendants have a parity flag, in contrast to contemporary processors such as the 6800 and 6502 that omitted this moderately complex feature.
The use of I/O ports instead of memory-mapped I/O is another feature of the Datapoint 2200 that persists in the x86, but was not used in the 6800 and 6502 and their descendants.
The opcodes of the Datapoint 2200 were based on octal 3-bit fields for hardware reasons. The x86 instructions are still &lt;a href=&quot;https://gist.github.com/seanjensengrey/f971c20d05d4d0efc0781f2f3c0353da&quot;&gt;designed around octal&lt;/a&gt;, but the usual hexadecimal display obscures their structure.
Finally, the Datapoint 2200&#39;s HALT instruction was exactly copied by the 8008&lt;span id=&quot;fnref:datapoint&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:datapoint&quot;&gt;10&lt;/a&gt;&lt;/span&gt; and persists in x86.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The HLT instruction seems like a simple function, but its implementation touches many parts of the 8086.
It is implemented in logic circuitry, completely bypassing the microcode.
The implementation became more complicated because of the 8086&#39;s four-step bus protocol, as well as interaction between halting
and the bus hold feature.
This illustrates how complexity creates more complexity, something the RISC processors of the 1980s tried to counter.&lt;/p&gt;
&lt;p&gt;I&#39;ve written multiple &lt;a href=&quot;https://www.righto.com/search/label/8086&quot;&gt;posts on the 8086&lt;/a&gt; so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.
Thanks to monocasa for suggesting this topic.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:logic&quot;&gt;
&lt;p&gt;The instructions implemented outside microcode are the segment register prefixes (ES:, CS:, SS:, DS:),
   the other prefixes (LOCK, REPNZ, REPZ), the simple flag instructions (CMC, CLC, STC, CLI, STI, CLD, STD), and HLT.
   These instructions are indicated by the 1BL (one-byte logic) output from the Group Decode ROM.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:logic&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:Tw&quot;&gt;
&lt;p&gt;The bus cycle may also include optional Tw wait states after T3 for slow memory.
The memory (or I/O device) lowers the READY pin until it is ready to proceed and the Bus Interface Unit waits.
I&#39;m ignoring Tw states in this discussion to keep things simpler.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:Tw&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:inverted&quot;&gt;
&lt;p&gt;For some reason, the T-state flip-flops all hold inverted signals, so strictly speaking a 0 bit goes through the flip-flops.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:inverted&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:hold&quot;&gt;
&lt;p&gt;The 8086 has a separate prioritized &quot;request/grant&quot; way for a device to obtain a bus hold, but it
doesn&#39;t change the underlying hold behavior.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:hold&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:floating&quot;&gt;
&lt;p&gt;During a HALT, the 8086 is not actively using the bus, but it does not release the bus either; it is still
electrically driving the bus. Otherwise, the bus would float to random voltages, confusing attached memory chips
or other circuitry.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:floating&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:prefetch&quot;&gt;
&lt;p&gt;When the Bus Interface Unit is unhalted due to an interrupt, you might expect it to immediately start
prefetching, accessing unwanted instructions.
It turns out that the prefetch circuitry does try to start prefetching and reaches the internal T0
bus state. But it then gets preempted by
the interrupt handler microcode, which uses the bus to send two interrupt acknowledge cycles.
Immediately after, the microcode routine suspends prefetching. Thus, prefetching doesn&#39;t run until the interrupt
microcode finishes and reenables prefetching.
There&#39;s a lot of tricky timing in the 8086 to make everything work.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:prefetch&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:blaauw&quot;&gt;
&lt;p&gt;For more history of the stop instruction, see &quot;Computer Architecture&quot;, Blaauw and Brooks, page 349.
(This the same Brooks who wrote &quot;The Mythical Man-Month&quot; and &quot;No Silver Bullet&quot;.)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:blaauw&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:4004&quot;&gt;
&lt;p&gt;You might wonder how the Intel 4004 fits into this history. Although many of the same people worked on both chips,
they have completely different architectures.  The 8008 is not at all an 8-bit version of the 4-bit 4004.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:4004&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:translation&quot;&gt;
&lt;p&gt;Assembly code for the 8-bit 8080 processor couldn&#39;t run directly on the 16-bit 8086. Instead, a translation program
converted the 8080 assembly language to be compatible with the 8086, making some changes in the process.
The 8086 dropped some of the less-useful instructions of the 8080, replacing them with multiple instructions in
the translation.
For instance, the 8080 had conditional subroutine call and return instructions (inherited from the Datapoint 2200), but
the 8086 dropped them.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:translation&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:datapoint&quot;&gt;
&lt;p&gt;To see that the 8008 copied the Datapoint 2200&#39;s HALT instruction, note that the Datapoint had three opcodes for
HALT (00, 01, and FF), which is a bit unusual. The 8008 also has three opcodes for HLT: 00, 01, and FF.
Most instructions in the 8008 used the same opcode values as the &lt;a href=&quot;https://bitsavers.org/pdf/datapoint/2200/2200_Reference_Manual.pdf&quot;&gt;Datapoint&lt;/a&gt;, with a few minor changes.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:datapoint&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/861830249857923940/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=861830249857923940' title='4 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/861830249857923940'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/861830249857923940'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/01/reverse-engineering-intel-8086.html' title='Reverse-engineering the Intel 8086 processor&#39;s HALT circuits'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-1961567496323199284</id><published>2023-01-23T10:29:00.008-08:00</published><updated>2023-01-24T10:17:35.788-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="chips"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>Reverse-engineering the conditional jump circuitry in the 8086 processor</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;

&lt;p&gt;Intel introduced the 8086 microprocessor in 1978 and it had a huge influence on computing.
I&#39;m reverse-engineering the
8086 by examining the circuitry on its silicon die and in this blog post I take a look at how conditional jumps
are implemented.
Conditional jumps are an important part of any instruction set, changing the flow of execution based on
a condition.
Although this instruction may seem simple, it involves many parts of the CPU:
the 8086 uses microcode along with special-purpose condition logic.&lt;/p&gt;
&lt;p&gt;The die photo below shows the 8086 microprocessor under a microscope.
The metal layer on top of the chip is visible, with the silicon and polysilicon mostly hidden underneath.
Around the edges of the die, bond wires connect pads to the chip&#39;s 40 external pins.
I&#39;ve labeled the key functional blocks; the ones that are important to this discussion are darker and will be discussed in detail below.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top and an Execution Unit (EU) below.
The BIU handles memory accesses, while the Execution Unit (EU) executes instructions.
Most of the relevant circuitry is in the Execution Unit, such as the condition evaluation circuitry near the center,
and the microcode in the lower right. But the Bus Interface Unit plays a part too, holding and modifying the program counter.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-conditional/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;621&quot; src=&quot;https://static.righto.com/images/8086-conditional/die-labeled-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Microcode&lt;/h2&gt;
&lt;p&gt;Most people think of machine instructions as the basic steps that a computer performs.
However, many processors (including the 8086) have another layer of software underneath: microcode.
One of the hardest parts of computer design is creating the control logic that directs the processor for each step of an instruction.
The straightforward approach is to build a circuit from flip-flops and gates that moves through the various steps and generates the control signals.
However, this circuitry is complicated, error-prone, and hard to design.&lt;/p&gt;
&lt;p&gt;The alternative is microcode: instead of building the control circuitry from complex logic gates, the control logic is largely replaced with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.
In other words, microcode forms another layer between the machine instructions and the hardware.
The main advantage of microcode is that it turns design of control circuitry into a programming task instead of a difficult logic design task.&lt;/p&gt;
&lt;p&gt;The 8086 uses a hybrid approach: although the 8086 uses microcode, much of the instruction functionality is implemented with gate logic.
This approach removed duplication from the microcode and kept the microcode small enough for 1978 technology.
In a sense, the microcode is parameterized.
For instance, the microcode can specify a generic Arithmetic/Logic Unit (ALU) operation, and the gate logic determines from the instruction which ALU (Arithmetic/Logic Unit) operation to perform.
More relevant to this blog post, the microcode can specify a generic conditional test and the gate logic determines which condition to use.
Although this made the 8086&#39;s gate logic more complicated, the tradeoff was worthwhile.&lt;/p&gt;
&lt;h3&gt;Microcode for conditional jumps&lt;/h3&gt;
&lt;p&gt;The 8086 processor has six status flags:
carry, parity, auxiliary carry, zero, sign, and overflow.&lt;span id=&quot;fnref:flags&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:flags&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
These flags are updated by arithmetic and logic operations based on the result.
The 8086 has sixteen different conditional jump instructions&lt;span id=&quot;fnref:others&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:others&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
that test status flags and jump if conditions are satisfied, such as zero, less than, or odd parity.
These instructions are very important since they permit &lt;code&gt;if&lt;/code&gt; statements, loops, comparisons, and so forth.&lt;/p&gt;
&lt;p&gt;In machine language, a conditional jump opcode is followed by a signed offset byte which specifies
a location relative to the current program counter, from 127 bytes ahead
to 128 bytes back.
This is a fairly small range, but the benefit is that the offset fits in a single byte, reducing the code size.&lt;span id=&quot;fnref:longjmp&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:longjmp&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
For typical applications such as loops or conditional code, jumps usually stay in the same neighborhood of code,
so the tradeoff is worthwhile.&lt;/p&gt;
&lt;p&gt;The 8086&#39;s microcode was disassembled by Andrew Jenner (&lt;a href=&quot;https://www.reenigne.org/blog/8086-microcode-disassembled/&quot;&gt;link&lt;/a&gt;) from my die photos, so we can see exactly what micro-instructions the 8086 is running for each machine instruction.
The microcode below implements conditional jumps.
In brief, the conditional jump code (Jcond) gets the branch offset byte.
It tests the appropriate condition and, if satisfied, jumps to the relative jump microcode (&lt;code&gt;RELJUMP&lt;/code&gt;).
The &lt;code&gt;RELJMP&lt;/code&gt; code adds the offset to the program counter.
In either case, the microcode routine ends when it runs the next instruction (&lt;code&gt;RNI&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;
   move       action
Jcond:
1 QtmpBL
2          XC    RELJMP                    
3          RNI                       

RELJMP:
4          SUSP
5          CORR                      
6 PCtmpA  ADD   tmpA
7 PC     FLUSH RNI                       
&lt;/pre&gt;

&lt;p&gt;In more detail, micro-instruction 1 (arbitrary numbering) moves a byte from the prefetch queue (&lt;code&gt;Q&lt;/code&gt;) across the queue bus to the
ALU&#39;s temporary B register.&lt;span id=&quot;fnref:sign&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:sign&quot;&gt;4&lt;/a&gt;&lt;/span&gt; (Arguments for ALU operations are first stored in temporary registers, invisible to the programmer.)
Instruction 2 tests the appropriate condition with &lt;code&gt;XC&lt;/code&gt;, and jumps to the &lt;code&gt;RELJMP&lt;/code&gt; routine if the condition is satisfied.&lt;span id=&quot;fnref:reljmp&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:reljmp&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
Otherwise, &lt;code&gt;RNI&lt;/code&gt; (Run Next Instruction) ends this sequence and loads the next machine instruction without jumping.&lt;/p&gt;
&lt;p&gt;If the condition is satisfied, the relative jump routine starts with instruction 4, which suspends prefetching.&lt;span id=&quot;fnref:prefetching&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:prefetching&quot;&gt;6&lt;/a&gt;&lt;/span&gt;
Instruction 5 corrects the program counter value, since it normally points to the next byte to prefetch,
not the next byte to execute.
Instruction 6 moves the corrected program counter address to the ALU&#39;s temporary A register.
It also starts an ALU operation to add temporary A and temporary B.
Instruction 7 moves the sum (&lt;code&gt;&lt;/code&gt;) to the program counter.
It flushes the prefetch queue, which starts up prefetching from the new PC value.
Finally, &lt;code&gt;RNI&lt;/code&gt; runs the next instruction, from the updated address.&lt;/p&gt;
&lt;p&gt;This code supports all 16 conditional jumps because the microcode tests the generic
&quot;XC&quot; condition.
This indicates that the specific test depends on the four low bits of the opcode, and the hardware determines
exactly what to test.
It&#39;s important to keep the two levels straight: the machine instruction is doing a conditional jump to a different memory address, while the microcode that implements this instruction is performing a conditional jump to a different micro-address.&lt;/p&gt;
&lt;h3&gt;The timing for conditional jumps&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;RNI&lt;/code&gt; (Run Next Instruction) micro-operation initiates processing of the next machine instruction.
However, it takes a clock cycle to get the next instruction from the prefetch queue, decode it, and start the
appropriate micro-instruction.
This causes a wasted clock cycle before the next micro-instruction executes.
To avoid this delay, most microcode routines issue a &lt;code&gt;NXT&lt;/code&gt; micro-operation one cycle before they end.
This gives the 8086 time to decode the next machine instruction so micro-instructions can run uninterrupted.&lt;/p&gt;
&lt;p&gt;Unfortunately, the conditional jump instructions can&#39;t take advantage of &lt;code&gt;NXT&lt;/code&gt;.
The problem is that the control flow in the microcode depends on whether the conditional jump is taken or not.
By the time the microcode knows it is not taking the branch, it&#39;s too late to issue &lt;code&gt;NXT&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The datasheet gives the timing of a conditional jump as 4 clock cycles if the jump is not taken, and 8 clock
cycles if the jump is taken.
Looking at the microcode explains these timings. There are 3 micro-instructions executed if the jump is not taken, and 7
if it is taken. Because of the &lt;code&gt;RNI&lt;/code&gt;, there is one wasted clock cycle, resulting in the documented 4 or 8 cycles in total.&lt;/p&gt;
&lt;h2&gt;The conditions&lt;/h2&gt;
&lt;p&gt;At this point I will review the 8086&#39;s conditional jumps.
The 8086 implements 16 conditional jumps. (This is a large number compared to earlier CPUs:
the 8080, 6502, and Z80 all had 8 conditional jumps, specified by 3 bits.)
The table below shows which flags are tested for each condition, specified by the low four bits of the opcode.
Some jump instructions have multiple names depending on the programmer&#39;s interpretation, but they map to the same machine instruction.&lt;span id=&quot;fnref:signed&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:signed&quot;&gt;7&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
table#jumps {border: 1px solid #ccc; border-collapse:collapse;font-size:85%;}
table#jumps tr td:nth-child(2) {border-right: 2px solid #ccc;}
table#jumps tr td {border: 1px solid #ccc;}
table#jumps tr th {border-bottom: 2px solid #ccc;}
table#jumps th {padding: 5 10px; vertical-align: top; text-align: center;}
table#jumps td {padding: 5 10px; vertical-align: top; text-align: left;}
&lt;/style&gt;

&lt;table id=&quot;jumps&quot;&gt;
&lt;tr&gt;&lt;th&gt;Condition&lt;/th&gt;&lt;th&gt;Bits&lt;/th&gt;&lt;th&gt;Condition true&lt;/th&gt;&lt;th&gt;Condition false&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;Overflow Flag (OF)=1&lt;/td&gt;&lt;td&gt;000x&lt;/td&gt;&lt;td&gt;overflow (JO)&lt;/td&gt;&lt;td&gt;not overflow (JNO)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Carry Flag (CF)=1&lt;/td&gt;&lt;td&gt;001x&lt;/td&gt;&lt;td&gt;carry (JC)&lt;br/&gt;
below (JB)&lt;br/&gt;
not above or equal (JNAE)&lt;/td&gt;&lt;td&gt;not carry (JNC)&lt;br/&gt;
not below (JNB)&lt;br/&gt;
above or equal (JAE)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Zero Flag (ZF)=1&lt;/td&gt;&lt;td&gt;010x&lt;/td&gt;&lt;td&gt;zero (JZ)&lt;br/&gt;
equal (JE)&lt;/td&gt;&lt;td&gt;not zero (JNZ)&lt;br/&gt;
not equal (JNE)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;CF=1 or ZF=1&lt;/td&gt;&lt;td&gt;011x&lt;/td&gt;&lt;td&gt;below or equal (JBE)&lt;br/&gt;
not above (JNA)&lt;/td&gt;&lt;td&gt;not below or equal (JNBE)&lt;br/&gt;
above (JA)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Sign Flag (SF)=1&lt;/td&gt;&lt;td&gt;100x&lt;/td&gt;&lt;td&gt;sign (JS)&lt;/td&gt;&lt;td&gt;not sign (JNS)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Parity Flag (PF)=1&lt;/td&gt;&lt;td&gt;101x&lt;/td&gt;&lt;td&gt;parity (JP)&lt;br/&gt;
parity even (JPE)&lt;/td&gt;&lt;td&gt;not parity (JNP)&lt;br/&gt;
parity odd (JPO)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;SF  OF&lt;/td&gt;&lt;td&gt;110x&lt;/td&gt;&lt;td&gt;less (JL)&lt;br/&gt;
not greater or equal (JNGE)&lt;/td&gt;&lt;td&gt;not less (JNL)&lt;br/&gt;
greater or equal (JGE)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ZF=1 or SF  OF&lt;/td&gt;&lt;td&gt;111x&lt;/td&gt;&lt;td&gt;less or equal (JLE)&lt;br/&gt;
not greater (JNG)&lt;/td&gt;&lt;td&gt;not less or equal (JNLE)&lt;br/&gt;
greater (JG)&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;From the hardware perspective, the important thing is that there are eight different condition flag tests.
Each test has two jump instructions associated with it: one that jumps if the condition is true, and one that jumps
if the condition is false.
The low bit of the opcode selects &quot;if true&quot; or &quot;if false&quot;.&lt;/p&gt;
&lt;p&gt;The image below shows the condition evaluation circuitry as it appears on the die. There isn&#39;t much structure to it; it&#39;s just
a bunch of gates.
This image shows the doped silicon regions that form transistors. The numerous small polygons with a circle inside
are connections between the metal layer and the polysilicon layer. Many of these connections use the silicon layer
to optimize the layout.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-conditional/conditions-die.jpg&quot;&gt;&lt;img alt=&quot;The circuitry to compute conditions as it appears on the die. The metal and polysilicon layers have been removed for this image, showing the silicon underneath.&quot; class=&quot;hilite&quot; height=&quot;275&quot; src=&quot;https://static.righto.com/images/8086-conditional/conditions-die-w500.jpg&quot; title=&quot;The circuitry to compute conditions as it appears on the die. The metal and polysilicon layers have been removed for this image, showing the silicon underneath.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The circuitry to compute conditions as it appears on the die. The metal and polysilicon layers have been removed for this image, showing the silicon underneath.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;This circuitry evaluates each condition by getting the instruction bits from the Instruction Register,
checking the bits to match each condition, and testing if the condition is satisfied.
For instance, the overflow condition (with instruction bits 000x) is computed by a NOR gate: &lt;code&gt;NOR(IR3, IR2, IR1, OF&#39;)&lt;/code&gt;, which will be true if instruction register bits 3, 2, and 1 are zero and the Overflow Flag is 1.&lt;/p&gt;
&lt;p&gt;The results from the individual condition tests are combined with a 7-input NOR gate, producing a result that is 0 if the specified 3-bit condition is satisfied.
Finally, the &quot;if true&quot; and &quot;if false&quot; cases are handled by flipping this signal depending on the low bit of the instruction.
This final result indicates if the 4-bit condition in the instruction is satisfied, and this signal is passed on
to the microcode control circuitry.&lt;/p&gt;
&lt;p&gt;One unexpected feature of the implementation is that a 7-input NOR gate combines the various conditions to
test if the selected condition is satisfied.
You&#39;d expect that with eight conditions, there would be eight inputs to the NOR gate.
However, there is a clever optimization that takes advantage of
conditions that are combinations of clauses, for example, &quot;less or equal&quot;.
Specifically, the zero flag is tested for bit pattern 01xx (where x indicates a 0 or 1), which covers two conditions with one gate.
Likewise, SFOF is tested for bit pattern 11xx and CF=1 is tested for bit pattern 0x1x.
With these optimizations, the eight conditions are covered with seven checks.
(This shows that the opcodes weren&#39;t assigned arbitrarily: the bit patterns needed to be carefully assigned for this to work.)&lt;/p&gt;
&lt;h2&gt;Back to the microcode&lt;/h2&gt;
&lt;p&gt;Before explaining how the microcode jump circuitry works, I&#39;ll briefly discuss the microcode format.
A micro-instruction is encoded into 21 bits as shown below.
Every micro-instruction contains a move from a source register to a destination register, each specified with 5 bits.
The meaning of the remaining bits is a bit tricky since it depends on the type field, which is two or three bits long.
The &quot;short jump&quot; (type 0) is a conditional jump within the current block of 16 micro-instructions.
The ALU operation (type 1) sets up the arithmetic-logic unit to perform an operation.
Bookkeeping operations (type 4) are anything from flushing the prefetch queue to ending the current instruction.
A memory read or write is type 6.
A &quot;long jump&quot; (type 5) is a conditional jump to any of 16 fixed microcode locations (specified in an external table).
Finally, a &quot;long call&quot; (type 7) is a conditional subroutine call to one of 16 locations (different from the jump targets).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-conditional/microcode-format.jpg&quot;&gt;&lt;img alt=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; class=&quot;hilite&quot; height=&quot;203&quot; src=&quot;https://static.righto.com/images/8086-conditional/microcode-format-w700.jpg&quot; title=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The encoding of a micro-instruction into 21 bits. Based on &lt;a href=&quot;https://digitalcommons.law.scu.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=1031&amp;context=chtlj&quot;&gt;NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;I&#39;m going to focus on the &lt;code&gt;XC RELJMP&lt;/code&gt; micro-instruction that we saw in the microcode earlier.
This is a &quot;long jump&quot; with &lt;code&gt;XC&lt;/code&gt; as the condition and &lt;code&gt;RELJMP&lt;/code&gt; as the target tag.
Another layer of hardware is required to implement the microcode conditions.
The microcode supports 16 conditions, which are completely different from the 16 programmer-level conditions.&lt;span id=&quot;fnref:conditions&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:conditions&quot;&gt;8&lt;/a&gt;&lt;/span&gt;
Some microcode conditions test special-purpose internal flags, while others test conditions such as an interrupt, the chip&#39;s TEST pin,
bit 3 of the opcode, or if the instruction has a one-byte address offset.
The &lt;code&gt;XC&lt;/code&gt; condition is one of these 16 conditions, number 15 specifically.&lt;/p&gt;
&lt;p&gt;The conditions are evaluated by the condition PLA (Programmable Logic Array, a grid of gates), shown below.
The four condition bits from the micro-instruction, along with their complements, are fed into the columns.
The PLA has 16 rows, one for each condition. 
Each row is a NOR gate matching one bit combination (i.e. selecting a condition) and the corresponding signal value to
test.&lt;span id=&quot;fnref:pla&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:pla&quot;&gt;9&lt;/a&gt;&lt;/span&gt;
Thus, if a particular condition is specified and is satisfied, that row will be 1.
The 16 row outputs are combined by the 16-input NOR gate at the left.
Thus, if the specified condition is satisfied, this output will be 0, and if the condition is unsatisfied, the
output will be 1.
This signal controls the jump or call micro-instruction:
if the condition is satisfied, the new micro-address is loaded into the microcode address register.
If the condition is not satisfied, the microcode proceeds sequentially.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-conditional/condition-pla.jpg&quot;&gt;&lt;img alt=&quot;The condition PLA evaluates microcode conditionals.&quot; class=&quot;hilite&quot; height=&quot;467&quot; src=&quot;https://static.righto.com/images/8086-conditional/condition-pla-w300.jpg&quot; title=&quot;The condition PLA evaluates microcode conditionals.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The condition PLA evaluates microcode conditionals.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;To summarize, the 8086 processor implements 16 conditional jump instructions.
One piece of microcode efficiently implements all 16 instructions, with gate logic determining which flags to test, depending
on bits in the machine instruction.
The result of this test is used by the microcode &lt;code&gt;XC&lt;/code&gt; conditional jump, one of 16 completely different microcode-level
conditions. If the &lt;code&gt;XC&lt;/code&gt; condition is satisfied, the program counter is updated by adding the offset,
jumping to the new location.&lt;/p&gt;
&lt;p&gt;Conditional jumps are relatively straightforward instructions from the programmer&#39;s perspective,
but they interact with most parts of the 8086 processor
including
the prefetch queue, the address adder, the ALU, microcode, and the Translation ROM.
The diagram below shows the interactions for each step of the jump.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-conditional/die-diagram.jpg&quot;&gt;&lt;img alt=&quot;The conditional jump involves many parts of the die, shown in this diagram.&quot; class=&quot;hilite&quot; height=&quot;686&quot; src=&quot;https://static.righto.com/images/8086-conditional/die-diagram-w700.jpg&quot; title=&quot;The conditional jump involves many parts of the die, shown in this diagram.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The conditional jump involves many parts of the die, shown in this diagram.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;I&#39;ve written multiple &lt;a href=&quot;https://www.righto.com/search/label/8086&quot;&gt;posts on the 8086&lt;/a&gt; so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:flags&quot;&gt;
&lt;p&gt;In addition to the six status flags, the 8086 has three control flags: trap, direction, and interrupt enable.
These flags aren&#39;t tested by conditional branches so I won&#39;t discuss them further.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:flags&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:others&quot;&gt;
&lt;p&gt;Strictly speaking, the 8086 has a few more conditional jumps. The JCXZ instruction tests if the CX register is zero.
The LOOP, LOOPNZ, and LOOPZ instructions decrement the CX register and loop if it is nonzero.
The last two only loop if the zero flag indicates nonzero or zero, respectively.
I&#39;m ignoring these instructions in the blog post.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:others&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:longjmp&quot;&gt;
&lt;p&gt;Although a conditional jump only supports a small range,
it&#39;s still possible to conditionally jump to a distant location by using two instructions.
A conditional jump with the opposite condition can skip over a longer unconditional jump instruction.
The 80386 removed this restriction by providing long-displacement conditional jumps, which could perform a 16-bit or 32-bit relative jump.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:longjmp&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:sign&quot;&gt;
&lt;p&gt;The relative offset byte is sign-extended when it is moved to the temporary B register.
That is, if the top bit is high, the high byte is set to all 1&#39;s to produce a 16-bit negative value.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:sign&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:reljmp&quot;&gt;
&lt;p&gt;The details of how the microcode jumps to the RELJMP routine are interesting, but a bit of a tangent,
so I&#39;ve put this discussion in a footnote.
For long jumps (and long calls) in microcode, the target micro-addresses are stored in the Translation ROM, and
the 4-bit target tag indexes into this ROM.
The motivation for this structure is that micro-addresses are 13 bits, which is a lot of bits to try to fit into
a 21-bit micro-instruction. 
Using a 4-bit tag keeps the microcode compact, but at the cost of requiring a small ROM in the 8086.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-conditional/translation-rom.jpg&quot;&gt;&lt;img alt=&quot;The translation ROM on the die.&quot; class=&quot;hilite&quot; height=&quot;726&quot; src=&quot;https://static.righto.com/images/8086-conditional/translation-rom-w400.jpg&quot; title=&quot;The translation ROM on the die.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The translation ROM on the die.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Above is a view of the Translation ROM, with the RELJMP entry highlighted.
The left half decodes tags, while the right half provides the corresponding microcode address.
The row for RELJMP is highlighted.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:reljmp&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:prefetching&quot;&gt;
&lt;p&gt;Much of this microcode snippet deals with the prefetch queue.
To increase efficiency, the 8086 processor fetches instructions from memory before they are needed and stores them
in a 6-byte prefetch queue.
In most processors, the program counter points to the memory address of the next instruction to execute.
However, in the 8086, the program counter advances during prefetching, so it points to the memory address of the
next instruction to &lt;em&gt;fetch&lt;/em&gt;. 
This discrepancy is invisible to the programmer, but the microcode needs to handle it.&lt;/p&gt;
&lt;p&gt;First, the microcode issues a &lt;code&gt;SUSP&lt;/code&gt; micro-operation to suspend prefetching. This ensures that the program
counter will not be changed due to more prefetching.
Next, the &lt;code&gt;CORR&lt;/code&gt; micro-operation corrects the program counter to point to the next address to execute.
This correction is performed by subtracting the number of unused bytes in the prefetch queue.
You might expect this correction to be performed by the Arithmetic/Logic Unit (ALU).
However, the 8086 has a separate adder that is used for memory address computations:
each memory access in the 8086 requires a segment register base address to be added to an offset address.
This address adder is also used for program counter correction.
The constant ROM holds the values -1 through -6, the appropriate constant is selected based on the
number of bytes in the prefetch queue, and this constant is added to the program counter.
(Interestingly, the address adder is used for program counter correction, while the ALU is used to modify the
program counter for the relative jump computation.)&lt;/p&gt;
&lt;p&gt;The address adder has multiple uses.
It is also used for updating the program counter during prefetching.
It updates addresses when performing block copy operations.
Finally, it updates addresses when performing an unaligned word operation.
The constant ROM holds constants for these operations.&lt;/p&gt;
&lt;p&gt;At the end of the microcode sequence, the &lt;code&gt;FLUSH&lt;/code&gt; micro-operation flushes the stale bytes from the prefetch queue,
resets the prefetch queue pointers, and restarts prefetching.
I wrote about prefetching in detail &lt;a href=&quot;https://www.righto.com/2023/01/inside-8086-processors-instruction.html&quot;&gt;here&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:prefetching&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:signed&quot;&gt;
&lt;p&gt;Often, the compare (CMP) instruction will be executed to compare two numbers by subtracting and discarding the result but keeping the condition codes.
One complication is that some tests make sense for signed numbers, while other tests make sense for unsigned numbers.
Specifically, &quot;greater&quot;, &quot;greater or equal&quot;, &quot;less&quot;, and &quot;less or equal&quot; make sense for signed comparisons.
On the other hand, &quot;above&quot;, &quot;above or equal&quot;, &quot;below&quot;, and &quot;below or equal&quot; make sense for unsigned comparisons.&lt;/p&gt;
&lt;p&gt;The 8086 supports both signed and unsigned numbers. The arithmetic operations are the same for both; it&#39;s just the programmer&#39;s interpretation that differs.
For instance, consider adding hex numbers 0xfe and 0x01. Treating them as unsigned numbers, the sum is 254 + 1 = 255.
But as signed numbers, -2 + 1 = -1. In either case, the processor computes the same result, 0xff, but the interpretation is different.&lt;/p&gt;
&lt;p&gt;The signed vs unsigned distinction matters for comparisons. For instance, as unsigned numbers,
0xfe (254) is above 0x01 (1). But as signed numbers, 0xfe (-2) is less than 0x01 (1).
This is why different instructions are used to compare unsigned versus signed numbers.&lt;/p&gt;
&lt;p&gt;Another important factor is that the carry flag indicates an unsigned result is too large for its byte (or word),
while the overflow flag indicates that a signed result is too large for its byte (or word).
For instance, adding unsigned bytes 0xff (255) and 0x02 (2) yields 0x01 (1) and a carry, indicating the result is too big for a byte.
However, as signed bytes this corresponds to -1 + 2 = 1, which fits in a byte, so the overflow flag is not set.
Conversely, 0x7f + 0x01 = 0x80. As unsigned bytes, this corresponds to 127 + 1 = 128 which is fine.
But as signed bytes, this corresponds to 127 + 1, which unexpectedly yields -128 due to overflow.
Thus, the carry flag is not set, but the overflow flag is set in this case.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:signed&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:conditions&quot;&gt;
&lt;p&gt;Short jumps have four bits to specify the condition, so they can access 16 conditions.
For long jumps and long calls, one bit is &quot;stolen&quot; from the condition to indicate the type, so they can only
access eight of the conditions. Thus, the conditions need to be assigned carefully so the necessary ones are available.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:conditions&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:pla&quot;&gt;
&lt;p&gt;PLAs are typically uniform grids, but the grid pattern breaks down a bit in the condition PLA.
The reason is that each test uses a separate signal, so there is a different signal into each row
(unlike a typical PLA where each row receives the same signals).
Moreover, some of the test signals are processed at the left, distorting the 16-input NOR gate.
This illustrates the degree of layout optimization in the 8086, squeezing transistors in to save a bit of space.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:pla&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/1961567496323199284/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=1961567496323199284' title='11 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/1961567496323199284'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/1961567496323199284'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/01/reverse-engineering-conditional-jump.html' title='Reverse-engineering the conditional jump circuitry in the 8086 processor'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>11</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-7179762780027911658</id><published>2023-01-20T17:11:00.000-08:00</published><updated>2023-03-04T13:59:52.678-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="electronics"/><category scheme="http://www.blogger.com/atom/ns#" term="globus"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><category scheme="http://www.blogger.com/atom/ns#" term="space"/><category scheme="http://www.blogger.com/atom/ns#" term="teardown"/><title type='text'>Inside the Globus INK: a mechanical navigation computer for Soviet spaceflight</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
&lt;/style&gt;

&lt;p&gt;The Soviet space program used completely different controls and instruments from American spacecraft.
One of the most interesting navigation instruments onboard Soyuz spacecraft was the Globus, which used a rotating globe
to indicate the spacecraft&#39;s position above the Earth.
This navigation instrument was an electromechanical analog computer that used an elaborate system of gears, cams, and differentials
to compute the spacecraft&#39;s position.
Officially, the unit was called a &quot;space navigation indicator&quot; with the Russian acronym  (INK),&lt;span id=&quot;fnref:ink&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:ink&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
but I&#39;ll use the more descriptive nickname &quot;Globus&quot;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/globus.jpg&quot;&gt;&lt;img alt=&quot;The INK-2S &amp;quot;Globus&amp;quot; space navigation indicator. Coincidentally, the latitude indicator matches the Ukrainian flag.&quot; class=&quot;hilite&quot; height=&quot;457&quot; src=&quot;https://static.righto.com/images/globus-overview/globus-w600.jpg&quot; title=&quot;The INK-2S &amp;quot;Globus&amp;quot; space navigation indicator. Coincidentally, the latitude indicator matches the Ukrainian flag.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The INK-2S &quot;Globus&quot; space navigation indicator. Coincidentally, the latitude indicator matches the Ukrainian flag.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;We recently received a Globus from a collector and opened it up for repair and reverse engineering. 
In this blog post, I explain how it operated, show its internal mechanisms, and describe what I&#39;ve learned so far from
reverse engineering.
The photo below gives an idea of the mechanical complexity of this device, which also has a few relays, solenoids, and other electrical
components.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/side.jpg&quot;&gt;&lt;img alt=&quot;Side view of the Globus INK. Click this (or any other image) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;662&quot; src=&quot;https://static.righto.com/images/globus-overview/side-w600.jpg&quot; title=&quot;Side view of the Globus INK. Click this (or any other image) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Side view of the Globus INK. Click this (or any other image) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Functionality&lt;/h2&gt;
&lt;p&gt;The primary purpose of the Globus was to indicate the spacecraft&#39;s position. The globe rotated while fixed crosshairs on the
plastic dome 
indicated the spacecraft&#39;s position.
Thus, the globe matched the cosmonauts&#39; view of the Earth, allowing them to confirm their location.
Latitude and longitude dials next to the globe provided a numerical indication of location.
Meanwhile, a light/shadow dial at the bottom showed when the spacecraft would be illuminated by the sun or in shadow,
important information for docking.
The Globus also had an orbit counter, indicating the number of orbits.&lt;/p&gt;
&lt;p&gt;The Globus had a second mode, indicating where the spacecraft would land if they fired the retrorockets to
initiate a landing. Flipping a switch caused the globe to rotate until the landing position was under the crosshairs
and the cosmonauts could evaluate the suitability of this landing site.&lt;/p&gt;
&lt;p&gt;The cosmonauts configured the Globus by turning knobs to set the spacecraft&#39;s initial position and orbital period.
From there, the Globus electromechanically tracked the orbit.
Unlike the Apollo Guidance Computer, the Globus did not receive navigational information from an inertial measurement unit (IMU) or other sources, so it did not know the spacecraft&#39;s real position.
It was purely a display of the predicted position.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/gears.jpg&quot;&gt;&lt;img alt=&quot;A close-up of the complex gear trains in the Globus.&quot; class=&quot;hilite&quot; height=&quot;450&quot; src=&quot;https://static.righto.com/images/globus-overview/gears-w600.jpg&quot; title=&quot;A close-up of the complex gear trains in the Globus.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A close-up of the complex gear trains in the Globus.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The globe&lt;/h2&gt;
&lt;p&gt;The globe itself is detailed for its small size, showing terrain features such as mountains, lakes, and rivers.
These features on the map helped cosmonauts compare their position with the geographic features they could
see on Earth.
These features were also important for selecting a landing site, so they could see what kind of terrain they would
be landing on.
For the most part, the map doesn&#39;t show political boundaries, except for thick red and purple lines.
This line shows the borders of the USSR, as well as the boundaries between communist and non-communist countries,
also important for selecting a landing site.
The globe also has numbered circles 1 through 8 that indicate radio sites for communication with the
spacecraft, allowing the cosmonauts to determine what ground stations could be contacted.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/map.jpg&quot;&gt;&lt;img alt=&quot;A view of the globe showing Asia.&quot; class=&quot;hilite&quot; height=&quot;375&quot; src=&quot;https://static.righto.com/images/globus-overview/map-w500.jpg&quot; title=&quot;A view of the globe showing Asia.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A view of the globe showing Asia.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Controlling the globe&lt;/h2&gt;
&lt;p&gt;On seeing the Globus, one might wonder how the globe is rotated.
It may seem that the globe must be free-floating so it can rotate in two axes.
Instead, a clever mechanism attaches the globe to the unit.
The key is that the globe&#39;s equator is a solid piece of metal that rotates around the horizontal axis of the unit.
A second gear mechanism inside the globe rotates the globe around the North-South axis.
The two rotations are controlled by concentric shafts that are fixed to the unit, allowing two rotational degrees of freedom through fixed shafts.&lt;/p&gt;
&lt;p&gt;The photo below shows the frame that holds and controls the globe.
The dotted axis is fixed horizontally in the unit and rotations are fed through the two gears at the left.
One gear rotates the globe and frame around the dotted axis, while the gear train causes the globe to rotate around the
vertical polar axis (while the equator remains fixed).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/axis.jpg&quot;&gt;&lt;img alt=&quot;The axis of the globe is at 51.8&amp;deg; to support that orbital inclination.&quot; class=&quot;hilite&quot; height=&quot;331&quot; src=&quot;https://static.righto.com/images/globus-overview/axis-w500.jpg&quot; title=&quot;The axis of the globe is at 51.8&amp;deg; to support that orbital inclination.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The axis of the globe is at 51.8&amp;deg; to support that orbital inclination.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The angle above is 51.8&amp;deg; which is very important: this is the inclination of the standard Soyuz orbit.
As a result, simply rotating the globe around the dotted line causes the crosshair to trace the standard orbit.&lt;span id=&quot;fnref:orbit&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:orbit&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
Rotating the two halves of the globe around the poles yields the different 51.8&amp;deg; orbits over the Earth&#39;s surface
as the Earth rotates.
(Why 51.8 degrees? The Baikonur Cosmodrome, launching point for Soyuz, is at 45.97&amp;deg; N latitude, so 45.97&amp;deg; would be
the most efficient inclination.
However, to prevent the launch from passing over western China, the rocket must be angled towards the north,
resulting in 51.8&amp;deg; (&lt;a href=&quot;https://space.stackexchange.com/questions/61553/why-is-51-8-inclination-standard-for-soyuz&quot;&gt;details&lt;/a&gt;).)&lt;/p&gt;
&lt;p&gt;One important consequence of this design is 
that the orbital inclination is fixed by the angle of the globe mechanism. Different Globus units
needed to be built for different orbits.
Moreover, this design only handles circular orbits, making it useless during orbit changes such as rendezvous and docking.
These were such significant limitations that some
cosmonauts wanted the Globus removed from the control panel, but it remained until it was replaced by a computer display in Soyuz-TMA (2002).&lt;span id=&quot;fnref:sirius&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:sirius&quot;&gt;3&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/globe-gears.jpg&quot;&gt;&lt;img alt=&quot;A closeup of the gears that drive the motion of the two halves of the globe around the polar axis, leaving the equator fixed.&quot; class=&quot;hilite&quot; height=&quot;493&quot; src=&quot;https://static.righto.com/images/globus-overview/globe-gears-w400.jpg&quot; title=&quot;A closeup of the gears that drive the motion of the two halves of the globe around the polar axis, leaving the equator fixed.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A closeup of the gears that drive the motion of the two halves of the globe around the polar axis, leaving the equator fixed.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;This Globus had clearly suffered some damage.
The back of the case had some large dents.&lt;span id=&quot;fnref:connector&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:connector&quot;&gt;7&lt;/a&gt;&lt;/span&gt;
More importantly, the globe&#39;s shaft had been knocked loose from its proper position and no longer meshed with the gears.
This also put a gouge into Africa, where the globe hit internal components.
Fortunately, CuriousMarc was able to get the globe back into position while ensuring that the gears had the right timing.
(Putting the globe back arbitrarily would mess up the latitude and longitude.)&lt;/p&gt;
&lt;h2&gt;Orbital speed and the &quot;cone&quot;&lt;/h2&gt;
&lt;p&gt;An orbit of Soyuz takes approximately 90 minutes, but the time varies according to altitude.&lt;span id=&quot;fnref:altitude&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:altitude&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
The Globus has an adjustment knob (below) to adjust
the orbital period in minutes, tenths of minutes, and hundredths of minutes.
The outer knob has three positions and points to the digit that changes when the inner knob is turned.
The mechanism provides an adjustment of 5 minutes from the nominal period of 91.85 minutes.&lt;span id=&quot;fnref2:sirius&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:sirius&quot;&gt;3&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/period-control.jpg&quot;&gt;&lt;img alt=&quot;The control to adjust the orbital period.&quot; class=&quot;hilite&quot; height=&quot;276&quot; src=&quot;https://static.righto.com/images/globus-overview/period-control-w200.jpg&quot; title=&quot;The control to adjust the orbital period.&quot; width=&quot;200&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The control to adjust the orbital period.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The orbital speed feature is implemented by increasing or decreasing the speed at which the globe rotates around the orbital (horizontal)
axis.
Generating a variable speed is tricky, since the Globus runs on fixed 1-hertz pulses.
The solution is to start with a base speed, and then add three increments: one for the minutes setting, one for
the tenths-of-minutes setting, and one for the hundredths-of-minutes setting.&lt;span id=&quot;fnref:hyperbolic&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:hyperbolic&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
These four speeds are added (as shaft rotation speeds) using obtain the overall rotation speed.&lt;/p&gt;
&lt;p&gt;The Globus uses numerous differential gears to add or subtract rotations. The photo below shows two sets of
differential gears, side-by-side.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/differential.jpg&quot;&gt;&lt;img alt=&quot;Two differential gears in the Globus.&quot; class=&quot;hilite&quot; height=&quot;309&quot; src=&quot;https://static.righto.com/images/globus-overview/differential-w600.jpg&quot; title=&quot;Two differential gears in the Globus.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Two differential gears in the Globus.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The problem is how to generate these three variable rotation speeds from the fixed input.
The solution is a special cam, shaped like a cone with a spiral cross-section.
Three followers ride on the cam, so as the cam rotates, the follower is pushed outward and rotates on its shaft.
If the follower is near the narrow part of the cam, it moves over a small distance and has a small rotation.
But if the follower is near the wide part of the cam, it moves a larger distance and has a larger rotation.
Thus, by moving the follower to a particular point on the cam, the rotational speed of the follower is selected.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/cone-diagram.jpg&quot;&gt;&lt;img alt=&quot;A diagram showing the orbital speed control mechanism. The cone has three followers, but only two are visible from this angle. The &amp;quot;transmission&amp;quot; gears are moved in and out by the outer knob to select which follower is adjusted by the inner knob.&quot; class=&quot;hilite&quot; height=&quot;533&quot; src=&quot;https://static.righto.com/images/globus-overview/cone-diagram-w600.jpg&quot; title=&quot;A diagram showing the orbital speed control mechanism. The cone has three followers, but only two are visible from this angle. The &amp;quot;transmission&amp;quot; gears are moved in and out by the outer knob to select which follower is adjusted by the inner knob.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A diagram showing the orbital speed control mechanism. The cone has three followers, but only two are visible from this angle. The &quot;transmission&quot; gears are moved in and out by the outer knob to select which follower is adjusted by the inner knob.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Obviously, the cam can&#39;t spiral out forever.
Instead, at the end of one revolution, its cross-section drops back sharply to the starting diameter.
This causes the follower to snap back to its original position. 
To prevent this from jerking the globe backward, the follower is connected to the differential gearing via a slip clutch and ratchet.
Thus, when the follower snaps back, the ratchet holds the drive shaft stationary.
The drive shaft then continues its rotation as the follower starts cycling out again. 
Thus, the output is a (mostly) smooth rotation at a speed that depends on the position of the follower.&lt;/p&gt;
&lt;h2&gt;Latitude and longitude&lt;/h2&gt;
&lt;p&gt;The indicators at the left and the top of the globe indicate the spacecraft&#39;s latitude and longitude respectively.
These are defined by surprisingly complex functions, generated by the orbit&#39;s projection onto the globe.&lt;span id=&quot;fnref:functions&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:functions&quot;&gt;6&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The latitude and longitude functions are implemented through the shape of metal cams; the photo below shows the
longitude mechanism.
Each function has two cams: one cam implements the desired function, while the other cam
has the &quot;opposite&quot; shape to maintain tension on the jaw-like tracking mechanism.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/cam.jpg&quot;&gt;&lt;img alt=&quot;The cam mechanism to compute longitude.&quot; class=&quot;hilite&quot; height=&quot;332&quot; src=&quot;https://static.righto.com/images/globus-overview/cam-w350.jpg&quot; title=&quot;The cam mechanism to compute longitude.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The cam mechanism to compute longitude.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The latitude cam drives the latitude dial, causing it to oscillate between 51.8&amp;deg; N and 51.8&amp;deg; S.
Longitude is more complicated because the Earth&#39;s rotation causes it to constantly vary.
The longitude output on the dial is produced by adding the cam&#39;s value to the Earth&#39;s rotation through a differential gear.&lt;/p&gt;
&lt;h2&gt;Light and shadow&lt;/h2&gt;
&lt;p&gt;The Globus has an indicator to show when the spacecraft will enter light or shadow.
The dial consists of two concentric dials, configured by the two knobs.
These dials move with the spacecraft&#39;s orbit, while the red legend remains fixed.
I think these dials are geared to the longitude dial, but I&#39;m still investigating.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/light-dark.jpg&quot;&gt;&lt;img alt=&quot;The light and shadow indicator is controlled by two knobs.&quot; class=&quot;hilite&quot; height=&quot;210&quot; src=&quot;https://static.righto.com/images/globus-overview/light-dark-w600.jpg&quot; title=&quot;The light and shadow indicator is controlled by two knobs.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The light and shadow indicator is controlled by two knobs.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The landing location mechanism&lt;/h2&gt;
&lt;p&gt;The Globus can display where the spacecraft would land if you started a re-entry burn now, with an accuracy
of 150 km.
This is computed by projecting the current orbit forward by a partial orbit, depending on how long it would take to land.
The cosmonaut specifies this value by the &quot;landing angle&quot;, which indicates this fraction of an orbit as an angle.
An electroluminescent indicator in the upper-left corner of the unit shows &quot; &quot; (Landing place) to indicate this mode.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/landing-angle.jpg&quot;&gt;&lt;img alt=&quot;The landing angle control.&quot; class=&quot;hilite&quot; height=&quot;146&quot; src=&quot;https://static.righto.com/images/globus-overview/landing-angle-w300.jpg&quot; title=&quot;The landing angle control.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The landing angle control.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;To obtain the landing position, a motor spins the globe until it is stopped after rotating through the specified angle.
The mechanism to implement this is shown below.
The adjustment knob on the panel turns the adjustment shaft which moves the limit
switch to the desired angle via the worm gear. The wiring is wrapped around a wheel so the wiring stays controlled during this movement.
When the drive motor is activated, it rotates the globe and the swing arm at the same time.
Since the motor stops when the swing arm hits the angle limit switch, the globe rotates through the desired angle.
The fixed limit switch is used when returning the globe&#39;s position to its regular, orbital position.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/landing-angle-diagram.jpg&quot;&gt;&lt;img alt=&quot;The landing angle function uses a complex mechanism.&quot; class=&quot;hilite&quot; height=&quot;628&quot; src=&quot;https://static.righto.com/images/globus-overview/landing-angle-diagram-w600.jpg&quot; title=&quot;The landing angle function uses a complex mechanism.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The landing angle function uses a complex mechanism.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The landing location mode is activated by a three-position rotary switch. The first position
&quot;&quot; ( , landing site) selects the landing site, the second position &quot;&quot; (, Earth) shows the position over the Earth, and the third position &quot;&quot; (off) undoes the landing angle rotation and turns off the mechanism.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/rotary-switch.jpg&quot;&gt;&lt;img alt=&quot;The rotary switch to select the landing angle mode.&quot; class=&quot;hilite&quot; height=&quot;222&quot; src=&quot;https://static.righto.com/images/globus-overview/rotary-switch-w250.jpg&quot; title=&quot;The rotary switch to select the landing angle mode.&quot; width=&quot;250&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The rotary switch to select the landing angle mode.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Electronics&lt;/h2&gt;
&lt;p&gt;Although the Globus is mostly mechanical,
it has an electronics board with four relays and a transistor, as well as resistors and diodes.
I think that most of these relays control the landing location mechanism, driving the motor forward or
backward and stopping at the limit switch.
The diodes are &lt;a href=&quot;https://en.wikipedia.org/wiki/Flyback_diode&quot;&gt;flyback diodes&lt;/a&gt;, two diodes in series across
each relay coil to eliminate the inductive kick when the coil is disconnected.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/electronics.jpg&quot;&gt;&lt;img alt=&quot;The electronics circuit board.&quot; class=&quot;hilite&quot; height=&quot;267&quot; src=&quot;https://static.righto.com/images/globus-overview/electronics-w700.jpg&quot; title=&quot;The electronics circuit board.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The electronics circuit board.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;A 360&amp;deg; potentiometer (below) converts the spacecraft&#39;s orbital position into a voltage. Sources indicate that
the Globus provides this voltage signal to other units on the spacecraft.
My theory is that the transistor on the electronics board amplifies this voltage, but I am still investigating.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/rheostat.jpg&quot;&gt;&lt;img alt=&quot;The potentiometer converts the orbital position into a voltage.
To the right is the cam that produces the longitude display. Antarctica is visible on the globe.&quot; class=&quot;hilite&quot; height=&quot;351&quot; src=&quot;https://static.righto.com/images/globus-overview/rheostat-w400.jpg&quot; title=&quot;The potentiometer converts the orbital position into a voltage.
To the right is the cam that produces the longitude display. Antarctica is visible on the globe.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The potentiometer converts the orbital position into a voltage.
To the right is the cam that produces the longitude display. Antarctica is visible on the globe.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The photo below shows the multiple wiring bundles in the Globus, at the front and the left. The electronics board is at the front right.
The Globus contains a surprising amount of wiring for a device that is mostly mechanical.
Inconveniently, all the wires to the box&#39;s external connector (upper left) were cut.&lt;span id=&quot;fnref2:connector&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:connector&quot;&gt;7&lt;/a&gt;&lt;/span&gt;
Perhaps this was part of decommissioning the unit.
However, one of the screws on the case is covered with a tamper-resistant wax seal with insignia, and this
wax seal was intact.
This indicates that the unit was officially re-sealed after cutting the wires, which doesn&#39;t make sense for
a decommissioned unit.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/wiring.jpg&quot;&gt;&lt;img alt=&quot;This view shows the back and underside of the Globus. The round connector at the back left provided the interface with the rest of the spacecraft. The black wires under this connector were all cut.&quot; class=&quot;hilite&quot; height=&quot;523&quot; src=&quot;https://static.righto.com/images/globus-overview/wiring-w700.jpg&quot; title=&quot;This view shows the back and underside of the Globus. The round connector at the back left provided the interface with the rest of the spacecraft. The black wires under this connector were all cut.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This view shows the back and underside of the Globus. The round connector at the back left provided the interface with the rest of the spacecraft. The black wires under this connector were all cut.&lt;/div&gt;&lt;/p&gt;
&lt;h1&gt;The drive solenoids&lt;/h1&gt;
&lt;p&gt;The unit is driven by two ratchet solenoids: one for the orbital rotation and one for the Earth&#39;s rotation.
These solenoids take 27-volt pulses at 1 hertz.&lt;span id=&quot;fnref3:sirius&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:sirius&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
Each pulse causes the solenoid to advance the gear by one tooth; a pawl keeps the gear from slipping back.
These small rotations drive the gears throughout the Globus and result in a tiny movement of the globe.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/solenoid1.jpg&quot;&gt;&lt;img alt=&quot;One of the driving solenoids in the Globus. The wheels to indicate orbital time are underneath.&quot; class=&quot;hilite&quot; height=&quot;255&quot; src=&quot;https://static.righto.com/images/globus-overview/solenoid1-w400.jpg&quot; title=&quot;One of the driving solenoids in the Globus. The wheels to indicate orbital time are underneath.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;One of the driving solenoids in the Globus. The wheels to indicate orbital time are underneath.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/solenoid2.jpg&quot;&gt;&lt;img alt=&quot;The other driving solenoid in the Globus.&quot; class=&quot;hilite&quot; height=&quot;375&quot; src=&quot;https://static.righto.com/images/globus-overview/solenoid2-w400.jpg&quot; title=&quot;The other driving solenoid in the Globus.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The other driving solenoid in the Globus.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Apollo-Soyuz&lt;/h2&gt;
&lt;p&gt;If you look closely at the globe, it has a bunch of pink dots added, along with three-letter labels in Latin (not Cyrillic) characters.&lt;span id=&quot;fnref:sites&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:sites&quot;&gt;8&lt;/a&gt;&lt;/span&gt;
In the photo below, you can see GDS (Goldstone), MIL (Merritt Island), BDA (Bermuda), and NFL (Newfoundland).
These are NASA tracking sites, which implies that this Globus was built for the Apollo-Soyuz Test Project,
a 1975 mission where an Apollo spacecraft docked with a Soyuz capsule.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/north-america.jpg&quot;&gt;&lt;img alt=&quot;North America as it appears on the globe. The US border is marked in red. The selection of cities seems a bit random, such as El Paso as the only western city until the coast.&quot; class=&quot;hilite&quot; height=&quot;477&quot; src=&quot;https://static.righto.com/images/globus-overview/north-america-w600.jpg&quot; title=&quot;North America as it appears on the globe. The US border is marked in red. The selection of cities seems a bit random, such as El Paso as the only western city until the coast.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;North America as it appears on the globe. The US border is marked in red. The selection of cities seems a bit random, such as El Paso as the only western city until the coast.&lt;/div&gt;&lt;/p&gt;
&lt;!-- ASTP flight plan https://www.ibiblio.org/apollo/Documents/56028570-Apollo-Soyuz-July-15-Launch-Final-Flight-Plan.pdf --&gt;

&lt;p&gt;Further confirmation of the Apollo-Soyuz connection is the VAN sticker in the middle of the Pacific Ocean (not visible above).
The &lt;a href=&quot;https://en.wikipedia.org/wiki/USNS_Mission_San_Fernando&quot;&gt;USNS Vanguard&lt;/a&gt; was a NASA tracking ship that was used in the Apollo program to fill in gaps in radio coverage. It was an oil tanker from World War II, converted postwar to a missile
tracking ship and then used for Apollo. In the photo below, you can see the large tracking antennas on its deck.
During the Apollo-Soyuz mission, Vanguard was stationed at &lt;a href=&quot;https://www.angelfire.com/space2/australia/recovery/recovery-astp/astp_cachets.htm&quot;&gt;25 S 155 W&lt;/a&gt; for the Apollo-Soyuz mission, exactly matching
the location of the VAN dot on the globe.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/vanguard.jpg&quot;&gt;&lt;img alt=&quot;The USNS Vanguard with a NASA C-54 plane overhead. (source).&quot; class=&quot;hilite&quot; height=&quot;341&quot; src=&quot;https://static.righto.com/images/globus-overview/vanguard-w600.jpg&quot; title=&quot;The USNS Vanguard with a NASA C-54 plane overhead. (source).&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The USNS Vanguard with a NASA C-54 plane overhead. (&lt;a href=&quot;http://www.navsource.org/archives/09/53/5319.htm&quot;&gt;source&lt;/a&gt;).&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;History&lt;/h2&gt;
&lt;p&gt;The Globus has a long history, back to the beginnings of Soviet crewed spaceflight. The first version was simpler and had the Russian acronym  (IMP).&lt;span id=&quot;fnref:imp&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:imp&quot;&gt;9&lt;/a&gt;&lt;/span&gt;
Development of the IMP started in &lt;a href=&quot;https://web.mit.edu/slava/space/essays/essay-tiapchenko1.htm&quot;&gt;1960&lt;/a&gt; for the Vostok (1961)
and Voshod (1964) spaceflights.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/globus-imp.jpg&quot;&gt;&lt;img alt=&quot;The Globus IMP. Photo from Francoisguay (CC BY-SA 3.0).&quot; class=&quot;hilite&quot; height=&quot;480&quot; src=&quot;https://static.righto.com/images/globus-overview/globus-imp-w500.jpg&quot; title=&quot;The Globus IMP. Photo from Francoisguay (CC BY-SA 3.0).&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Globus IMP. Photo from &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Voskhod_spacecraft_IMP_%27Globus%27_navigation_instrument,_full_view.jpg&quot;&gt;Francoisguay&lt;/a&gt; (&lt;a href=&quot;https://creativecommons.org/licenses/by-sa/3.0/deed.en&quot;&gt;CC BY-SA 3.0&lt;/a&gt;).&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The basic functions of the earlier Globus IMP are similar to the INK, showing the spacecraft&#39;s position and the
landing position.
It has an orbit counter in the lower right. The latitude and longitude displays at the top were added for the Voshod flights.
The large correction knob
allows the orbital period to be adjusted.
The main differences are that the IMP doesn&#39;t have a display at the bottom for sun and shade and
doesn&#39;t have a control to set the landing angle.&lt;span id=&quot;fnref2:imp&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:imp&quot;&gt;9&lt;/a&gt;&lt;/span&gt;
Unlike the INK, the mode (orbit vs landing position) was selected by external switches, rather than a switch on the unit.&lt;/p&gt;
&lt;p&gt;The more complex INK model (described in this blog post) was created for the Soyuz flights, starting in 1967.
It was part of the &quot;Sirius&quot; information display system (IDS).
The Neptun IDS used on Soyuz-T (1976) and the Neptun-M for Soyuz-TM (1986) modernized much of the console but kept the
Globus INK. The photo below shows the Globus mounted in the upper-right of a Soyuz-TM console.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/soyuz-panel.jpg&quot;&gt;&lt;img alt=&quot;The Neptun-M IDS for the Soyuz-TM (source).&quot; class=&quot;hilite&quot; height=&quot;311&quot; src=&quot;https://static.righto.com/images/globus-overview/soyuz-panel-w500.jpg&quot; title=&quot;The Neptun-M IDS for the Soyuz-TM (source).&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Neptun-M IDS for the Soyuz-TM (&lt;a href=&quot;https://web.mit.edu/slava/space/essays/essay-tiapchenko4.htm&quot;&gt;source&lt;/a&gt;).&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The Soyuz-TMA (2002) upgraded to the Neptun-ME system&lt;span id=&quot;fnref4:sirius&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:sirius&quot;&gt;3&lt;/a&gt;&lt;/span&gt; which used digital display screens. In particular, the Globus was replaced with the graphical display below.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/ess-tiap4-15.jpg&quot;&gt;&lt;img alt=&quot;A computer display from the Neptune-ME display system used in the Soyuz-TMA spaceship. The Soyuz consoles are much simpler than the Apollo or Space Shuttle consoles, and built with completely different design principles. From Information Display Systems for Soyuz Spaceships.&quot; class=&quot;hilite&quot; height=&quot;375&quot; src=&quot;https://static.righto.com/images/globus-overview/ess-tiap4-15-w500.jpg&quot; title=&quot;A computer display from the Neptune-ME display system used in the Soyuz-TMA spaceship. The Soyuz consoles are much simpler than the Apollo or Space Shuttle consoles, and built with completely different design principles. From Information Display Systems for Soyuz Spaceships.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A computer display from the Neptune-ME display system used in the Soyuz-TMA spaceship. The Soyuz consoles are much simpler than the Apollo or Space Shuttle consoles, and built with completely different design principles. From &lt;a href=&quot;https://web.mit.edu/slava/space/essays/essay-tiapchenko4.htm&quot;&gt;Information Display Systems for Soyuz Spaceships&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The Globus INK is a remarkable piece of machinery, an analog computer that calculates orbits through an intricate
system of gears, cams, and differentials.
It provided cosmonauts with a high-resolution, full-color display of the spacecraft&#39;s position, way beyond what
an electronic space computer could provide in the 1960s.&lt;/p&gt;
&lt;p&gt;Although the Globus is an amazing piece of mechanical computation, its functionality is limited.
Its parameters must be manually configured: the spacecraft&#39;s starting position, the orbital speed, the light/shadow regions, and the landing angle.
It doesn&#39;t take any external guidance inputs, such as an IMU (inertial measurement unit), so it&#39;s not particularly accurate.
Finally, it only supports a circular orbit at a fixed angle.
While the more modern digital display lacks the physical charm of a rotating globe, the digital solution provides
much more capability.&lt;/p&gt;
&lt;p&gt;I plan to continue reverse-engineering the Globus and hope to get it operational,
so follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.
Many thanks to Marcel for providing the Globus.
Thanks to &lt;a href=&quot;https://space.stackexchange.com/questions/61553/why-is-51-8-inclination-standard-for-soyuz/61554&quot;&gt;Stack Overflow&lt;/a&gt; for orbit information and my Twitter followers for translation assistance.&lt;/p&gt;
&lt;p&gt;I should give a disclaimer that I am still reverse-engineering the Globus, so what I described is subject to change.
Also, I don&#39;t read Russian, so any errors are the fault of Google Translate. :-)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/opened.jpg&quot;&gt;&lt;img alt=&quot;With the case removed, the complex internals of the Globus are visible.&quot; class=&quot;hilite&quot; height=&quot;428&quot; src=&quot;https://static.righto.com/images/globus-overview/opened-w600.jpg&quot; title=&quot;With the case removed, the complex internals of the Globus are visible.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;With the case removed, the complex internals of the Globus are visible.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:ink&quot;&gt;
&lt;p&gt;In Russian, the name for the device is &quot;  &quot; abbreviated as  (INK). This translates to &quot;space navigation indicator.&quot;
The name Globus () seems to be a nickname, and I suspect it&#39;s more commonly used in English than Russian.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:ink&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:orbit&quot;&gt;
&lt;p&gt;To see how the angle between the poles and the globe&#39;s rotation results in the desired orbital inclination, consider two limit cases.
First, suppose the angle between is 90&amp;deg;. In this case, the globe is &quot;straight&quot; with the equator horizontal.
Rotating the globe along the horizontal axis, flipping the poles end-over-end, will cause the crosshair to
trace a polar orbit, giving the expected inclination of 90&amp;deg;.
On the other hand, suppose the angle is 0&amp;deg;. In this case, the globe is &quot;sideways&quot; with the equator vertical.
Rotating the globe will cause the crosshair to remain over the equator, corresponding to an equatorial orbit
with 0&amp;deg; inclination.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:orbit&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:sirius&quot;&gt;
&lt;p&gt;A detailed description of Globus in Russian is in &lt;a href=&quot;https://astronaut.ru/bookcase/article/article152.htm?reload_coolmenus&quot;&gt;this document&lt;/a&gt;, in Section 5.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:sirius&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref2:sirius&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref3:sirius&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref4:sirius&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref5:sirius&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:altitude&quot;&gt;
&lt;p&gt;Or conversely, the altitude varies according to the speed.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:altitude&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:hyperbolic&quot;&gt;
&lt;p&gt;Note that panel control adjusts the period of the orbit, while the implementation adjusts the speed of
the orbit. These are reciprocals, so linear changes in the period result in hyperbolic changes in the speed.
The mechanism, however, changes the speed linearly, which seems like it wouldn&#39;t work.
However, since the period is large relative to the change in the period, this linear approximation works and
the error is small, about 1%.
It&#39;s possible that the cone has a nonlinear shape to correct this, but I couldn&#39;t detect any
nonlinearity in photographs.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:hyperbolic&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:functions&quot;&gt;
&lt;p&gt;The latitude is given by arcsin(sin i * sin (2t/T)),
while the longitude is given by
     = arctan (cos i * tan(2t/T)) + t + &lt;sub&gt;0&lt;/sub&gt;,
    where t is the spaceship&#39;s flight time starting at the equator, i is the angle of inclination (51.8&amp;deg;), T is the orbital period,
     is the angular velocity of the Earth&#39;s rotation, and &lt;sub&gt;0&lt;/sub&gt;
    is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node&quot;&gt;longitude of the ascending node&lt;/a&gt;.&lt;span id=&quot;fnref5:sirius&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:sirius&quot;&gt;3&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The formula for latitude is simpler than longitude because the latitude repeats every orbit. The longitude, however,
continually changes as the Earth rotates under the spacecraft.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:functions&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:connector&quot;&gt;
&lt;p&gt;The back of the Globus has a 32-pin connector, a standard RS32TV Soviet military design.
The case also has some dents visible; the dents were much larger before CuriousMarc smoothed them out.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/globus-overview/back.jpg&quot;&gt;&lt;img alt=&quot;The back of the Globus.&quot; class=&quot;hilite&quot; height=&quot;433&quot; src=&quot;https://static.righto.com/images/globus-overview/back-w600.jpg&quot; title=&quot;The back of the Globus.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The back of the Globus.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- --&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:connector&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref2:connector&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:sites&quot;&gt;
&lt;p&gt;The NASA tracking sites marked with dots are
CYI (Grand Canary Island),
ACN (Ascension),
MAD (Madrid, Spain),
TAN (Tananarive, Madagascar),
GWM (Guam),
ORR (Orroral, Australia),
HAW (Hawaii),
GDS (Goldstone, California),
MIL (Merritt Island, Florida),
QUI (Quito, Ecuador),
AGO (Santiago, Chile),
BDA (Bermuda),
NFL (Newfoundland, Canada),
and VAN (Vanguard tracking ship).
Most of these sites were part of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Spacecraft_Tracking_and_Data_Acquisition_Network&quot;&gt;Spacecraft Tracking and Data Network&lt;/a&gt;.
The numbers 1-7 are apparently USSR communication sites, although I&#39;m puzzled by 8 in Nova Scotia and 9 in Honduras.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:sites&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:imp&quot;&gt;
&lt;p&gt;Details on the earlier Globus IMP are at &lt;a href=&quot;https://vostoksupersite.weebly.com/index.html&quot;&gt;this site&lt;/a&gt;, including
a discussion of the four different versions IMP-1 through IMP-4.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Voskhod_Spacecraft_%22Globus%22_IMP_navigation_instrument&quot;&gt;Wikipedia&lt;/a&gt; also has information.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:imp&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref2:imp&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/7179762780027911658/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=7179762780027911658' title='13 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/7179762780027911658'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/7179762780027911658'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/01/inside-globus-ink-mechanical-navigation.html' title='Inside the Globus INK: a mechanical navigation computer for Soviet spaceflight'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>13</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-823107564209308759</id><published>2023-01-14T10:17:00.005-08:00</published><updated>2023-01-14T11:23:28.072-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="electronics"/><title type='text'>Counting the transistors in the 8086 processor: it&#39;s harder than you might think</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
&lt;/style&gt;

&lt;p&gt;How many transistors are in Intel&#39;s 8086 processor? This seems like a straightforward question, but it doesn&#39;t have a straightforward answer.
Most sources say that this processor has 29,000 transistors.&lt;span id=&quot;fnref:manual&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:manual&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
However, I have traced out every transistor from die photos and my count is 19,618. What accounts for the 9382 missing transistors?&lt;/p&gt;
&lt;p&gt;The explanation is that when manufacturers report the transistor count of chips, typically often report &quot;potential&quot; transistors.
Chips that include a ROM will have different numbers of transistors depending on the values stored in the ROM.
Since marketing doesn&#39;t want to publish varying numbers depending on the number of 1 bits and 0 bits, they often count ROM sites:
places that could have transistors, but might not.
A PLA (Programmable Logic Array) has similar issues; the transistor count depends on the desired logic functions.&lt;/p&gt;
&lt;p&gt;What are these potential transistor sites?
ROMs are typically constructed as a grid of cells, with a transistor at a cell for a 1 bit, and no transistor for a 0 bit.&lt;span id=&quot;fnref:bits&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:bits&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
In the 8086, transistors are created or not through the pattern of silicon doping. 
The photo below shows a closeup of the silicon layer for part of the 8086&#39;s microcode ROM. The empty regions are undoped silicon, while the other regions are doped silicon.
Transistor gates are formed where vertical polysilicon lines (removed for the photo) passed over the doped silicon.
Thus, depending on the data encoded into the ROM during manufacturing, the number of transistors varies.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-transistors/microcode.jpg&quot;&gt;&lt;img alt=&quot;A closeup of part of the microcode ROM. The dark circles indicate vias between the silicon and the metal on top.&quot; class=&quot;hilite&quot; height=&quot;405&quot; src=&quot;https://static.righto.com/images/8086-transistors/microcode-w400.jpg&quot; title=&quot;A closeup of part of the microcode ROM. The dark circles indicate vias between the silicon and the metal on top.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A closeup of part of the microcode ROM. The dark circles indicate vias between the silicon and the metal on top.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The diagram below provides more detail, showing the microcode ROM up close. Green T&#39;s indicate transistors, while red X&#39;s indicate positions with no transistor.
As you can see, the potential transistor positions form a grid, but only some of the positions are occupied by transistors.
The common method for counting transistors counts all the potential positions (18 below) rather than the actual transistors that are implemented (12 below).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-transistors/microcode-labeled2.jpg&quot;&gt;&lt;img alt=&quot;An extreme closeup of the microcode ROM. Green T&#39;s indicate transistors, while red X&#39;s indicate positions with no transistor.&quot; class=&quot;hilite&quot; height=&quot;164&quot; src=&quot;https://static.righto.com/images/8086-transistors/microcode-labeled2-w300.jpg&quot; title=&quot;An extreme closeup of the microcode ROM. Green T&#39;s indicate transistors, while red X&#39;s indicate positions with no transistor.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;An extreme closeup of the microcode ROM. Green T&#39;s indicate transistors, while red X&#39;s indicate positions with no transistor.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;I found &lt;a href=&quot;https://stevemorse.org/8086history/8086history.pdf&quot;&gt;an Intel history&lt;/a&gt; that confirmed that the 8086 transistor count includes potential sites, saying
&quot;This is 29,000 transistors if all ROM and PLA available placement sites are counted.&quot;
That paper gives the approximate number of (physical) transistors in the 8086 as 20,000. This number is close to my count of 19,618.&lt;/p&gt;
&lt;p&gt;To get a transistor count that includes empty sites,
I counted the number of transistor sites in the various ROMs and PLAs in the 8086 chip. This is harder than you might expect because the smaller ROMs, such as the constant ROM,
have some layout optimization.
The photo below shows a closeup of the constant ROM. It is essentially a grid, but has been &quot;squeezed&quot; slightly to optimize its layout, making it slightly irregular.
I&#39;m counting its &quot;potential&quot; transistors, but
one could argue that it shouldn&#39;t be counted because filling in these transistors might run into problems.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-transistors/constants2.jpg&quot;&gt;&lt;img alt=&quot;Closeup of the constant ROM showing the silicon and polysilicon.&quot; class=&quot;hilite&quot; height=&quot;466&quot; src=&quot;https://static.righto.com/images/8086-transistors/constants2-w300.jpg&quot; title=&quot;Closeup of the constant ROM showing the silicon and polysilicon.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Closeup of the constant ROM showing the silicon and polysilicon.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The following table breaks down the ROM and PLA counts by subcomponent.
I found a total of approximately 9659 unfilled transistor vacancies. If you add those to my transistor count, it works out to 29,277 transistors.&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
table#transistors {border: 1px solid #ccc; border-collapse:collapse;}
table#transistors tr th {border-bottom: 1px solid #ccc;}
table#transistors th, table#transistors td {padding: 0 10px; text-align: center;}
&lt;/style&gt;

&lt;table id=&quot;transistors&quot;&gt;
&lt;tr&gt;&lt;th&gt;Component&lt;/th&gt;&lt;th&gt;Transistor sites&lt;/th&gt;&lt;th&gt;Transistors&lt;/th&gt;&lt;th&gt;Vacancies&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Microcode&lt;/td&gt;&lt;td&gt;13904&lt;/td&gt;&lt;td&gt;6210&lt;/td&gt;&lt;td&gt;7694&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Group Decode ROM&lt;/td&gt;&lt;td&gt;1254&lt;/td&gt;&lt;td&gt;603&lt;/td&gt;&lt;td&gt;651&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Translation ROM&lt;/td&gt;&lt;td&gt;1050&lt;/td&gt;&lt;td&gt;431&lt;/td&gt;&lt;td&gt;619&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Register PLAs&lt;/td&gt;&lt;td&gt;465&lt;/td&gt;&lt;td&gt;182&lt;/td&gt;&lt;td&gt;283&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ALU PLA&lt;/td&gt;&lt;td&gt;354&lt;/td&gt;&lt;td&gt;170&lt;/td&gt;&lt;td&gt;184&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Constant ROM&lt;/td&gt;&lt;td&gt;203&lt;/td&gt;&lt;td&gt;109&lt;/td&gt;&lt;td&gt;94&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Condition PLA&lt;/td&gt;&lt;td&gt;160&lt;/td&gt;&lt;td&gt;74&lt;/td&gt;&lt;td&gt;86&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Segment PLA&lt;/td&gt;&lt;td&gt;90&lt;/td&gt;&lt;td&gt;42&lt;/td&gt;&lt;td&gt;48&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;The image below shows these ROMs and PLAs on the die and how much the vacancies increase the transistor count.
Not surprisingly, the large microcode ROM and its decoding PLA are responsible for most of the vacancies.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-transistors/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die with transistor vacancy counts and how much they contribute to the final transistor count. (Click this image or any other for a larger version.)&quot; class=&quot;hilite&quot; height=&quot;687&quot; src=&quot;https://static.righto.com/images/8086-transistors/die-labeled-w700.jpg&quot; title=&quot;The 8086 die with transistor vacancy counts and how much they contribute to the final transistor count. (Click this image or any other for a larger version.)&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die with transistor vacancy counts and how much they contribute to the final transistor count. (Click this image or any other for a larger version.)&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Potential exclusions&lt;/h2&gt;
&lt;p&gt;So are my counts of 19,618 transistors and 29,277 transistor sites correct?
There are some subtleties that could lower this count slightly.
First, the output pins use large, high-current transistors. Each output transistor is constructed from more than a dozen transistors wired in parallel.
Should this be counted as a dozen transistors or a single transistor? I&#39;m counting the component transistors.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-transistors/driver.jpg&quot;&gt;&lt;img alt=&quot;An output pad with a bond wire attached. Driver transistors next to the pad are constructed from multiple transistors in parallel.&quot; class=&quot;hilite&quot; height=&quot;183&quot; src=&quot;https://static.righto.com/images/8086-transistors/driver-w350.jpg&quot; title=&quot;An output pad with a bond wire attached. Driver transistors next to the pad are constructed from multiple transistors in parallel.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;An output pad with a bond wire attached. Driver transistors next to the pad are constructed from multiple transistors in parallel.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The 8086 has about 43 transistors wired as diodes for various purposes. Some are input protection diodes, while others are used in the charge pump for the &lt;a href=&quot;https://www.righto.com/2020/07/inside-8086-processor-tiny-charge-pumps.html&quot;&gt;substrate bias generator&lt;/a&gt;.
Should these be excluded from the transistor count? Physically they are transistors but functionally they aren&#39;t.&lt;/p&gt;
&lt;p&gt;The 8086 is built with NMOS logic which builds gates out of active &quot;enhancement&quot; transistors as well as &quot;depletion&quot; transistors which basically act as pull-up resistors.
I count 2689 depletion-mode transistors, but you could exclude them from the count as not &quot;real&quot; transistors.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The number of transistors in a chip is harder to define than you might expect.
The 8086 is commonly described as having 29,000 transistors when including empty sites in ROMs and PLAs that potentially could have a transistor.
The published number of physical transistors in the 8086 is &quot;approximately 20,000&quot;.
From my counts, the 8086 has 19,618 physical transistors and 29,277 transistors when including empty sites.
Given the potential uncertainties in counting, it&#39;s not surprising that Intel rounded the numbers to the nearest thousand.&lt;/p&gt;
&lt;p&gt;The practice of counting empty transistor sites may seem like an exaggeration of the real transistor count, but there are some good reasons to count this way.
Including empty sites gives a better measure of the size and complexity of the chip, since these sites take up area whether or not they are used.
This number also lets one count the number of transistors before the microcode is written, and it is also stable as the microcode changes.
But when looking at transistor counts, it&#39;s good to know exactly what is getting counted.&lt;/p&gt;
&lt;p&gt;I plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.
I discussed the transistor count in the 6502 processor &lt;a href=&quot;https://www.righto.com/2013/09/intel-x86-documentation-has-more-pages.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:manual&quot;&gt;
&lt;p&gt;For example, &lt;a href=&quot;http://bitsavers.org/components/intel/8086/9800722-03_The_8086_Family_Users_Manual_Oct79.pdf&quot;&gt;The 8086 Family Users Manual&lt;/a&gt; says on page A-210:
&quot;The central processor for the iSBC 86/12 board is
Intel&#39;s 8086, a powerful 16-bit H-MOS device. The
225 sq. mil chip contains 29,000 transistors and has
a clock rate of 5MHz.&quot;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:manual&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:bits&quot;&gt;
&lt;p&gt;ROMs can also be constructed the other way around, with a transistor indicating a 0. It&#39;s essentially an arbitrary decision, depending on whether the output buffer inverts
the bit or not.
Other ROM technologies may have transistors at all the sites but only connect the desired ones.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:bits&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/823107564209308759/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=823107564209308759' title='11 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/823107564209308759'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/823107564209308759'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/01/counting-transistors-in-8086-processor.html' title='Counting the transistors in the 8086 processor: it&#39;s harder than you might think'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>11</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-4620624825163473376</id><published>2023-01-12T10:05:00.004-08:00</published><updated>2023-01-17T18:27:22.601-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="analog"/><category scheme="http://www.blogger.com/atom/ns#" term="electronics"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>Reverse-engineering an airspeed/Mach indicator from 1977</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
&lt;/style&gt;

&lt;p&gt;How does a vintage airspeed indicator work? CuriousMarc picked one up for a project, but it didn&#39;t have any documentation, so I
reverse-engineered it.
This indicator
was used in the cockpit panel for business jets such as the
Gulfstream G-III, Cessna Citation, and Bombardier Challenger CL600.
It was probably manufactured in 1977 based on the dates on its transistors.&lt;/p&gt;
&lt;p&gt;You might expect that the indicators on an aircraft control panel are simple dials.
But behind this dial is a large, 2.8-pound box
with a complex system of motors, gears, and feedback potentiometers, controlled by two boards of electronics.
But for all this complexity, the indicator doesn&#39;t have any smarts: the pointers just indicate voltages fed into it from an air data computer.
This is a quick blog post to summarize what I found.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/mach-meter/front.jpg&quot;&gt;&lt;img alt=&quot;Front view of the indicator.&quot; class=&quot;hilite&quot; height=&quot;293&quot; src=&quot;https://static.righto.com/images/mach-meter/front-w300.jpg&quot; title=&quot;Front view of the indicator.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Front view of the indicator.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The dial has two rotating pointers:
the white pointer indicates airspeed in knots while
the striped pointer indicates the maximum airspeed (which varies depending on altitude).
The &quot;digital&quot; indicator at the top shows Mach number from 0.10 to 0.99, implemented with rotating digit wheels.
When the unit is operating, the OFF indicator flag switches to black. The flag switches to a bright V&lt;sub&gt;MO&lt;/sub&gt; warning if
the pilot exceeds the maximum airspeed.&lt;span id=&quot;fnref:maximum&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:maximum&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
On the rim of the dial, two small markers called &quot;bugs&quot; can be manually moved to indicate critical speeds such as takeoff speed.&lt;/p&gt;
&lt;!--
Challenger CL601: https://www.psilabs.com/airframe_capabilities/airframe%20_capabilities.pdf
Challenger CL600 https://www.aerosales.co.uk/for-sale/light-aircraft/1983-challenger-cl-600-for-sale_i4274
Gulfstream G-III photo https://www.hangar67.com/aircraft/1984-gulfstream-giii/25408?psrc=8591#gallery-8
Cessna Citation https://adsavionics.com/cessna-citation/
--&gt;

&lt;style type=&quot;text/css&quot;&gt;
table#pinout {border: 1px solid #ccc; border-collapse:collapse;}
tr.ul {border-bottom: 1px solid #ccc;}
th, td {padding: 0 10px; text-align: center;}
&lt;/style&gt;

&lt;p&gt;In use, the indicator is connected to a Sperry air data computer and receives voltage signals to control the dial positions.&lt;span id=&quot;fnref:connector&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:connector&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
The air data computer measures the static and dynamic air pressure from pitot tubes and determines the airspeed, Mach number, altitude,
and other parameters. (These calculations become nontrival near Mach 1 as air compresses and the fluid dynamics change.)
Since we didn&#39;t have the air data computer or its specifications, I needed to figure out the connections from the computer to the display.&lt;/p&gt;
&lt;p&gt;With the unit&#39;s cover removed, you can see the internal mechanisms and circuitry.
Each of the three indicators is controlled by a small DC motor with a potentiometer providing feedback.
To the right, two circuit boards provide the electronics to drive the indicators.&lt;span id=&quot;fnref:boards&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:boards&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
At the upper right, the black blob is a 26-volt 400-Hertz transformer to power the unit.
Some power supply components are in front of it.
Below the transformer is an orangish flexible printed-circuit board, which seems advanced for the timeframe.
This flexible ribbon connects the transformer, the external connector, and the printed-circuit board sockets, providing the backplane for the system.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/mach-meter/opened-side.jpg&quot;&gt;&lt;img alt=&quot;A side view of the unit shows the gears to control the indicators.&quot; class=&quot;hilite&quot; height=&quot;291&quot; src=&quot;https://static.righto.com/images/mach-meter/opened-side-w600.jpg&quot; title=&quot;A side view of the unit shows the gears to control the indicators.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A side view of the unit shows the gears to control the indicators.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The diagram below shows the principle behind the servo mechanism that controls each indicator.
The goal is to rotate the indicator to a position corresponding to the input voltage.
A feedback loop is used to achieve this.
The potentiometer provides a voltage proportional to its rotation.
The input voltage and the feedback voltage are inputs to an op amp, which generates an error signal based on the difference between the inputs.
The error signal rotates the DC motor in the appropriate direction until the potentiometer voltage matches
the input voltage. Because the indicator and the potentiometer are geared together, the indicator will be in the correct position.
As the input voltage changes, the system will continuously track the changes and keep the indicator updated.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/mach-meter/servo.jpg&quot;&gt;&lt;img alt=&quot;A diagram illustrating the servo feedback loop.&quot; class=&quot;hilite&quot; height=&quot;195&quot; src=&quot;https://static.righto.com/images/mach-meter/servo-w500.jpg&quot; title=&quot;A diagram illustrating the servo feedback loop.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A diagram illustrating the servo feedback loop.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Because the DC motor spins much faster than the dial moves, reduction gears slow the rotation.
The photo below shows the gear train in the unit. A potentiometer is at the upper-right with three wires attached.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/mach-meter/gears.jpg&quot;&gt;&lt;img alt=&quot;A closeup of the gear train. A potentiometer is on the right.&quot; class=&quot;hilite&quot; height=&quot;232&quot; src=&quot;https://static.righto.com/images/mach-meter/gears-w400.jpg&quot; title=&quot;A closeup of the gear train. A potentiometer is on the right.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A closeup of the gear train. A potentiometer is on the right.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The Mach number has additional gearing to rotate the numbered wheels. When the low-digit wheel cycles around, it advances the high-digit wheel, similar to an odometer.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/mach-meter/numbers.jpg&quot;&gt;&lt;img alt=&quot;The mechanism to rotate the digit wheels for the Mach number.&quot; class=&quot;hilite&quot; height=&quot;188&quot; src=&quot;https://static.righto.com/images/mach-meter/numbers-w400.jpg&quot; title=&quot;The mechanism to rotate the digit wheels for the Mach number.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The mechanism to rotate the digit wheels for the Mach number.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Fault checking&lt;/h2&gt;
&lt;p&gt;One interesting feature of the indicator unit is that it implements fault checking to alert the pilot if something goes wrong.
The front panel has a three-position flag. By default it&#39;s in the OFF position. Powering the coil in one direction rotates the
flag to the blank side. Powering the coil in the other direction rotates the flag to the &quot;V&lt;sub&gt;MO&lt;/sub&gt;&quot; position which indicates that the pilot has
exceeded the maximum operating speed.&lt;/p&gt;
&lt;p&gt;I figured that powering up the unit would move the flag out of the OFF position, but it&#39;s more complicated than that.
First, the unit checks that the air data computer is providing a suitable reference voltage.
Second, the unit verifies that the motor voltages for the two needles are within limits;
this ensures that the servo loop is operating successfully.
Third, the unit checks that signals are received on status pins K and L.
The unit only moves out of the OFF state if all these conditions are satisfied.&lt;span id=&quot;fnref:lpin&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:lpin&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
Thus, if the unit receives bad signals or is malfunctioning, the pilot will be alerted by the OFF indicator, rather than trusting the faulty display.&lt;/p&gt;
&lt;h2&gt;The circuitry&lt;/h2&gt;
&lt;p&gt;The unit is powered by 26 volts, 400 Hz, a standard voltage for aviation.
A small transformer provides multiple outputs for the various internal voltages.
The unit has four power supplies: three on the first board and one on the back wall of the unit.
One power supply is for the status indicator, one is for the op amps, one powers the 41.7V motors, and
the fourth provides other power.&lt;/p&gt;
&lt;p&gt;One subtlety is how the feedback potentiometers are powered.
The servo loop compares the potentiometer voltage with the input voltage.
But this only works if the potentiometer and the input voltage are using the same reference.
One solution would be for the indicator unit and the air data computer to contain matching precision voltage regulators.
Instead, the system uses a simpler, more reliable approach: the air data computer provides a reference voltage that the
indicator unit uses to power the potentiometers.&lt;span id=&quot;fnref:reference&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:reference&quot;&gt;6&lt;/a&gt;&lt;/span&gt;
With this approach, the air data computer&#39;s voltage reference can fluctuate and the indicator will still reach the right position.
(In other words, a 5V input with a 10V reference and a 6V input with a 12V reference are both 50%.)&lt;/p&gt;
&lt;p&gt;The diagram below shows the board with the servo circuitry.
The board uses dual op-amp integrated circuits,
packaged in 10-pin metal cans that protected against interference.&lt;span id=&quot;fnref:ics&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:ics&quot;&gt;7&lt;/a&gt;&lt;/span&gt;
The ICs and some of the other components have obscure military part numbers; I don&#39;t know if this unit was built for military use or if
military-grade parts were used for reliability.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/mach-meter/board2-labeled.jpg&quot;&gt;&lt;img alt=&quot;The servo board is full of transistors, resistors, capacitors, diodes, and op-amp integrated circuits.&quot; class=&quot;hilite&quot; height=&quot;432&quot; src=&quot;https://static.righto.com/images/mach-meter/board2-labeled-w500.jpg&quot; title=&quot;The servo board is full of transistors, resistors, capacitors, diodes, and op-amp integrated circuits.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The servo board is full of transistors, resistors, capacitors, diodes, and op-amp integrated circuits.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The circuitry in the lower-left corner handles the reference voltage from the air data computer.
The board buffers this voltage with an op amp to power the three
feedback potentiometers.
The op amp also ensures that the reference voltage is at least 10 volts. If not, the indicator unit shows the &quot;OFF&quot; flag to alert the pilot.&lt;/p&gt;
&lt;p&gt;The schematic below shows one of the servo circuits; the three circuits are roughly the same.
The heart of the circuit is the error op amp in the center. It compares the voltage from the potentiometer with the input voltage and
generates an error output that moves the motor appropriately.
A positive error output will turn on the upper transistor, driving the motor with a positive voltage.
Conversely, a negative error output will turn on the lower transistor, driving the motor with a negative voltage.
The motor drive circuit has clamp diodes to limit the transistor base voltages.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/mach-meter/servo-schematic.jpg&quot;&gt;&lt;img alt=&quot;Schematic of one of the servo circuits.&quot; class=&quot;hilite&quot; height=&quot;459&quot; src=&quot;https://static.righto.com/images/mach-meter/servo-schematic-w700.jpg&quot; title=&quot;Schematic of one of the servo circuits.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Schematic of one of the servo circuits.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The op amp also receives a feedback signal from the motor output. I don&#39;t entirely understand this signal, which goes through a filter
circuit with resistors, diodes, and a capacitor. I think it dampens the motor signal so the motor doesn&#39;t overshoot the desired position.
I think it also keeps the transistor drive signal biased relative to the emitter voltage (i.e. the motor output).&lt;/p&gt;
&lt;p&gt;On the input side, the potentiometer voltage goes through an op amp follower buffer, which simply outputs its input voltage.
This may seem pointless, but the op amp provides a high-impedance input so the
potentiometer&#39;s voltage doesn&#39;t get distorted.&lt;/p&gt;
&lt;p&gt;The external input voltage goes through a resistor/capacitor circuit to scale it and filter out noise.
Curiously, the circuit board was modified by cutting a trace and adding a resistor and capacitor to change the input circuit for one of the inputs.
In the photo below, you can see the added resistor and capacitor; the cut trace is just to the right of the capacitor.
I don&#39;t know if this modification changed the scale factor or if it filtered out noise.
A label on the box says that Honeywell performed a modification on November 8, 1991, which presumably was this circuit.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/mach-meter/modification.jpg&quot;&gt;&lt;img alt=&quot;A closeup of the circuit board showing the modification.&quot; class=&quot;hilite&quot; height=&quot;276&quot; src=&quot;https://static.righto.com/images/mach-meter/modification-w400.jpg&quot; title=&quot;A closeup of the circuit board showing the modification.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A closeup of the circuit board showing the modification.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The second board implements three power supplies as well as the circuitry for the OFF/V&lt;sub&gt;MO&lt;/sub&gt; flag.
The power supplies are simple and unregulated, just diode bridges to convert AC to DC, along with filter capacitors.
Most of the circuitry on the board controls the status flag.
Two dual op amps check the motor voltages against upper and lower limits to ensure that the motors are tracking the inputs.
These outputs, along with other logic status signals, are combined with diode-transistor logic to determine the flag status.
Driver transistors provide +18 or -18 volts to the flag&#39;s coil to drive it to the desired position.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/mach-meter/board1-labeled.jpg&quot;&gt;&lt;img alt=&quot;This board has power supply circuitry and the control circuitry for the indicator flag.&quot; class=&quot;hilite&quot; height=&quot;557&quot; src=&quot;https://static.righto.com/images/mach-meter/board1-labeled-w500.jpg&quot; title=&quot;This board has power supply circuitry and the control circuitry for the indicator flag.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This board has power supply circuitry and the control circuitry for the indicator flag.&lt;/div&gt;&lt;/p&gt;
&lt;!--
https://aerospace.honeywell.com.cn/content/dam/aerobt/en/documents/learn/products/sensors/brochures/C61-0308-000-001-AirDataComputer-bro.pdf
http://www.privatejettrading.com/aircraft/226/specs.html
https://www.ebay.com/itm/134144499925
https://myduncan.aero/online/parts/list/search/AZ-242
https://opposite-lock.com/topic/7358/flightline-113-c-11a-shuttle-training-aircraft
--&gt;

&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;After reverse-engineering the pinout, I connected the airspeed indicator to a stack of power supplies and succeeded in getting the indicators to operate (&lt;a href=&quot;https://twitter.com/kenshirriff/status/1613605588272807949&quot;&gt;video&lt;/a&gt;).
This unit is much more complex than I expected for a simple display, with servoed motors controlled by two boards of electronics.
Air safety regulations probably account for much of the complexity, ensuring that the display provides the pilot with accurate information.
For all that complexity, the unit is essentially a voltmeter, indicating three voltages on its display.
This airspeed indicator is a bit different from most of the hardware I examine, but hopefully you found this look at its internal circuitry interesting.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/mach-meter/meter-opened.jpg&quot;&gt;&lt;img alt=&quot;With the case removed, the internal circuitry is visible.&quot; class=&quot;hilite&quot; height=&quot;523&quot; src=&quot;https://static.righto.com/images/mach-meter/meter-opened-w350.jpg&quot; title=&quot;With the case removed, the internal circuitry is visible.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;With the case removed, the internal circuitry is visible.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;You can follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;rss&lt;/a&gt;.
I&#39;ve also started experimenting with mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:maximum&quot;&gt;
&lt;p&gt;Since the unit has airspeed and maximum airspeed indicators, you might expect it to display the maximum airspeed warning flag
based on the two speed inputs.
Instead, the flag is controlled by input pin &quot;L&quot;.
In other words, the air data computer, not the indicator unit, determines when the maximum airspeed is exceeded.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:maximum&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:label&quot;&gt;
&lt;p&gt;This unit is a &quot;Mach Airspeed Indicator&quot;, 4018366, apparently also called the SI-225,&lt;span id=&quot;fnref:label&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:label&quot;&gt;2&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/mach-meter/label.jpg&quot;&gt;&lt;img alt=&quot;Product label with part number 4018366-901.&quot; class=&quot;hilite&quot; height=&quot;164&quot; src=&quot;https://static.righto.com/images/mach-meter/label-w500.jpg&quot; title=&quot;Product label with part number 4018366-901.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Product label with part number 4018366-901.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Note that the label says Sperry. 
In 1986, Sperry attempted to buy Honeywell but instead Burroughs made a hostile takeover bid.
The merger of Sperry and Burroughs formed Unisys.
A couple of months after the merger, the Sperry Aerospace Group was sold to Honeywell for $1.025 billion.
Thus, the indicator became a Honeywell product.
This corporate history explains why the unit has a Honeywell product support sticker.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/mach-meter/top-labels.jpg&quot;&gt;&lt;img alt=&quot;Labels on top of the unit indicate that it worked with the Sperry 4013242 and 4013244 air data computers. These became the Honeywell AZ-242 and AZ-244.&quot; class=&quot;hilite&quot; height=&quot;430&quot; src=&quot;https://static.righto.com/images/mach-meter/top-labels-w250.jpg&quot; title=&quot;Labels on top of the unit indicate that it worked with the Sperry 4013242 and 4013244 air data computers. These became the Honeywell AZ-242 and AZ-244.&quot; width=&quot;250&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Labels on top of the unit indicate that it worked with the Sperry 4013242 and 4013244 air data computers. These became the Honeywell AZ-242 and AZ-244.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- --&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:label&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:connector&quot;&gt;
&lt;p&gt;The connector is a 32-pin MIL Spec round connector. Most of the 32 pins are unused.
The connector has complex keying with 5 slots. I assume the keying is specific to this indicator, so
the wrong indicator doesn&#39;t get connected.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/mach-meter/connector.jpg&quot;&gt;&lt;img alt=&quot;A closeup of the 32-pin connector, probably a MIL Spec 18-32.&quot; class=&quot;hilite&quot; height=&quot;316&quot; src=&quot;https://static.righto.com/images/mach-meter/connector-w300.jpg&quot; title=&quot;A closeup of the 32-pin connector, probably a MIL Spec 18-32.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A closeup of the 32-pin connector, probably a MIL Spec 18-32.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;For reference, here is the pinout of the unit. Since this is based on reverse engineering, I don&#39;t guarantee it 100%. Don&#39;t use this for flight!&lt;/p&gt;
&lt;p&gt;&lt;table id=&quot;pinout&quot;&gt;&lt;tr class=&quot;ul&quot;&gt;&lt;th&gt;Pin&lt;/th&gt;&lt;th&gt;Use&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;A&lt;/td&gt;&lt;td&gt;5V illumination&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;B&lt;/td&gt;&lt;td&gt;Chassis ground&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;AC ground&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;E&lt;/td&gt;&lt;td&gt;26V 400 Hz&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;F&lt;/td&gt;&lt;td&gt;26V 400 Hz&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;K&lt;/td&gt;&lt;td&gt;Enable&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;L&lt;/td&gt;&lt;td&gt;Speed ok&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;M&lt;/td&gt;&lt;td&gt;Signal ground&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;N&lt;/td&gt;&lt;td&gt;Ref. voltage &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;P&lt;/td&gt;&lt;td&gt;Vmax control voltage&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;R&lt;/td&gt;&lt;td&gt;Airspeed control voltage&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;S&lt;/td&gt;&lt;td&gt;Mach control voltage&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;V&lt;/td&gt;&lt;td&gt;Chassis ground&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;Pins D, G, H, J, T, U, W, X, Y, Z, a, b, c, d, e, f, g, h, and j are unused.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:connector&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:boards&quot;&gt;
&lt;p&gt;The chassis has an empty slot for a third circuit board. My guess is that this chassis was used for multiple types of indicators and others required a third board.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:boards&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:lpin&quot;&gt;
&lt;p&gt;If the L pin goes low, the indicator will move to the V&lt;sub&gt;MO&lt;/sub&gt; position.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:lpin&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:reference&quot;&gt;
&lt;p&gt;My hypothesis is that the correct reference voltage is 11.7 volts. This yields a scale factor of 1 volt equals 50 knots.
It also matches up the display&#39;s change in scale at 250 knots with the measured scale change.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:reference&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:ics&quot;&gt;
&lt;p&gt;The meter uses three different integrated circuits in 10-pin metal cans with mysterious military markings: &quot;FHL 24988&quot;, &quot;JM38510/10102BIC 27014&quot;,  and &quot;SL14040&quot;.
These appear to all be equivalent to uA747 dual op amps.
(Note that &lt;a href=&quot;http://everyspec.com/MIL-SPECS/MIL-SPECS-MIL-M/MIL-M-38510J_14597/&quot;&gt;JM38510&lt;/a&gt; is not a part number; it is a general military specification for integrated circuits.
The number after it is the relevant part number.)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:ics&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/4620624825163473376/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=4620624825163473376' title='9 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/4620624825163473376'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/4620624825163473376'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/01/reverse-engineering-airspeedmach.html' title='Reverse-engineering an airspeed/Mach indicator from 1977'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>9</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-5308910172987217299</id><published>2023-01-10T10:16:00.004-08:00</published><updated>2023-02-27T18:20:35.583-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="chips"/><category scheme="http://www.blogger.com/atom/ns#" term="microcode"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>The 8086 processor&#39;s microcode pipeline from die analysis</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
  a:link img.hilite, a:visited img.hilite {color: #fff;}
  a:hover img.hilite {color: #f66;}
&lt;/style&gt;

&lt;p&gt;Intel introduced the 8086 microprocessor in 1978, and its influence still remains through the popular x86 architecture.
The 8086 was a fairly complex microprocessor for its time, implementing instructions in microcode with pipelining to improve performance.
This blog post explains the microcode operations for a particular instruction, &quot;ADD immediate&quot;.
As the 8086 documentation will tell you, this instruction takes four clock cycles to execute.
But looking internally shows seven clock cycles of activity.
How does the 8086 fit seven cycles of computation into four cycles? As I will show, the trick is pipelining.&lt;/p&gt;
&lt;p&gt;The die photo below shows the 8086 microprocessor under a microscope.
The metal layer on top of the chip is visible, with the silicon and polysilicon mostly hidden underneath. Around the edges of the die, bond wires connect pads to
the chip&#39;s 40 external pins.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top
and an Execution Unit (EU) below, which will be important in the discussion.
The Bus Interface Unit handles memory accesses (including instruction prefetching), while the Execution Unit executes instructions.
The functional blocks labeled in black are the ones that are part of the discussion below.
In particular, the registers and ALU (Arithmetic/Logic Unit) are at the left and the large microcode ROM is in the lower-right.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-pipeline/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;624&quot; src=&quot;https://static.righto.com/images/8086-pipeline/die-labeled-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Microcode for &quot;ADD&quot;&lt;/h2&gt;
&lt;p&gt;Most people think of machine instructions as the basic steps that a computer performs.
However, many processors (including the 8086) have another layer of software underneath: microcode.
The motivation is that instructions usually require multiple steps inside the processor.
One of the hardest parts of computer design is creating the control logic that directs the processor for each step of an instruction.
The straightforward approach is to build a circuit from flip-flops and gates that moves through the various steps and generates the control signals.
However, this circuitry is complicated, error-prone, and hard to design.&lt;/p&gt;
&lt;p&gt;The alternative is microcode: instead of building the control circuitry from complex logic gates, the control logic is largely replaced with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.
In other words, microcode forms another layer between the machine instructions and the hardware.
The main advantage of microcode is that it turns the processor&#39;s control logic into a programming task instead of a difficult logic design task.&lt;/p&gt;
&lt;p&gt;The 8086 uses a hybrid approach: although the 8086 uses microcode, much of the instruction functionality is implemented with gate logic.
This approach removed duplication from the microcode and kept the microcode small enough for 1978 technology.
In a sense the microcode is parameterized.
For instance, the microcode can specify a generic ALU operation, and the gate logic determines from the instruction which ALU operation to perform.
Likewise, the microcode can specify a generic register and the gate logic determines which register to use.
The simplest instructions (such as prefixes or condition-code operations) don&#39;t use microcode at all.
Although this made the 8086&#39;s gate logic more complicated, the tradeoff was worthwhile.&lt;/p&gt;
&lt;p&gt;The 8086&#39;s microcode was disassembled by Andrew Jenner (&lt;a href=&quot;https://www.reenigne.org/blog/8086-microcode-disassembled/&quot;&gt;link&lt;/a&gt;) from my die photos, so we can see exactly what micro-instructions the 8086 is running for each machine instruction.
In this post, I will focus on the ADD instruction, since it is fairly straightforward.
In particular, the &quot;ADD AX, immediate&quot; instruction contains a 16-bit value that is added to the value in the 16-bit AX register.
This instruction consists of three bytes: the opcode 05, followed by the two-byte immediate value.
(An &quot;immediate&quot; value is included in the instruction, rather than coming from a register or memory location.)&lt;/p&gt;
&lt;p&gt;This ADD instruction is implemented in the 8086&#39;s microcode as four micro-instructions, shown below.
Each micro-instruction specifies a move operation across the internal ALU bus. It also specifies an action. 
In brief, the first two instructions get the immediate argument from the prefetch queue.
The third instruction gets the argument from the AX register and starts the ALU (Arithmetic/Logic Unit) operation.
The final instruction stores the result into the AX register and updates the condition flags.&lt;/p&gt;
&lt;pre&gt;
-address    move        action
   018    Q &amp;rarr; tmpBL     L8    2
   019    Q &amp;rarr; tmpBH
   01a    M &amp;rarr; tmpA      XI    tmpA, NXT
   01b    &amp;Sigma; &amp;rarr; M         RNI   FLAGS
&lt;/pre&gt;

&lt;p&gt;In detail, the first instruction moves a byte from the prefetch queue (&lt;code&gt;Q&lt;/code&gt;) to one of the ALU&#39;s temporary registers, specifically the low byte of the tmpB register.
(The ALU has three temporary registers to hold arguments: tmpA, tmpB, and tmpC.
These temporary registers are invisible to the programmer and are unrelated to the AX, BX, CX registers.)
Likewise, the second instruction fetches the high byte of the immediate value from the queue and stores it in the high byte of the ALU&#39;s tmpB register.
The action in the first micro-instruction, &lt;code&gt;L8&lt;/code&gt;, will branch to step 2 (01a) if the instruction specifies an 8-bit operation, skipping the load of the high byte.
Thus, the same microcode supports the 8-bit and 16-bit ADD instructions.&lt;span id=&quot;fnref:byte&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:byte&quot;&gt;1&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The third micro-instruction is more complicated. The move section moves the AX register&#39;s contents (indicated by &lt;code&gt;M&lt;/code&gt;) to the accumulator&#39;s tmpA register, getting both arguments ready for
the operation. &lt;code&gt;XI tmpA&lt;/code&gt; starts an ALU operation, in this case adding tmpA to tmpB.&lt;span id=&quot;fnref:alu&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:alu&quot;&gt;2&lt;/a&gt;&lt;/span&gt;
Finally, &lt;code&gt;NXT&lt;/code&gt; indicates that this is the next-to-last micro-instruction, as will be discussed below.&lt;/p&gt;
&lt;p&gt;The last micro-instruction stores the ALU&#39;s result (&amp;Sigma;) into the AX register.
The end of the microcode for this machine instruction is indicated by &lt;code&gt;RNI&lt;/code&gt; (Run Next Instruction). Finally, &lt;code&gt;FLAGS&lt;/code&gt; causes the 8086&#39;s condition flags register to be updated,
indicating if the result is zero, negative, and so forth.&lt;/p&gt;
&lt;p&gt;You may have noticed that the microcode doesn&#39;t explicitly specify the ADD operation or the AX register, using &lt;code&gt;XI&lt;/code&gt; and &lt;code&gt;M&lt;/code&gt; instead.
This illustrates the &quot;parameterized&quot; microcode mentioned earlier.
The microcode specifies a generic ALU operation with &lt;code&gt;XI&lt;/code&gt;,&lt;span id=&quot;fnref:xi&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:xi&quot;&gt;3&lt;/a&gt;&lt;/span&gt; and the hardware fills in the particular ALU operation from bits 5-3 of the machine instruction.
Thus, the microcode above can be used for addition, subtraction, exclusive-or, comparisons, and four other arithmetic/logic operations.&lt;/p&gt;
&lt;p&gt;The other parameterized aspect is the generic &lt;code&gt;M&lt;/code&gt; register specification.
The 8086&#39;s instruction set has a flexible way of specifying registers for the source and destination of an operation:
registers are often specified by a &quot;Mod R/M&quot; byte, but can also be specified by bits in the first opcode.
Moreover, many instructions have a bit to switch the source and destination, and another bit to specify an 8-bit or 16-bit register.
The microcode can ignore all this; a micro-instruction uses &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; for the source and destination registers, and the hardware handles the details.&lt;span id=&quot;fnref:mndetails&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:mndetails&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
The M and N values are implemented by 5-bit registers that are invisible to the programmer and specify the &quot;real&quot; register to use. The diagram below shows how they appear on the die.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-pipeline/MNregs.jpg&quot;&gt;&lt;img alt=&quot;Die photo of the circuitry that implements the M and N registers. A multiplexer selects a source for the N register value and feeds it into the 5-bit N register. The M register is similar. Between the two registers is a &amp;quot;swap&amp;quot; circuit to swap the outputs of the two registers based on the instruction&#39;s &amp;quot;direction&amp;quot; bit. In this image, the metal layer has been dissolved with acid to show the transistors in the silicon layer underneath.&quot; class=&quot;hilite&quot; height=&quot;450&quot; src=&quot;https://static.righto.com/images/8086-pipeline/MNregs-w300.jpg&quot; title=&quot;Die photo of the circuitry that implements the M and N registers. A multiplexer selects a source for the N register value and feeds it into the 5-bit N register. The M register is similar. Between the two registers is a &amp;quot;swap&amp;quot; circuit to swap the outputs of the two registers based on the instruction&#39;s &amp;quot;direction&amp;quot; bit. In this image, the metal layer has been dissolved with acid to show the transistors in the silicon layer underneath.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Die photo of the circuitry that implements the M and N registers. A multiplexer selects a source for the N register value and feeds it into the 5-bit N register. The M register is similar. Between the two registers is a &quot;swap&quot; circuit to swap the outputs of the two registers based on the instruction&#39;s &quot;direction&quot; bit. In this image, the metal layer has been dissolved with acid to show the transistors in the silicon layer underneath.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Pipelining&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&quot;http://www.bitsavers.org/components/intel/8086/9800749-1_MCS-86_Assembly_Language_Reference_Guide_Oct78.pdf&quot;&gt;8086 documentation&lt;/a&gt; says this ADD instruction takes four clock cycles, and as we have seen, it is implemented with four micro-instructions.
One micro-instruction is executed per clock cycle, so the timing seems straightforward.
The problem, however, is that a micro-instruction can&#39;t be completed in one clock cycle.
It takes a clock cycle to read a micro-instruction from the microcode ROM.
Sending signals across an internal bus typically takes a clock cycle and other actions take more time.
So a typical micro-instruction ends up taking 2 clock cycles from start to end.
One solution would be to slow down the clock, so the micro-instruction can complete in one cycle, but that would drastically reduce performance.
A better solution is pipelining the execution so a micro-instruction can complete every cycle.&lt;span id=&quot;fnref:superscalar&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:superscalar&quot;&gt;5&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The idea of pipelining is to break instruction processing into &quot;stages&quot;, so different stages can work on different instructions at the same time.
It&#39;s sort of like an assembly line, where a particular car might take an hour to manufacture, but a new car comes off the assembly line every minute.
The diagram below shows a simple example. Suppose executing an instruction requires three steps: A, B, and C.
Executing four instructions, as shown at the top would take 12 steps in total.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-pipeline/pipeline.jpg&quot;&gt;&lt;img alt=&quot;Diagram of a simple pipeline showing four instructions executing through three stages.&quot; class=&quot;hilite&quot; height=&quot;228&quot; src=&quot;https://static.righto.com/images/8086-pipeline/pipeline-w500.jpg&quot; title=&quot;Diagram of a simple pipeline showing four instructions executing through three stages.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Diagram of a simple pipeline showing four instructions executing through three stages.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;However, suppose the steps can execute independently, so step B for one instruction can execute at the same time as step A for another instruction.
Now, as soon as instruction 1 finishes step A and moves on to step B, instruction 2 can start step A.
Next, instruction 3 starts step A as instructions 2 and 1 move to steps B and C respectively.
The first instruction still takes 3 time units to complete, but after that, an instruction completes every time unit, providing a theoretical 3&amp;times; speedup.&lt;span id=&quot;fnref:problems&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:problems&quot;&gt;6&lt;/a&gt;&lt;/span&gt;
In a bit, I will show how the 8086 uses the idea of pipelining.&lt;/p&gt;
&lt;h2&gt;The prefetch queue&lt;/h2&gt;
&lt;p&gt;The 8086 uses instruction prefetching to improve performance.
Prefetching is not the focus of this article, but a brief explanation is necessary. (I wrote about the prefetch circuitry in detail &lt;a href=&quot;https://www.righto.com/2023/01/inside-8086-processors-instruction.html&quot;&gt;earlier&lt;/a&gt;.)
Memory accesses on the 8086 are relatively slow (at least four clock cycles), so we don&#39;t want to wait every time the processor needs a new instruction.
The idea behind prefetching is that the processor fetches future instructions from memory while the CPU is busy with the current instruction.
When the CPU is ready to execute the next instruction, hopefully the instruction is already in the prefetch queue and the CPU doesn&#39;t need to wait for memory.
The 8086 appears to be the first microprocessor to implement prefetching.&lt;/p&gt;
&lt;p&gt;In more detail, the 8086 fetches instructions into its prefetch queue asynchronously from instruction execution: The &quot;Bus Interface Unit&quot; performs prefetches, while
the &quot;Execution Unit&quot; executes instructions.
Prefetched instructions are stored in the 6-byte prefetch queue.
The Q bus (short for &quot;Queue bus&quot;) provides bytes, one at a time, from the prefetch queue to the Execution Unit.&lt;span id=&quot;fnref:prefetch&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:prefetch&quot;&gt;7&lt;/a&gt;&lt;/span&gt;
If the prefetch queue doesn&#39;t have a byte available when the Execution Unit needs one, the Execution Unit
waits until the prefetch circuitry can complete a memory access.&lt;/p&gt;
&lt;h2&gt;The loader&lt;/h2&gt;
&lt;p&gt;To decode and execute an instruction, the Execution Unit must get instruction bytes from the prefetch queue, but this is not entirely straightforward.
The main problem is that the prefetch queue can be empty, blocking execution.
Second, instruction decoding is relatively slow, so for maximum performance, the decoder needs a new byte before the current instruction
is finished.
A circuit called the &quot;loader&quot; solves these problems by 
using a small state machine (below) to efficiently fetch bytes from the queue at the right time.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-pipeline/loader.png&quot;&gt;&lt;img alt=&quot;The state machine for the 8086 &amp;quot;loader&amp;quot; circuit. I&#39;m not going to explain how it works in this post, but the diagram looks pretty cool.
From patent US4449184.&quot; class=&quot;hilite&quot; height=&quot;345&quot; src=&quot;https://static.righto.com/images/8086-pipeline/loader-w400.png&quot; title=&quot;The state machine for the 8086 &amp;quot;loader&amp;quot; circuit. I&#39;m not going to explain how it works in this post, but the diagram looks pretty cool.
From patent US4449184.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The state machine for the 8086 &quot;loader&quot; circuit. I&#39;m not going to explain how it works in this post, but the diagram looks pretty cool.
From &lt;a href=&quot;https://patents.google.com/patent/US4449184A&quot;&gt;patent US4449184&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The loader generates two timing signals that synchronize instruction decoding and microcode execution with the prefetch queue.
The FC (First Clock) indicates that the first instruction byte is available, while the SC (Second Clock) indicates the second
instruction byte.
Note that the First Clock and Second Clock are not necessarily consecutive clock cycles because the first byte could be the last one in the queue,
delaying the Second Clock.&lt;/p&gt;
&lt;p&gt;At the end of a microcode sequence, the Run Next Instruction (&lt;code&gt;RNI&lt;/code&gt;) micro-operation causes the loader to fetch the next machine instruction.
However, microcode execution would be blocked for a cycle due to the delay of fetching and decoding the next instruction.
In many cases, this can be avoided: if the microcode knows that it is one micro-instruction away from finishing,
it issues a Next-to-last (&lt;code&gt;NXT&lt;/code&gt;) micro-operation so the loader can start loading the next instruction before the previous instruction finishes.
As will be shown in the next section,
this usually allows micro-instructions to run without interruption.&lt;/p&gt;
&lt;h2&gt;Instruction execution&lt;/h2&gt;
&lt;p&gt;Putting this all together, we can see how the ADD instruction is executed, cycle by cycle.
Each clock cycle starts with the clock high (H) and ends with the clock low (L).&lt;span id=&quot;fnref:clock&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:clock&quot;&gt;8&lt;/a&gt;&lt;/span&gt;
The sequence starts with the prefetch queue supplying the ADD instruction across the Q bus in cycle 1.
The loader indicates that this is First Clock and the instruction is loaded into the microcode address register.
It takes a clock cycle for the address to exit the address register (as indicated by an arrow) along with the microcode counter value indicating step 0.
To remember the ALU operation, bits 5-3 of the instruction are saved in the internal X register (unrelated to the AX register).&lt;/p&gt;
&lt;p&gt;In cycle 2, the prefetch queue has supplied the second byte of the instruction so the loader indicates Second Clock.
In the second half of cycle 2, the microcode address decoder has converted the instruction-based address to the micro-address 018 and supplies it to the microcode ROM.&lt;/p&gt;
&lt;p&gt;In cycle 3, the microcode ROM outputs the micro-instruction at micro-address 018: &lt;code&gt;QtmpBL&lt;/code&gt;, which will move a byte from the prefetch queue bus (Q bus) to the low byte of the ALU temporary B register, as described earlier.
It takes a full clock cycle for this action to take place, as the byte traverses buses to reach the register.
This micro-instruction also generates the &lt;code&gt;L8&lt;/code&gt; micro-op, which will branch if an 8-bit operation is taking place.
As this is a 16-bit operation, no branch takes place.&lt;span id=&quot;fnref:l8&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:l8&quot;&gt;9&lt;/a&gt;&lt;/span&gt;
Meanwhile, the microcode address register moves to step 1, causing the decoder to produce the micro-address 019.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-pipeline/diagram-labeled2.jpg&quot;&gt;&lt;img alt=&quot;This diagram shows the execution of an ADD instruction and what is happening in various parts of the 8086. The arrows show the flow from step to step. The character  is short for &amp;quot;micro&amp;quot;.&quot; class=&quot;hilite&quot; height=&quot;502&quot; src=&quot;https://static.righto.com/images/8086-pipeline/diagram-labeled2-w800.jpg&quot; title=&quot;This diagram shows the execution of an ADD instruction and what is happening in various parts of the 8086. The arrows show the flow from step to step. The character  is short for &amp;quot;micro&amp;quot;.&quot; width=&quot;800&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;This diagram shows the execution of an ADD instruction and what is happening in various parts of the 8086. The arrows show the flow from step to step. The character  is short for &quot;micro&quot;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;In cycle 4,
the prefetch queue provides a new byte, the high byte of the immediate value.
The microcode ROM outputs the micro-instruction at micro-address 019: &lt;code&gt;QtmpBH&lt;/code&gt;, which will move this byte from the prefetch queue bus to the high byte of the ALU temporary B register.
As before, it takes a full cycle for this move to complete.
Meanwhile, the microcode address register moves to step 2, causing the decoder to produce the micro-address 01a.&lt;/p&gt;
&lt;p&gt;In cycle 5, 
the microcode ROM outputs the micro-instruction at micro-address 01a: &lt;code&gt;MtmpA,XI tmpA,NXT&lt;/code&gt;.
Since the M (source) register specifies AX, the contents of the AX register will be moved into the ALU tmpA register, but this will take a cycle to complete.
The &lt;code&gt;XI tmpA&lt;/code&gt; part starts decoding the ALU operation saved in the X register, in this case ADD.
Finally, &lt;code&gt;NXT&lt;/code&gt; indicates that the next micro-instruction is the last one in this instruction.
In combination with the next instruction on the Q bus, this causes the loader to issue First Clock. This starts execution of the next machine instruction, even though the current instruction is still executing.&lt;/p&gt;
&lt;p&gt;In cycle 6,
the microcode ROM outputs the micro-instruction at micro-address 01b: &lt;code&gt;M,RNI&lt;/code&gt;.
This will store the ALU output into the register indicated by M (i.e. AX), but not yet.
In the first half of cycle 6, the ALU decoder determines the ALU control signals that will cause an ADD to take place.
In the second half of cycle 6, the ALU receives these control signals and computes the sum.
The &lt;code&gt;RNI&lt;/code&gt; (Run Next Instruction) and the second instruction byte from the prefetch queue cause the loader to issue Second Clock, and the micro-address for
the next machine instruction is sent to the microcode ROM.&lt;/p&gt;
&lt;p&gt;Finally, in cycle 7, the sum is written to the AX register and the flags are updated, completing the ADD instruction.
Meanwhile, the next instruction is well underway with its first micro-instruction being executed.&lt;/p&gt;
&lt;p&gt;As you can see, execution of a micro-instruction is pipelined, with three full clock cycles from the arrival of an instruction until the first
micro-instruction completes in cycle 4.
Although this system is complex, in the best case it achieves the goal of running a micro-instruction each cycle, without gaps.
(There are gaps in some cases, most commonly when the prefetch queue is empty.
A gap will also occur if the microcode control flow doesn&#39;t allow a &lt;code&gt;NXT&lt;/code&gt; micro-instruction to be issued.
In that case, the loader can&#39;t issue First Clock until the &lt;code&gt;RNI&lt;/code&gt; micro-instruction is issued, resulting in a delay.)&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The 8086 uses multiple types of pipelining to increase performance. I&#39;ve focused on the pipelining at the microcode level, but the 8086 uses at least four interlocking
types of pipelining.
First, microcode pipelining allows micro-instructions to complete at the rate of one per clock cycle, even though it takes multiple cycles for a micro-instruction to
complete.
Admittedly, this pipeline is not very deep compared to the pipelines in RISC processors; the 8086 designers called the overlap in the microcode ROM a &quot;sort of mini-pipeline.&quot;&lt;span id=&quot;fnref:mckevitt&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:mckevitt&quot;&gt;10&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The second type of pipelining overlaps instruction decoding and execution. Instruction decoding is fairly complicated on the 8086 since there are many different
formats of instructions, usually depending on the second byte (Mod R/M).
The loader coordinates this pipelining, issuing the First Clock and Second Clock signals so decoding on the next instruction can start before the previous instruction has completed.
Third is the prefetch queue, which overlaps fetching instructions from memory with execution.
This is accomplished by partitioning the processor into the Bus Interface Unit and the Execution Unit, with the prefetch queue in between.
(I recently wrote about &lt;a href=&quot;https://www.righto.com/2023/01/inside-8086-processors-instruction.html&quot;&gt;instruction prefetching&lt;/a&gt; in detail.)&lt;/p&gt;
&lt;p&gt;There&#39;s a final type of pipelining that I haven&#39;t discussed. Inside the memory access sequence, computing the memory address from a segment register and offset is overlapped with the previous
memory access. The result is that memory accesses appear to take four cycles, even though they really take six cycles.
I plan to write more about memory access in a later post.&lt;/p&gt;
&lt;p&gt;The 8086 was a large advance in size, performance, and architecture compared to earlier microprocessors such as the Z80 (1976), 8085 (1977), and 6809 (1978). As well as moving to 16 bits, the 8086 had
a considerably more complex architecture with instruction prefetching and microcode, among other features.
At the same time, the 8086 avoided the architectural overreach of Intel&#39;s ill-fated iAPX 432, a complex processor that supported garbage collection and objects in hardware.
Although the 8086&#39;s architecture had flaws, it was a success and led to the x86 architecture, still dominant today.&lt;/p&gt;
&lt;p&gt;I plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.
If you&#39;re interested in the 8086, I wrote about the &lt;a href=&quot;http://www.righto.com/2020/06/a-look-at-die-of-8086-processor.html&quot;&gt;8086 die&lt;/a&gt;, its &lt;a href=&quot;https://www.righto.com/2020/06/die-shrink-how-intel-scaled-down-8086.html&quot;&gt;die shrink process&lt;/a&gt; and the &lt;a href=&quot;http://www.righto.com/2020/07/the-intel-8086-processors-registers.html&quot;&gt;8086 registers&lt;/a&gt; earlier.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:byte&quot;&gt;
&lt;p&gt;The lowest bit of many 8086 instructions selects if the instruction operates on a byte or a word.
Thus, many instructions in the instruction set appear in pairs.
The support for byte operations gave the 16-bit 8086 processor compatibility with the older 8-bit 8080, if assembly code was suitably translated.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:byte&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:alu&quot;&gt;
&lt;p&gt;The microcode for an ALU operation can select the first operand from tmpA, tmpB, or tmpC. The second operand is always tmpB.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:alu&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:xi&quot;&gt;
&lt;p&gt;I don&#39;t know why Intel used XI to indicate the ALU opcode. I don&#39;t think it&#39;s the Greek letter &amp;Xi;, although they did use &amp;Sigma; (sigma) for the ALU output.
The opcode is stored in the X register, so maybe XI is X Instruction?
(It&#39;s also unclear why the register is called X.)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:xi&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:mndetails&quot;&gt;
&lt;p&gt;Normally, the internal M register specifies the source register and the N register specifies the destination register, and these two registers are loaded
from the instruction.
However, some instructions only use the A or AX register, depending on whether the instruction acts on bytes or words.
These instructions are the ALU immediate instructions, accumulator move instructions, string instructions, and the TEST, IN, and OUT instructions.
For these instructions, the Group Decode ROM activates a signal that forces the M register to specify the AX register for a 16-bit operation, or the A
register for an 8-bit operation.
Thus, by specifying the M register in the microcode above, the same microcode is used for instructions with an 8-bit immediate argument or a 16-bit immediate argument.
This also illustrates how the designers of the 8086 kept the microcode small by moving a lot of logic into hardware.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:mndetails&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:superscalar&quot;&gt;
&lt;p&gt;I should mention that the pipelining in the 8086 is completely different from the parallelism in modern superscalar CPUs.
The 8086 is executing instructions linearly, step-by-step, even though instructions overlap.
There is only one execution path and no speculative execution, for instance.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:superscalar&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:problems&quot;&gt;
&lt;p&gt;I showed a theoretical speedup from pipelining. Several issues make the real speedup smaller.
First, the steps of an instruction typically don&#39;t take the same amount of time, so you&#39;re limited by the slowest step.
Second, the overhead to handle the steps adds some delay.
Finally, conflicts between instructions and other &quot;hazards&quot; may prevent overlap in various cases.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:problems&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:prefetch&quot;&gt;
&lt;p&gt;The interaction between the prefetch queue and the Execution Unit is a &quot;push&quot; model rather than a &quot;pull&quot; model.
If the prefetch queue contains a byte, the prefetch circuitry puts the byte on the Q bus and lets the Execution Unit know that a byte is available.
The Execution Unit signals the prefetch circuitry when it uses a byte, and the prefetch queue moves to the next byte in the queue.
If the Execution Unit needs a byte and it isn&#39;t ready, it blocks until a byte is available.
The prefetch queue loads new words as it empties, when the memory bus isn&#39;t in use for other purposes.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:prefetch&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:clock&quot;&gt;
&lt;p&gt;The 8086 is active during both phases (low and high) of the clock, with things happening both while the clock is high and while it is low.
One unusual feature of the 8086 is that the clock signal is asymmetrical with a 33% duty cycle, so the clock is low for twice as long as the clock 
is high. 
In other words, the 8086 does twice as much (by time) during the low part of the clock cycle as during the high part of the clock cycle.
There are multiple reasons why actions take a full clock cycle to complete.
Much of the circuitry uses edge-triggered flip-flops to hold state. These latch data on one clock edge and move data internally during the other part of the clock.
(The 8086 uses both positive-edge and negative-edge triggered flip flops; some latch when the clock goes high and others latch when the clock goes low.)
Many control signals have their voltage level boosted by a &lt;a href=&quot;https://www.righto.com/2022/11/the-unusual-bootstrap-drivers-inside.html&quot;&gt;bootstrap driver&lt;/a&gt; circuit,
driven by the clock.&lt;/p&gt;
&lt;p&gt;Many buses are precharged during one clock phase and then transmit a signal during the other phase.
The motivation behind precharging the bus is that NMOS transistors are much better at pulling a line low than pulling it high (i.e. they can provide more current).
This especially affects buses because they have relatively high capacitance due to their length, so pulling the bus high is slow.
Thus, the bus is &quot;leisurely&quot; precharged to a high state during one clock phase, and then it can be rapidly pulled low (if the bit is a 0) and transmit the
data during the other clock phase.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:clock&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:l8&quot;&gt;
&lt;p&gt;You might expect that the 8-bit ADD would be faster than the 16-bit ADD since it is a 2-byte instruction instead of a 3-byte instruction and one micro-instruction
is skipped.
However, both the 8-bit and the 16-bit ADD instructions take 4 cycles.
The reason is that branching to a new micro-instruction requires updating the microcode address register, which takes a clock cycle, resulting in a wasted
clock cycle where no micro-instruction is executed.
(Specifically, the next micro-instruction is on the way, so it is blocked by the ROM Enable (ROME) signal going low.)
The result of this is that the branch for an 8-bit ADD costs an extra cycle, which cancels out the saved cycle.
(In practice, the 16-bit instruction might be slower because it needs one more byte from the prefetch queue, which could cause a delay.)
Just as a branch in the machine instructions can cause a delay (a &quot;bubble&quot;) in the instruction pipeline, a branch in the microcode causes a delay in the micro-instruction
pipeline.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:l8&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:mckevitt&quot;&gt;
&lt;p&gt;The design decisions for the 8086 are described in: J. McKevitt and J. Bayliss, &quot;New options from big chips,&quot; in IEEE Spectrum, vol. 16, no. 3, pp. 28-34, March 1979, doi: 10.1109/MSPEC.1979.6367944.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:mckevitt&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/5308910172987217299/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=5308910172987217299' title='11 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/5308910172987217299'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/5308910172987217299'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/01/the-8086-processors-microcode-pipeline.html' title='The 8086 processor&#39;s microcode pipeline from die analysis'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>11</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-7884724419474851896</id><published>2023-01-02T09:55:00.004-08:00</published><updated>2023-02-27T18:20:53.107-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="chips"/><category scheme="http://www.blogger.com/atom/ns#" term="microcode"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>Inside the 8086 processor&#39;s instruction prefetch circuitry</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
&lt;/style&gt;

&lt;p&gt;The groundbreaking 8086 microprocessor was introduced by Intel in 1978 and
led to the x86 architecture that still dominates
desktop and server computing.
One way that the 8086 increased performance was by prefetching:
the processor fetches instructions from memory before they are needed,
so the processor can execute them without waiting on the (relatively slow) memory.
I&#39;ve been reverse-engineering the 8086 from die photos and this blog post discusses what I&#39;ve uncovered
about the prefetch circuitry.&lt;/p&gt;
&lt;p&gt;The 8086 was introduced at an interesting point in microprocessor history, where memory was becoming slower than the CPU.
For the first microprocessors, the speed of the CPU and the speed of memory were comparable.&lt;span id=&quot;fnref:memory-speed&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:memory-speed&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
However, as processors became faster, the speed of memory failed to keep up.
The 8086 was probably the first microprocessor to prefetch instructions to improve performance.
While modern microprocessors have megabytes of fast cache&lt;span id=&quot;fnref:cache&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:cache&quot;&gt;2&lt;/a&gt;&lt;/span&gt; to act as a buffer between the CPU and much-slower main memory,
the 8086 has just 6 bytes of prefetch queue. However, this was enough to increase performance by about 50%.&lt;span id=&quot;fnref:mckevitt&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:mckevitt&quot;&gt;3&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The die photo below shows the 8086 microprocessor under a microscope.
The metal layer on top of the chip is visible, with the silicon and polysilicon mostly hidden underneath. Around the edges of the die, bond wires connect pads to
the chip&#39;s 40 external pins.
I&#39;ve labeled the key functional blocks; 
ones that are important to the prefetch queue are highlighted in red and will be discussed in detail below.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top
and an Execution Unit (EU) below.
The BIU handles memory accesses, while the Execution Unit (EU) executes instructions.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-prefetch/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;626&quot; src=&quot;https://static.righto.com/images/8086-prefetch/die-labeled-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Prefetching and the architecture of the 8086&lt;/h2&gt;
&lt;p&gt;Prefetching had a major impact on the design of the 8086.
Earlier processors such as the 6502, 8080, or Z80 were deterministic. 
The processor fetched an instruction, executed the instruction, fetched the next instruction, and so forth.
Memory accesses corresponded directly to instruction fetching and execution and
instructions took a predictable number of clock cycles.
This all changed with the introduction of the prefetch queue.
Memory operations became unlinked from instruction execution since prefetches happen as needed and when the memory bus is available.&lt;/p&gt;
&lt;p&gt;Since memory operations and instruction execution happen independently,
the implementors of the 8086 split the chip into two processing units: the Bus Interface Unit (BIU) that handles memory accesses, and the Execution Unit (EU) that executes instructions,
as shown below.&lt;span id=&quot;fnref:patent&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:patent&quot;&gt;4&lt;/a&gt;&lt;/span&gt;
The Bus Interface Unit contains the 6-byte instruction prefetch queue; it supplies instructions to
the Execution Unit via the Q (queue) bus.
The adder (&amp;Sigma;) performs address calculation, adding the segment register base to an address offset, among other things.
The Execution Unit is what comes to mind when you think of a processor: it has most of the registers, the arithmetic/logic unit (ALU), and the microcode that implements instructions.
The address adder and the ALU are independent arithmetic units.
The segment registers (CS, DS, SS, ES) and the Instruction Pointer (IP) are in the Bus Interface Unit since they are directly involved in memory accesses,
while the general-purpose registers are in the Execution Unit.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-prefetch/8086-block-diagram.jpg&quot;&gt;&lt;img alt=&quot;Block diagram of the 8086 processor.
This diagram differs from most 8086 block diagrams because it shows the actual physical implementation, rather than the programmer&#39;s view of the processor.
The &amp;quot;Internal Communication Registers&amp;quot; consist of the Indirect Register (IND) and the Operand Register (OPR). These hold a memory address and memory data value respectively.
From The 8086 Family User&#39;s Manual.&quot; class=&quot;hilite&quot; height=&quot;602&quot; src=&quot;https://static.righto.com/images/8086-prefetch/8086-block-diagram-w750.jpg&quot; title=&quot;Block diagram of the 8086 processor.
This diagram differs from most 8086 block diagrams because it shows the actual physical implementation, rather than the programmer&#39;s view of the processor.
The &amp;quot;Internal Communication Registers&amp;quot; consist of the Indirect Register (IND) and the Operand Register (OPR). These hold a memory address and memory data value respectively.
From The 8086 Family User&#39;s Manual.&quot; width=&quot;750&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Block diagram of the 8086 processor.
This diagram differs from most 8086 block diagrams because it shows the actual physical implementation, rather than the programmer&#39;s view of the processor.
The &quot;Internal Communication Registers&quot; consist of the Indirect Register (IND) and the Operand Register (OPR). These hold a memory address and memory data value respectively.
From &lt;a href=&quot;http://bitsavers.org/components/intel/8086/9800722-03_The_8086_Family_Users_Manual_Oct79.pdf&quot;&gt;The 8086 Family User&#39;s Manual&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The 8086&#39;s segment registers play an important part in this architecture, so I&#39;ll review them quickly.
One of the challenges of the 8086 was how to support more than 64K of memory with 16-bit registers.
The much-reviled solution was to create a 1-megabyte (20-bit) address space consisting of 64K segments, with segment registers indicating
the start of each segment.
Specifically, a memory address was specified by a 16-bit offset address along with a particular segment register selecting a segment
(Code Segment, Data Segment, Stack Segment, or Extra Segment).
The segment register&#39;s value was shifted by 4 bits to give the segment&#39;s 20-bit base address. The 16-bit offset address was added,
yielding a 20-bit memory address.
This gave the processor a 1-megabyte address space, although only 64K could be accessed without changing a segment register.&lt;/p&gt;
&lt;p&gt;It may seem inefficient for the Bus Interface Unit to have its own adder instead of using the ALU,
but there are a couple of reasons for the separate adder.
First, every memory access uses the adder at least once to add the segment base and offset.
The adder is also used to increment the PC or index registers.
Since these operations are so frequent, they would create a bottleneck if they used the ALU.
Second, since the Execution Unit and the Bus Interface Unit run asynchronously with respect to each other, it would be complicated
to share the ALU without causing delays and conflicts.&lt;/p&gt;
&lt;p&gt;Prefetching had another major but little-known effect on the 8086 architecture: the designers were considering
making the 8086 a two-chip microprocessor.
Prefetching, however, required a one-chip design because the number of control signals required to synchronize prefetching across two chips exceeded the package pins available.
This became a compelling argument for the one-chip design that was used for the 8086.&lt;span id=&quot;fnref2:mckevitt&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:mckevitt&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
(The unsuccessful Intel &lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_iAPX_432&quot;&gt;iAPX 432&lt;/a&gt;, which was under development at the same time, ended up being a two-chip processor: one to fetch and decode instructions, and one to execute them.)&lt;/p&gt;
&lt;h2&gt;Implementing the queue&lt;/h2&gt;
&lt;p&gt;The instruction prefetch queue is implemented with three 16-bit queue registers along with two hardware pointers that keep track
of the current position in the queue.
One two-bit counter keeps track of the current read position from 0 to 3, i.e. the queue register that will provide the next instruction.
The second counter keeps track of the current write position, i.e. the queue register that will receive the next instruction from memory.
As words are fetched from the queue, the read pointer advances. As words are added to the queue, the write pointer advances.
Because the queue registers hold words, while the prefetch circuitry provides bytes, another flip-flop keeps track of
whether the high byte or the low byte of the word is being used. I call this the HL flip-flop.
This causes the low byte to be provided first and then the high byte (since the 8086 is little-endian).&lt;/p&gt;
&lt;p&gt;The diagram below shows an example queue configuration with four bytes. The first two queue registers (Q0 and Q1) hold data.
The read pointer and HL pointer indicate that the next prefetched byte will come from the low byte of Q0.
The write pointer indicates that the next prefetched word will go into Q2.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-prefetch/queue-diagram-1.jpg&quot;&gt;&lt;img alt=&quot;A queue configuration with four bytes in the prefetch queue. Bytes in blue hold prefetched data.&quot; class=&quot;hilite&quot; height=&quot;190&quot; src=&quot;https://static.righto.com/images/8086-prefetch/queue-diagram-1-w300.jpg&quot; title=&quot;A queue configuration with four bytes in the prefetch queue. Bytes in blue hold prefetched data.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A queue configuration with four bytes in the prefetch queue. Bytes in blue hold prefetched data.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The diagram below shows how the queue pointers can wrap around. In this configuration, one byte has been used from Q2 so the next byte will
be Q2&#39;s high byte.
Q0 holds the next prefetched word. The next word to be prefetched will be stored in Q1, as indicated by the write pointer.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-prefetch/queue-diagram-2.jpg&quot;&gt;&lt;img alt=&quot;A queue configuration with three bytes in the prefetch queue.&quot; class=&quot;hilite&quot; height=&quot;186&quot; src=&quot;https://static.righto.com/images/8086-prefetch/queue-diagram-2-w300.jpg&quot; title=&quot;A queue configuration with three bytes in the prefetch queue.&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A queue configuration with three bytes in the prefetch queue.&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;The relative positions of the write and read pointers indicate how much data is in the queue.
If the write pointer is one position before the read pointer (modulo 3), the queue holds 3 or 4 bytes. 
If the write pointer is one position after the read pointer (modulo 3), the queue holds 1 or 2 bytes.
But what about when the read pointer and write pointer indicate the same register?
This can either indicate that the queue is empty or that the queue is full (5 or 6 bytes).
To distinguish these cases, a flip-flop is set
if the queue enters the empty state. This flip-flop generates a signal that Intel called MT (empty).&lt;/p&gt;
&lt;p&gt;Another complication occurs if you jump to an odd address. Because of its 16-bit bus, the 8086 will prefetch a word from the even address one less.
This loads one usable byte and one byte that needs to be discarded.
The 8086 handles this by
setting the HL flip-flop high, using a handful of gates to detect this case. As in the diagram above, the unwanted low byte will be skipped.&lt;/p&gt;
&lt;p&gt;The diagram below zooms in on the prefetch and queue control circuitry on the die, with the main flip-flops and circuitry labeled.
The lower half manages the queue, keeping track of the read and write positions and computing the queue length.
The upper circuitry controls prefetch operations and interacts with the rest of the memory cycle circuitry.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-prefetch/prefetch-die.jpg&quot;&gt;&lt;img alt=&quot;The queue and prefetch circuitry on the die. The metal layer has been removed for the closeup to show the silicon of the underlying transistors.&quot; class=&quot;hilite&quot; height=&quot;641&quot; src=&quot;https://static.righto.com/images/8086-prefetch/prefetch-die-w600.jpg&quot; title=&quot;The queue and prefetch circuitry on the die. The metal layer has been removed for the closeup to show the silicon of the underlying transistors.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The queue and prefetch circuitry on the die. The metal layer has been removed for the closeup to show the silicon of the underlying transistors.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Even though there is not a lot of circuitry involved (about a dozen flip-flops and associated logic gates), this circuitry
occupies a substantial part of the 8086 die.
(The relatively small amount of circuitry did not make this easy to reverse-engineer, however!)
Compared to modern chips, the density of the 8086 is very low; you can almost see the flip-flops with the naked eye.
This diagram only shows the circuitry directly involved in prefetching. Additional circuitry is scattered through the
memory cycle control circuitry to deal with prefetching, and the queue registers take up a substantial part of the register file.
Thus, prefetching was a moderately expensive feature for the 8086, as far as die area.&lt;/p&gt;
&lt;h2&gt;The loader&lt;/h2&gt;
&lt;!--
The 8086 processor is implemented with microcode: most 8086 machine instructions are broken down into simple micro-instructions that are
stored in the microcode ROM.
For example, an ADD instruction is implemented through a sequence of micro-instructions to move the arguments to the Arithmetic/Logic Unit, perform the addition, and store the result.
The multiple addressing modes are implemented in micro-instruction subroutines that access index registers and compute the
memory address.

In 1978 the space available for microcode was limited, so the 8086 designers
moved a lot of control logic outside the microcode, including insruction fetching and decoding.

The relevant part for this discussion is the instruction fetch and decode loop is implemented outside the microcode.
A state machine called the &quot;loader&quot; fetches the first one or two bytes of an instruction. A ROM called the Group Decode ROM
does a &quot;high-level&quot; classification of the instruction.
Simple instructions (such as clearing the carry flag) or prefixes (such as LOCK or selecting a segment register) are performed
directly. More complex instructions are dispatched to the microcode engine, which runs the micro-instructions to carry
out the instruction.
--&gt;

&lt;p&gt;To decode and execute an instruction, the Execution Unit must get instruction bytes from the Bus Interface Unit, but this is not entirely straightforward.
The main problem is that the queue can be empty, in which case instruction decoding must block until a byte is available from
the queue.
The second problem is that instruction decoding is relatively slow, so for maximum performance, the decoder needs a new byte before the current instruction
is finished.
A circuit called the &quot;loader&quot; solves these problems by providing
synchronization between the prefetch queue and the instruction decoder.
The loader uses a small state machine to efficiently fetch bytes from the queue at the right time and to provide timing
signals to the decoder and microcode engine.&lt;/p&gt;
&lt;!--
To explain how instructions are fetched, I&#39;ll first give a brief overview of 8086 instructions.
The 8086 instruction format is fairly complicated, with instructions from one to six bytes long.
The first byte is the opcode, specifying the instruction.
In some cases, this byte completely specifies the instruction, for example PUSH AX to push the AX register to the stack.
Most of the instructions, however, have a second byte that specifies the addressing mode and register: the Mod R/M byte.
Depending on the addressing mode selected, this may be followed by an 8- or 16-bit memory displacement.
Finally, there can be an 8- or 16-bit immediate operand.
--&gt;

&lt;p&gt;In more detail, as the loader requests the first two instruction bytes from the prefetch queue, it generates two timing signals that control the microcode execution.
The FC (First Clock) indicates that the first instruction byte is available, while the SC (Second Clock) indicates the second
instruction byte.
Note that the First Clock and Second Clock are not necessarily consecutive clock cycles because
the prefetch queue could be empty or contain just one byte, in which case the First Clock and/or Second Clock would be
delayed.
The instruction decoding circuitry and the microcode engine are controlled by the First Clock and Second Clock signals, so
they remain synchronized with the bytes supplied by the prefetch queue.&lt;/p&gt;
&lt;p&gt;At the end of a microcode sequence, the Run Next Instruction (RNI) micro-operation causes the loader to fetch the next machine instruction.
However, fetching and decoding the next instruction is a bit slow so microcode execution would be blocked for a cycle.
In many cases, this slowdown can be avoided: if the microcode knows that it is one micro-instruction away from finishing,
it issues a Next-to-last (NXT) micro-operation so the loader can start loading the next instruction.
This achieves a degree of pipelining in most cases; fetching the next instruction is overlapped with finishing the execution
of the previous instruction.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-prefetch/loader.png&quot;&gt;&lt;img alt=&quot;The state machine for the 8086 &amp;quot;loader&amp;quot; circuit.
The 1BL signal indicates a 1-byte instruction implemented in logic rather than microcode.
From patent US4449184.&quot; class=&quot;hilite&quot; height=&quot;345&quot; src=&quot;https://static.righto.com/images/8086-prefetch/loader-w400.png&quot; title=&quot;The state machine for the 8086 &amp;quot;loader&amp;quot; circuit.
The 1BL signal indicates a 1-byte instruction implemented in logic rather than microcode.
From patent US4449184.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The state machine for the 8086 &quot;loader&quot; circuit.
The 1BL signal indicates a 1-byte instruction implemented in logic rather than microcode.
From &lt;a href=&quot;https://patents.google.com/patent/US4449184A&quot;&gt;patent US4449184&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The diagram above shows the state machine for the loader.
I won&#39;t explain it in detail, but essentially it keeps track of whether it is waiting for a First Clock byte or a
Second Clock byte, and if it is performing a fetch in advance (NXT) or at the end of an instruction (RNI).
The state machine is implemented with two flip-flops to support its four states.&lt;/p&gt;
&lt;h2&gt;Other memory accesses&lt;/h2&gt;
&lt;p&gt;The loader takes care of fetching an instruction that consists of an opcode byte and a Mod R/M (addressing mode) byte.
However, many instructions have additional bytes or don&#39;t follow this format
For example, an opcode such as &quot;ADD AX&quot; can be followed by an 8- or 16-bit immediate value, adding that value to the AX register.
Or a &quot;move memory to AX&quot; instruction can be followed by a 16-bit memory address
The microcode uses a separate mechanism for fetching these instruction bytes from the queue.
Specifically, each micro-instruction contains a source register and a destination register that specify a data move.
By specifying &quot;Q&quot; (the queue) as the source, a byte is fetched from the prefetch queue.&lt;/p&gt;
&lt;p&gt;A third path is used for arbitrary memory reads and writes, such as when an instruction stores a register&#39;s contents to memory.
In this case, the microcode puts the memory address in the IND (indirect) register.
The microcode then issues a read or write micro-operation which causes the memory contents to be read into the OPR (operand register) or written from the OPR.
(The IND and OPR registers are internal 8086 registers that are not visible to the programmer.)
In the 8086, a memory cycle takes at least four clock cycles (called T1 through T4), including adding the segment register to compute the memory address.
An &quot;unaligned&quot; memory access takes twice as long, though, because the 8086 has a word-based 16-bit data bus.
Thus, if you try to access a word from an odd address, two memory accesses are required, one for the first byte and one for the second byte.&lt;span id=&quot;fnref:unaligned&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:unaligned&quot;&gt;5&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;As you can see, a memory access is a fairly complex operation.
In the 8086, all these steps are done by hardware in the Bus Interface Unit, rather than being performed by microcode.
(I&#39;ll discuss the complex memory control circuitry in detail in a future post.)
After issuing a memory read or write, the microcode engine is blocked until the memory request completes.&lt;/p&gt;
&lt;h2&gt;Microcode instructions and the correction circuitry&lt;/h2&gt;
&lt;p&gt;The microcode interacts with prefetching in several ways. In addition to requesting a byte from the queue (as discussed above),
microcode can perform three micro-instructions that involve prefetching: SUSP, FLUSH, and CORR.
The SUSP (suspend) micro-instruction stops prefetching, typically before a change to execution flow.
The FLUSH micro-instruction flushes the prefetch queue and resumes prefetching.
To implement these, the prefetching circuitry has a flip-flop to keep track of the suspended state, and logic to reset the queue pointer counters to flush the queue.&lt;/p&gt;
&lt;p&gt;The CORR (correct) micro-instruction corrects the Instruction Pointer to point to the next execution position.
This is an interesting and more complicated micro-instruction.
Like most processors, the 8086 has a program counter (PC) to keep track of what instruction to execute; the 8086 calls this the Instruction Pointer (IP).
In the programmer&#39;s view, the Instruction Pointer points to the memory address of the next instruction to execute.
However, in the hardware, the Instruction Pointer points to the next instruction to be &lt;em&gt;fetched&lt;/em&gt;, which is generally several bytes after the next instruction to be executed.&lt;span id=&quot;fnref:pc&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:pc&quot;&gt;6&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;For the most part, this doesn&#39;t matter; the queue provides instructions in the order they were fetched and it doesn&#39;t matter if the Instruction Pointer runs ahead.
However, there are a few cases where the &quot;real&quot; Instruction Pointer address is needed.
For example, a relative jump instruction causes execution to jump to an address relative to the current instruction.
When performing a subroutine call, the return address must be pushed on the stack.
The correct Instruction Pointer value is also needed for an interrupt.
Thus, the 8086 needs a mechanism to compute the real Instruction Pointer value from the value in the Instruction Pointer register.&lt;/p&gt;
&lt;p&gt;The solution is the CORR micro-instruction, which corrects the Instruction Pointer value by subtracting the prefetch queue length, so the
Instruction Pointer holds the &quot;true&quot; value.
For instance, if there are 4 bytes in the queue, then the address in the Instruction Pointer register is four more than the desired Instruction Pointer address.
The Bus Interface Unit performs this subtraction by using the addressing adder and a small table of constants called the Constant ROM.&lt;span id=&quot;fnref:correction-complications&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:correction-complications&quot;&gt;7&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The diagram below zooms in on the Constant ROM, located next to the adder.
The Constant ROM is implemented as a PLA (programmable logic array), a two-level structured arrangement of gates.
The first level (bottom) selects the desired correction constant, while the second level (middle) generates the bits of the constant: three bits plus a sign bit.
The necessary correction constant is selected based on the length of the queue in words, the HL pointer, and the empty (MT) flag.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-prefetch/constant-die.jpg&quot;&gt;&lt;img alt=&quot;The Constant ROM, highlighted on the die.&quot; class=&quot;hilite&quot; height=&quot;564&quot; src=&quot;https://static.righto.com/images/8086-prefetch/constant-die-w500.jpg&quot; title=&quot;The Constant ROM, highlighted on the die.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Constant ROM, highlighted on the die.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The Constant ROM is used for more than just address correction. For example, it is also used to increment the Instruction Pointer by 2 after a prefetch.
Other constants are used for the 8086&#39;s string operations, which act on a block of memory. The index registers are incremented or decremented by 1 for bytes or 2 for words.
When popping a value from the stack, the stack pointer is decremented, which uses the constant -2.
Additional constants are required to increment and decrement the IND register when accessing words from unaligned (odd) addresses.
These increment/decrement values are selected in the upper part of the Constant ROM.
In total, the Constant ROM holds values from -6 to +2.&lt;/p&gt;
&lt;h2&gt;Policy&lt;/h2&gt;
&lt;p&gt;There are some &quot;policy&quot; decisions on prefetching, and it&#39;s interesting to see how the 8086 implements them.
Prefetching is not free:
there is a tradeoff when performing a prefetch between saving time later versus delaying memory accesses from an executing instruction.
Moreover, if a jump operation takes place, the prefetch queue is discarded and the memory cycles were wasted.
Thus, the length of the queue is an &quot;extremely tricky design problem, because performance can deteriorate if the queue is too long as well as if it is too short.&quot;&lt;span id=&quot;fnref3:mckevitt&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:mckevitt&quot;&gt;3&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Intel performed simulations to determine the best queue length. A 4-byte queue provided a large benefit, while a 6-byte
queue (which they chose) was slightly better.
The designers were surprised to find that performance flattened out after that; they expected a much longer queue would be necessary.
The 8088 process has only a 4-byte prefetch queue because its 8-bit bus changes the tradeoffs.&lt;span id=&quot;fnref:8088&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:8088&quot;&gt;8&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The basic prefetch policy is that if a memory access and a prefetch are requested at the same time, the memory access &quot;wins&quot;, since it is guaranteed to be useful while the prefetch is just speculative.
If the queue holds 0 to 2 bytes, prefetch happens during the next free memory cycle.
If the queue holds 5 or 6 bytes, no prefetch can happen, since prefetch happens a word at a time.
However, if the queue holds 3 or 4 bytes, prefetch is delayed for two clock cycles, which is an interesting choice.
This gives an instruction more opportunities to perform a memory operation without being delayed by a prefetch.
There is a tradeoff because maybe delaying the prefetch will waste two cycles of memory bandwidth, but performing the prefetch might waste four cycles of memory bandwidth.
The motivation for this delay is that the last two bytes in the queue are less valuable because they are more likely to be discarded.&lt;/p&gt;
&lt;p&gt;Another policy decision is how to handle a change in execution flow, such as a jump or subroutine call.
The 8086 simply discards the prefetch queue and starts fetching from the new address.
The 8086 designers considered better ways of handling jumps, but it wasn&#39;t practical to implement at the time.
There is no intelligence if the instructions are already in the queue (e.g. jumping forward a couple of bytes).
There is also no branch prediction; prefetching proceeds linearly regardless of branch instructions.&lt;/p&gt;
&lt;p&gt;The 8086 does nothing to ensure consistency between the prefetch queue and memory if a prefetched instruction
is modified in memory.&lt;span id=&quot;fnref:consistency&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:consistency&quot;&gt;9&lt;/a&gt;&lt;/span&gt;
In this case, the &quot;stale&quot; instruction in the queue is executed.
This situation may seem contrived, but self-modifying code used to be fairly popular, where a program would change its own instructions.&lt;span id=&quot;fnref:self-modifying&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:self-modifying&quot;&gt;10&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Prefetching and the 8087 coprocessor&lt;/h2&gt;
&lt;p&gt;One feature of the 8086 microprocessor is that it supports coprocessors such as the 8087 floating point chip.&lt;span id=&quot;fnref:coprocessors&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:coprocessors&quot;&gt;11&lt;/a&gt;&lt;/span&gt;
The 8087 implements high-performance floating-point computation, performing arithmetic and transcendental computations up to
100 times faster than the 8086.
The 8087 gets instructions in an interesting fashion, executing floating-point instructions from the 8086&#39;s instruction stream.
Specifically, an &quot;ESCAPE&quot; opcode indicates an instruction that is performed by the 8087 rather than the 8086.
However, prefetching adds a lot of complexity to the coprocessor because
the 8087 monitors the bus to determine when it should execute an instruction.
With prefetching, the instruction on the bus doesn&#39;t match the instruction being executed.
An instruction may be executed many cycles after it was fetched over the bus.
A prefetched instruction may even be discarded and never executed.&lt;/p&gt;
&lt;p&gt;To solve this problem, the 8087 manages its own copy of the prefetch queue to determine when the
8086 would be executing a floating-point instruction.
The 8087 watches the bus to see when instructions are prefetched.
The 8086 provides queue status signals (QS0 and QS1) to indicate when it takes bytes from the queue or flushes the queue.
These signals allow the 8087 coprocessor to keep track of the 8086&#39;s queue state so it can tell what instruction the 8086
is executing.
In other words, the 8086 doesn&#39;t tell the 8087 coprocessor what to do; instead, the two chips process the instruction stream in parallel.
Another complication is the 8087 coprocessor can be used with the 8088 processor chip, which has a smaller 4-byte queue.
Thus, the 8087 coprocessor must detect
whether it is connected to an 8086 or an 8088 and maintain its queue appropriately.&lt;/p&gt;
&lt;h2&gt;Brief history&lt;/h2&gt;
&lt;p&gt;Caching and prefetching were used in mainframe computers dating back to the 1960s. 
For instance, the IBM System/360 Model 91 (1966) had a cache with prefetching.
Minicomputers such as the VAX 11/780 (1977) later used caching and prefetching.
However, these features took a while to trickle down to microprocessors.
The Motorola 68000 (1980) had a &lt;a href=&quot;http://pasti.fxatari.com/68kdocs/68kPrefetch.html&quot;&gt;4-byte prefetch queue&lt;/a&gt;.
As far as I can tell, the 8086 was the first microprocessor with a prefetch queue.&lt;/p&gt;
&lt;p&gt;We can view the 8086 as a stepping-stone towards the large caches first used externally in the 80386 and internally in the 486.
The 80186 and 80286 kept the 6-byte prefetch buffer size of the 8086. 
The 80386 has a 16-byte prefetch buffer, although apparently &lt;a href=&quot;http://www.rcollins.org/secrets/PrefetchQueue.html&quot;&gt;due to a bug&lt;/a&gt; it was shrunk to 12 bytes in later revisions.
As well as the prefetch queue, the 80386 supported an external cache.&lt;/p&gt;
&lt;!-- http://www.bitsavers.org/components/intel/80286/210760-002_80286_Hardware_Reference_Manual_1987.pdf --&gt;
&lt;!-- http://www.bitsavers.org/components/intel/80386/231746-001_Introduction_to_the_80386_Apr86.pdf --&gt;

&lt;p&gt;Early microprocessors such as the 6502 or Z80 could fetch the next instruction while they were finishing the previous instruction.
This minimal two-stage pipelining improved performance, but was much more limited than 8086-style prefetching.
An Intel study found that this simple overlap provides a 35% performance increase with 15% more hardware, while implementing prefetching provided an additional 11% gain with 14% more hardware.&lt;span id=&quot;fnref4:mckevitt&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:mckevitt&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
This illustrates how the increasing transistor counts from Moore&#39;s law opened up new opportunities to improve performance.
But it also shows diminishing returns as performance increases become smaller and more expensive.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Well, this was supposed to be a quick post about the prefetch queue, but the topic turned out to have a lot more complexity than I
expected.
A six-byte prefetch queue may seem like a simple feature to add to a processor, but it affects many parts of the system.
Prefetching is tied closely to the memory access circuitry, of course, but it also required a Constant ROM to handle the difference
between the execution address and the prefetch address. Prefetching also impacted the microcode, with three micro-instructions to support prefetching.&lt;/p&gt;
&lt;p&gt;Prefetching also illustrates some of the ways that each feature and corner case of a processor like the 8086 leads to more complexity.
For instance, byte-aligned (rather than word-aligned) instructions require a mechanism to fetch bytes as well as words.
Supporting multiple instruction formats (1-byte opcodes, an opcode byte followed by a Mod R/M byte, multi-byte instructions) resulted in the loader
state machine.
The segment registers required an adder to compute the memory address for every access.
Looking at the 8086 internals makes it easier to understand the motivation behind RISC processors, discarding the complexity and corner cases to create
a simpler but faster processor.&lt;/p&gt;
&lt;p&gt;I plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@oldbytes.space@kenshirriff&lt;/a&gt;.
If you&#39;re interested in the 8086, I wrote about the &lt;a href=&quot;http://www.righto.com/2020/06/a-look-at-die-of-8086-processor.html&quot;&gt;8086 die&lt;/a&gt;, its &lt;a href=&quot;https://www.righto.com/2020/06/die-shrink-how-intel-scaled-down-8086.html&quot;&gt;die shrink process&lt;/a&gt; and the &lt;a href=&quot;http://www.righto.com/2020/07/the-intel-8086-processors-registers.html&quot;&gt;8086 registers&lt;/a&gt; earlier.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:memory-speed&quot;&gt;
&lt;p&gt;Steve Furber, co-creator of the ARM chip, mentions that &quot;The first integrated CPUs were coincidentally quite well matched to semiconductor memory speeds, and were therefore built without caches. This can now be seen as a temporary aberration.&quot;
See &lt;a href=&quot;https://amzn.to/3hIasOL&quot;&gt;VLSI Risc Architecture and Organization&lt;/a&gt; p77.
To make this concrete, the Apple II (1977) used a MOS 6502 processor running at about 1 megahertz
while its 4116 DRAM chips could perform an access in 250 nanoseconds (4 times the clock speed).
The 8086 processor ran at 5-10 MHz which meant that 250 ns DRAM chips were slower than the clock speed.
Nowadays, processors run at 4 GHz but DRAM access speed is about 50 nanoseconds (1/200 the clock speed).&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:memory-speed&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:cache&quot;&gt;
&lt;p&gt;Modern processors use caches to improve memory performance; caches are often megabytes in size.
Accessing data from a cache is faster than accessing it from main memory, but the tradeoff is that caches are smaller.
The 8086&#39;s prefetch queue is similar to a cache in some ways, but there are some key differences.
First, the prefetch queue is strictly sequential. If you jump ahead two bytes, even if the prefetch queue has those instruction bytes, the processor can&#39;t use them.
Second, the prefetch queue can&#39;t reuse bytes. If you have a 6-byte loop, even though all the code fits in the prefetch queue, it will be reloaded every time.
Third, the prefetch queue doesn&#39;t provide any consistency. If you modify an instruction in memory a couple of bytes ahead of the PC, the 8086 will run the old instruction if it&#39;s in the queue.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:cache&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:mckevitt&quot;&gt;
&lt;p&gt;The design decisions for the 8086 prefetch cache (and many other aspects of the chip) are described in: J. McKevitt and J. Bayliss, &quot;New options from big chips,&quot; in IEEE Spectrum, vol. 16, no. 3, pp. 28-34, March 1979, doi: 10.1109/MSPEC.1979.6367944.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:mckevitt&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref2:mckevitt&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref3:mckevitt&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref4:mckevitt&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:patent&quot;&gt;
&lt;p&gt;A detailed block diagram of the 8086 is provided in the patent.
Conveniently, the layout of the diagram is close to the physical layout of the chip.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-prefetch/patent-diagram2.jpg&quot;&gt;&lt;img alt=&quot;Detailed block diagram of the 8086, based on patent US4449184. I have modified the register names to match the common naming.&quot; class=&quot;hilite&quot; height=&quot;1033&quot; src=&quot;https://static.righto.com/images/8086-prefetch/patent-diagram2-w800.jpg&quot; title=&quot;Detailed block diagram of the 8086, based on patent US4449184. I have modified the register names to match the common naming.&quot; width=&quot;800&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Detailed block diagram of the 8086, based on &lt;a href=&quot;https://patents.google.com/patent/US4449184A&quot;&gt;patent US4449184&lt;/a&gt;. I have modified the register names to match the common naming.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;I won&#39;t discuss this block diagram in detail here, but I&#39;ll point out the Q (queue) control logic in the upper center,
with its associated read and write pointers. The Q bus connects the queue to various parts of the instruction decoding
circuitry.&lt;/p&gt;
&lt;p&gt;&lt;!-- --&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:patent&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:unaligned&quot;&gt;
&lt;p&gt;Supporting misaligned memory accesses (i.e. accessing a word at an odd address) adds complexity to the 8086.
It&#39;s not surprising that many RISC chips prohibit unaligned accesses.
On SPARC, for instance, an unaligned access fails with a &quot;bus error&quot;, which the Sun programmers out there probably recognize.
ARM processors before ARMv7 didn&#39;t support unaligned accesses.
RISC-V supports misaligned data accesses but not misaligned instructions.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:unaligned&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:pc&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;https://patents.google.com/patent/US4449184A&quot;&gt;8086 patent&lt;/a&gt; describes how the program counter in the 8086 does not hold the &quot;real&quot; value:&lt;/p&gt;
&lt;p&gt;&lt;blockquote&gt;
PC is not a real or true program counter in that it does not, nor does any other register within CPU, maintain the actual execution point at any time. PC actually points to the next byte to be input into queue. The real program counter is calculated by instruction whenever a relative jump or call is required by subtracting the number of accessed instructions still remaining unused in queue from PC.
&lt;/blockquote&gt;&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:pc&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:correction-complications&quot;&gt;
&lt;p&gt;The CORR correction operation adds more complexity to the system than you might expect, with synchronization between the Bus Interface
Unit and the Execution Unit.
Because the correction computation uses the addressing adder, the correction operation must be synchronized with memory
accesses that also use the adder.
To accomplish this, the Bus Interface Unit waits until any memory operation is finished and then
generates two clock cycles of &quot;fake&quot; memory operation, keeping the adder free for the CORR instruction.
As a result, the memory control circuitry needs logic to implement this memory cycle.
Meanwhile, the microcode engine is stopped until the CORR instruction completes, requiring synchronization circuitry.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:correction-complications&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:8088&quot;&gt;
&lt;p&gt;The 8088 is famous as the processor in the original IBM PC.
The 8088 processor is essentially the same as the 8086 except that it has an 8-bit data bus instead of a 16-bit data bus,
so it performs memory accesses a byte at a time instead of a word at a time.
Internally, the 8088 is nearly identical to the 8086 but there are a few differences in microcode and in the bus circuitry.
The most visible difference is that the 8088 has a 4-byte prefetch queue instead of a 6-byte prefetch queue.
Simulations showed that a 4-byte queue was sufficient for the 8088.
Because it fetches one byte at a time instead of two bytes, the 8088 fills the prefetch queue more slowly and wouldn&#39;t
get much benefit from the larger queue.
I haven&#39;t looked at the 8088&#39;s prefetch circuitry in detail, so I can&#39;t describe it exactly.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:8088&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:consistency&quot;&gt;
&lt;p&gt;At some point, Intel implemented consistency between cached instructions and memory.
This ensures that self-modifying code will run the latest version of an instruction rather than a stale instruction in the cache.
I couldn&#39;t determine exactly when this was implemented; various sources say the &lt;a href=&quot;https://news.ycombinator.com/item?id=29573673&quot;&gt;486&lt;/a&gt;, the &lt;a href=&quot;http://donaldkenney.x10.mx/GLOSSARY/PREFETCH.HTM&quot;&gt;Pentium&lt;/a&gt;, or the &lt;a href=&quot;https://news.ycombinator.com/item?id=33948275&quot;&gt;Pentium Pro&lt;/a&gt;.
(If you have a definitive answer, please let me know.)&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:consistency&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:self-modifying&quot;&gt;
&lt;p&gt;Self-modifying code can be used as a way to &lt;a href=&quot;https://www.drdobbs.com/embedded-systems/processor-detection-schemes/184409011&quot;&gt;distinguish&lt;/a&gt; between the 8086 and 8088 chips in software.
Since the 8086 has a 6-byte queue and the 8088 has a 4-byte queue, you can create self-modifying code that will run a prefetched instruction on the 8086 but run the modified instruction on the 8088.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:self-modifying&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:coprocessors&quot;&gt;
&lt;p&gt;Although the 8087 is the most well-known coprocessor for the 8086, it was not the only coprocessor.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_8089&quot;&gt;Intel 8089&lt;/a&gt; input/output coprocessor
provided mainframe-style I/O channels, offloading I/O processing from the 8086.
More than just a DMA engine, the 8089 was a separate processor with its own &lt;a href=&quot;https://www.elinfor.com/pdf//8089_Intel.pdf&quot;&gt;instruction set&lt;/a&gt;.
Unlike the 8087, the 8089 didn&#39;t take instructions from the 8086&#39;s instruction stream so it didn&#39;t interact with prefetching;
instead, the 8086 sent a Channel Attention signal to the 8089 and the 8089 read instructions from shared memory.
The 8089 was complex and expensive and wasn&#39;t very popular.
The &lt;a href=&quot;http://www.bitsavers.org/components/intel/ethernet/i82586.pdf&quot;&gt;Intel 82586&lt;/a&gt; Ethernet coprocessor used a similar Channel Attention scheme.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:coprocessors&quot; title=&quot;Jump back to footnote 11 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/7884724419474851896/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=7884724419474851896' title='7 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/7884724419474851896'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/7884724419474851896'/><link rel='alternate' type='text/html' href='http://www.righto.com/2023/01/inside-8086-processors-instruction.html' title='Inside the 8086 processor&#39;s instruction prefetch circuitry'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>7</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6264947694886887540.post-3555662096871568632</id><published>2022-11-28T23:08:00.010-08:00</published><updated>2022-12-06T11:28:01.124-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="8086"/><category scheme="http://www.blogger.com/atom/ns#" term="chips"/><category scheme="http://www.blogger.com/atom/ns#" term="electronics"/><category scheme="http://www.blogger.com/atom/ns#" term="intel"/><category scheme="http://www.blogger.com/atom/ns#" term="reverse-engineering"/><title type='text'>How the 8086 processor&#39;s microcode engine works</title><content type='html'>&lt;style&gt;
  .hilite {cursor:zoom-in}
&lt;/style&gt;

&lt;p&gt;The 8086 microprocessor was a groundbreaking processor introduced by Intel in 1978.
It led to the x86 architecture that still dominates
desktop and server computing.
The 8086 chip uses microcode internally to implement its instruction set.
I&#39;ve been reverse-engineering the 8086 from die photos and this blog post discusses how the chip&#39;s microcode engine operated.
I&#39;m not going to discuss the contents of the microcode&lt;span id=&quot;fnref:reenigne&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:reenigne&quot;&gt;1&lt;/a&gt;&lt;/span&gt;
or how 
the microcode controls the rest of the processor here.
Instead, I&#39;ll look at how the 8086 decides what microcode to run, steps through the microcode, handles jumps and calls
inside the microcode, and physically stores the microcode.
It was a challenge to fit the microcode onto the chip with 1978 technology, so Intel used many optimization techniques to
reduce the size of the microcode.&lt;/p&gt;
&lt;p&gt;In brief,
the microcode in the 8086 consists of 512 micro-instructions, each 21 bits wide.
The microcode engine has a 13-bit register that steps through the microcode, along with a 13-bit subroutine register to store
the return address for microcode subroutine calls.
The microcode engine is assisted by two smaller ROMs: the &quot;Group Decode ROM&quot; to categorize machine instructions, and the &quot;Translation ROM&quot; to branch to microcode subroutines for address calculation and other roles.
Physically, the microcode is stored in a 128&amp;times;84 array. It has a special address decoder that optimizes the storage.
The microcode circuitry is visible in the die photo below.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-mc-overview/die-labeled.jpg&quot;&gt;&lt;img alt=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; class=&quot;hilite&quot; height=&quot;587&quot; src=&quot;https://static.righto.com/images/8086-mc-overview/die-labeled-w600.jpg&quot; title=&quot;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;What is microcode?&lt;/h2&gt;
&lt;p&gt;Machine instructions are generally considered the basic steps that a computer performs.
However, each instruction usually requires multiple operations inside the processor.
For instance, an ADD instruction may involve computing the memory address, accessing the value, moving the value to the Arithmetic-Logic Unit (ALU), computing the sum, and storing the result in a register.
One of the hardest parts of computer design is creating the control logic that signals the appropriate parts of the processor for each step of an instruction.
The straightforward approach is to build a circuit from flip-flops and gates that moves through the various steps and generates
the control signals.
However, this circuitry is complicated and error-prone.&lt;/p&gt;
&lt;p&gt;In 1951, Maurice Wilkes came up with the idea of microcode: instead of building the control circuitry from complex logic gates, the control logic could be replaced with another layer of code (i. e. microcode) stored in a special memory called a control store.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.
In other words, microcode forms another layer between the machine instructions and the hardware.
The main advantage of microcode is that it turns the processor&#39;s control logic into a programming task instead of a difficult logic design task.
Microcode also permits complex instructions and a large instruction set to be implemented without making the processor more
complex (apart from the size of the microcode).
Finally, it is generally easier to fix a bug in microcode than in circuit logic.&lt;/p&gt;
&lt;p&gt;Early computers didn&#39;t use microcode, largely due to the lack of good storage technologies to hold the microcode.
This changed in the 1960s; for example
IBM made extensive use of microcode in the System/360 (1964). (I&#39;ve written about that &lt;a href=&quot;https://www.righto.com/2022/01/ibm360model50.html&quot;&gt;here&lt;/a&gt;.)
But early microprocessors didn&#39;t use microcode, returning to hard-coded control logic with logic gates.&lt;span id=&quot;fnref:pla&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:pla&quot;&gt;3&lt;/a&gt;&lt;/span&gt;
This logic was generally more compact and ran faster than microcode, since the circuitry could be optimized.
Since space was at a premium in early microprocessors and the instruction sets were relatively simple, this tradeoff made sense.
But as microprocessor instruction sets became complex and transistors became cheaper, microcode became appealing.
This led to the use of microcode in the Intel 8086 (1978) and 8088 (1979) and Motorola 68000 (1979), for instance.&lt;span id=&quot;fnref:z8000&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:z8000&quot;&gt;2&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;The 8086&#39;s microcode&lt;/h2&gt;
&lt;p&gt;The 8086&#39;s microcode is much simpler than in most processors, but it&#39;s still fairly complex.
The code below is the microcode routine from the 8086 for a routine called &quot;CORD&quot;, part of integer division, consisting of 16 micro-instructions.
I&#39;m not going to explain how this microcode works in detail, but I want to give a flavor of it.
Each line has an address on the left (blue) and the micro-instruction on the right (yellow), specifying the low-level actions during one time step (i.e. clock cycle).
Each micro-instruction performs a move, transferring data from a source register (S) to a destination register (D).
(The source &amp;Sigma; indicates the ALU output.)
For parallelism, the micro-instruction performs an operation or two at the same time as the move.
This operation is specified by the &quot;a&quot; and &quot;b&quot; fields; their meanings depend on the type field.
For instance, type 1 indicates an ALU instruction such as subtract (SUBT) or left-rotate through carry (LRCY).
Type 4 selects two general operations such as &quot;RTN&quot; which returns from a microcode subroutine.
Type 0 indicates a jump operation; &quot;UNC 10&quot; is an unconditional jump to line 10 while &quot;CY 13&quot; jumps to line 13 if the carry flag is set.
Finally, the &quot;F&quot; field
indicates if the condition code flags should be updated.
The key points are that the micro-instructions are simple and execute in one clock cycle, they can perform multiple operations
in parallel to maximize performance, and they include control-flow operations such as conditional jumps and subroutines.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-mc-overview/mc-example.jpg&quot;&gt;&lt;img alt=&quot;An example of a microcode routine. The CORD routine implements integer division with subtracts and left rotates. This is from patent 4,449,184.&quot; class=&quot;hilite&quot; height=&quot;264&quot; src=&quot;https://static.righto.com/images/8086-mc-overview/mc-example-w600.jpg&quot; title=&quot;An example of a microcode routine. The CORD routine implements integer division with subtracts and left rotates. This is from patent 4,449,184.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;An example of a microcode routine. The CORD routine implements integer division with subtracts and left rotates. This is from &lt;a href=&quot;https://patents.google.com/patent/US4449184A&quot;&gt;patent 4,449,184&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Each instruction is stored at a 13-bit address (blue) which consists of 9 bits shown explicitly and a 4-bit sequence counter &quot;CR&quot;.
The eight numbered address bits usually correspond to the machine instruction&#39;s opcode.
The &quot;X&quot; bit is an extra bit
to provide more address space for code that is not directly tied to a machine instruction, such as reset and interrupt code, address computation,
and the multiply/divide algorithms.&lt;/p&gt;
&lt;p&gt;A micro-instruction is encoded into 21 bits as shown below.
Every micro-instruction contains a move from a source register to a destination register, each specified with 5 bits.
The meaning of the remaining bits is a bit tricky since it depends on the type field, which is two or three bits long.
The &quot;short jump&quot; (type 0) is a conditional jump within the current block of 16 micro-instructions.
The ALU operation (type 1) sets up the arithmetic-logic unit to perform an operation.
Bookkeeping operations (type 4) are anything from flushing the prefetch queue to ending the current instruction.
A memory read or write is type 6.
A &quot;long jump&quot; (type 5) is a conditional jump to any of 16 fixed microcode locations (specified in an external table).
Finally, a &quot;long call&quot; (type 7) is a conditional subroutine call to one of 16 locations (different from the jump targets).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-mc-overview/microcode-format.jpg&quot;&gt;&lt;img alt=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; class=&quot;hilite&quot; height=&quot;203&quot; src=&quot;https://static.righto.com/images/8086-mc-overview/microcode-format-w700.jpg&quot; title=&quot;The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The encoding of a micro-instruction into 21 bits. Based on &lt;a href=&quot;https://digitalcommons.law.scu.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=1031&amp;context=chtlj&quot;&gt;NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;This &quot;vertical&quot; microcode format reduces the storage required for the microcode by encoding control signals into various fields.
However, it requires some decoding logic to process the fields and generate the low-level control signals.
Surprisingly, there&#39;s no specific &quot;microcode decoder&quot; circuit. Instead, the logic is scattered across the chip, looking for various
microcode bit patterns to generate control signals where they are needed.&lt;/p&gt;
&lt;!--
As you can see, the microcode can perform loops, subroutine calls, and conditional branches, so it is more powerful than you might expect.
The microcode also permits a data move to take place in parallel with something else.
The format of the microcode limits the parallelism, however. For instance, it can&#39;t do an ALU computation, an address computation,
and a bookkeeping operation in parallel, even though the hardware could support that.
This illustrates the tradeoff between &quot;horizontal&quot; and &quot;vertical&quot; microcode. A very wide micro-instruction gives control over everything in parallel, while a narrow &quot;vertical&quot; micro-instruction like the 8086 limits what can be specified in one instruction.

--&gt;
&lt;h2&gt;How instructions map onto the ROM&lt;/h2&gt;
&lt;p&gt;One interesting issue is how the micro-instructions are organized in the ROM, and how the right micro-instructions are
executed for a particular machine instruction.
The 8086 uses a clever mapping from the machine instruction to a microcode address that allows machine instructions to share
microcode.&lt;/p&gt;
&lt;p&gt;Different processors use a variety of approaches to microcode organization.
One technique is for each micro-instruction to contain a field with the address of the next micro-instruction.
This provides complete flexibility for the arrangement of micro-instructions, but requires a field to hold the address, increasing
the number of bits in each micro-instruction.
A common alternative is to execute micro-instructions sequentially, with a micro-program-counter stepping through each micro-address
unless there is an explicit jump to a new address.
This approach avoids the cost of an address field in each instruction, but requires a program counter with an incrementer, increasing the hardware complexity.&lt;/p&gt;
&lt;p&gt;The 8086 uses a hybrid approach. A 4-bit program counter steps through the bottom 4 bits of the address, so up to 16 micro-instructions can be executed in sequence without a jump.
This approach has the advantage of requiring a smaller 4-bit incrementer for the program counter, rather than a 13-bit incrementer.
The microcode engine provides a &quot;short jump&quot; operation that makes it easy to jump within the group of 16 instructions using
a 4-bit jump target, rather than a full 13-bit address.&lt;/p&gt;
&lt;p&gt;Another important design decision in microcode is how to determine the starting micro-address for each machine instruction.
In other words, if you want to do an ADD, where does the microcode for ADD start?
One approach is a table of starting addresses: the system looks in the table to find the starting address for ADD,
but this requires a large table of 256 entries.
A second approach is to use the opcode code value as the starting address. That is, an ADD instruction 0x05 would start at micro-address
5.
This approach has two problems. First, you can&#39;t run the microcode sequentially since consecutive micro-instructions belong to
different machine instructions.
Moreover, you can&#39;t share microcode since each instruction has a different address in the microcode ROM.&lt;/p&gt;
&lt;p&gt;The 8086 solves these problems in two ways. First, the machine instructions are spaced sixteen slots apart in the microcode.
In other words, the opcode
is multiplied by 16 (has four zeros appended) to form the starting address in the microcode ROM, so there is plenty of space to
implement each machine instruction.
The second technique is that the ROM&#39;s addressing is partially decoded rather than fully decoded, so multiple micro-addresses can correspond to the same physical storage.&lt;span id=&quot;fnref:rom-decoding&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:rom-decoding&quot;&gt;4&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;To make this concrete, consider the 8086&#39;s arithmetic-logic instructions: one-byte add register to memory, one-byte
add memory to register, one-word subtract memory from register, one-word xor register to memory, and so forth.
There are 8 ALU operations and each can be byte- or word-sized, with memory as source or destination.
This yields 32 different machine opcodes.
These opcodes were carefully assigned, so they all have the format 00xxx0xx.
The ROM address decoder is designed to look for three 0 bits in those positions, and ignore the other bits, so it will match
that pattern.
The result is that all 32 of these ALU instructions activate the same ROM column select line, and thus they all share the same
microcode, shrinking the size of the ROM.&lt;/p&gt;
&lt;h2&gt;The microcode ROM&#39;s physical layout&lt;/h2&gt;
&lt;p&gt;The microcode ROM holds 512 words of 21 bits, so the obvious layout would be 512 columns and 21 rows.
However, these dimensions are not practical for physically building the ROM because
it would be too long and skinny.
Instead, the ROM is constructed by grouping four words in each column, resulting in 128 columns of 84 rows, much closer to square.
Not only does this make the physical layout more convenient, but it also reduces the number of column decoders from 512 to 128,
reducing the circuitry size.
Although the ROM now requires 21 multiplexers to select which of the four rows corresponds to each output bit, the circuitry is
still much smaller.
There is a tradeoff with the ability to merge addresses together by ignoring bits, though.
Each decoder now selects a column of four words, rather than a single word, so each block of four words must have
consecutive addresses.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-mc-overview/mc-die2.jpg&quot;&gt;&lt;img alt=&quot;The main components of the microcode engine. The metal layer has been removed to show the silicon and polysilicon underneath. If you zoom in, the bit pattern is visible in the silicon doping pattern.&quot; class=&quot;hilite&quot; height=&quot;564&quot; src=&quot;https://static.righto.com/images/8086-mc-overview/mc-die2-w600.jpg&quot; title=&quot;The main components of the microcode engine. The metal layer has been removed to show the silicon and polysilicon underneath. If you zoom in, the bit pattern is visible in the silicon doping pattern.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The main components of the microcode engine. The metal layer has been removed to show the silicon and polysilicon underneath. If you zoom in, the bit pattern is visible in the silicon doping pattern.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The image above shows how microcode is stored and accessed.
At the top is the 13-bit microcode address register, which will be discussed in detail below.
The column selection circuit decodes 11 of the 13 address bits to select one column of the microcode storage.
At the left, multiplexers select one bit out of each four rows using the two remaining address bits (specifically, the two lowest
sequence bits).
The selected 21 microcode outputs are latched and fed to the rest of the processor, where they are decoded as described earlier and control the processor&#39;s actions.&lt;/p&gt;
&lt;h2&gt;Optimizing the microcode&lt;/h2&gt;
&lt;p&gt;In 1978, the number of bits that could be stored in the microcode ROM was rather limited.
In particular, the 8086 holds only 512 micro-instructions. Since it has approximately 256 machine-code instructions in its one-byte opcode,
combined with multiple addressing modes, and each instruction requires multiple micro-instructions,
compression and optimization were necessary to make the microcode fit.&lt;span id=&quot;fnref:8087&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:8087&quot;&gt;5&lt;/a&gt;&lt;/span&gt;
The main idea was to move functionality out of the microcode and into discrete logic when it made sense.
I&#39;ll describe some of the ways they did this.&lt;/p&gt;
&lt;p&gt;The 8086 has an arithmetic-logic unit (ALU) that performs operations such as addition and subtraction, as well as logical
operations such as AND and XOR.
Consider the machine instruction ADD, implemented with a few micro-operations that compute the memory address, fetch data, perform the addition, and store the result.
The machine instructions for subtraction, AND, or XOR require identical steps, except that the ALU performs
a different operation.
In total, the 8086 has eight ALU-based operations that are identical except for the operation performed by the ALU.&lt;span id=&quot;fnref:aluops&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:aluops&quot;&gt;6&lt;/a&gt;&lt;/span&gt;
The 8086 uses a &quot;trick&quot; where these eight machine instructions share the same microcode.
Specifically, the microcode tells the ALU to perform a special operation XI, which indicates that the
ALU should look at the appropriate bits of the instruction and do the appropriate operation.&lt;span id=&quot;fnref:alu-control&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:alu-control&quot;&gt;7&lt;/a&gt;&lt;/span&gt;
This shrinks the microcode for these operations by a factor of eight, at the cost of requiring additional logic for the ALU.
In particular, the ALU control circuitry has a register to hold the relevant instruction bits, and a PLA to decode these
bits into low-level ALU control signals.&lt;/p&gt;
&lt;p&gt;Similarly, the 8086 has eight machine instructions to increment a specific register (out of a set of 8), and eight instructions to decrement a register.
All 16 instructions are handled by the same set of micro-instructions and
the ALU does the increment or decrement as appropriate. Moreover, the register control circuitry determines which register
is specified by the instruction, without involvement from the microcode.&lt;/p&gt;
&lt;p&gt;Another optimization is that the 8086 has many machine instructions in pairs: an 8-bit version and a 16-bit version.
One approach would be to have separate microcode for the two instructions, one to handle a single byte and one to handle two
bytes.
Instead, the machine instructions share microcode. The complexity is moved to the circuitry that moves data on the bus: it looks at
the low bit of the instruction to determine if it should process a byte or a word.
This cuts the microcode size in half for the many affected instructions.&lt;/p&gt;
&lt;p&gt;Finally, simple instructions that can take place in one cycle are implemented
with logic gates, rather than through microcode. For instance, the CLC (clear carry flag) instruction updates the flag directly.
Similarly, prefix instructions for segment selection,
instruction locking, or repetition are performed in logic. These instructions don&#39;t use any microcode at all, which will
be important later below.&lt;/p&gt;
&lt;p&gt;Using techniques such as these, about 75 different instruction types are
implemented in the microcode (instead of about 256), making the microcode much smaller.
The tradeoff is that the 8086 requires more logic circuitry, but the designers found the tradeoff to be worthwhile.&lt;/p&gt;
&lt;h2&gt;The ModR/M byte&lt;/h2&gt;
&lt;p&gt;There&#39;s another complication for 8086 microcode, however.
Most 8086 instructions have a second byte: the ModR/M byte, which controls the addressing mode for the instructions in a complex
way (shown below).
This byte gives 8086 instructions a lot of flexibility: you can use two registers, a register and a memory location, or a
register and an &quot;immediate&quot; value specified in the instruction.
The memory location can be specified by 8 index register combinations with a one-byte or two-byte displacement optionally added.
(This is useful for accessing data in an array or structure, for instance.)
Although these addressing modes are powerful, they pose a problem for the microcode.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-mc-overview/modrm.jpg&quot;&gt;&lt;img alt=&quot;A summary of the ModR/M byte, from MCS-86 Assembly Language Reference Guide.&quot; class=&quot;hilite&quot; height=&quot;555&quot; src=&quot;https://static.righto.com/images/8086-mc-overview/modrm-w500.jpg&quot; title=&quot;A summary of the ModR/M byte, from MCS-86 Assembly Language Reference Guide.&quot; width=&quot;500&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A summary of the ModR/M byte, from &lt;a href=&quot;http://bitsavers.org/components/intel/8086/9800749-1_MCS-86_Assembly_Language_Reference_Guide_Oct78.pdf&quot;&gt;MCS-86 Assembly Language Reference Guide&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;These different addressing modes need to be implemented in microcode, since different addressing modes require
different sequences of steps.
In other words, you can&#39;t use the previous trick of pushing the problem into logic gates.
And you clearly don&#39;t want a separate implementation of each instruction for each addressing mode since the size of the microcode
would multiply out of control.&lt;/p&gt;
&lt;p&gt;The solution is to use a subroutine (in microcode) to compute the memory address. Thus, instructions can share the microcode
for each addressing mode.
This adds a lot of complexity to the microcode engine, however, since it needs to store the micro-address for a micro-subroutine-call
so it can return to the right location.
To support this, the microcode engine has a register to hold this return address.
(Since it doesn&#39;t have a full stack, you can&#39;t perform nested subroutine calls, but this isn&#39;t a significant limitation.)&lt;/p&gt;
&lt;p&gt;The microcode ends up having about 10 subroutines for the different addressing modes, as well as four routines for the
different sizes of displacement.
(The 8 possibilities for source registers are handled in the register selection logic, rather than microcode.)
Thus, the microcode handles the 256 different addressing modes with about 14 short routines that add the appropriate address register(s) and the displacement to obtain the memory address.&lt;/p&gt;
&lt;p&gt;One more complication is that machine instructions can switch the source and destination specified by the
ModR/M byte, depending on the opcode. For example, one subtract instruction will subtract a memory location from a register, while a different subtract
instruction subtracts a register from a memory location.
The two variants are distinguished by bit 1 of the instruction, the &quot;direction&quot; bit.
These variants are handled by the control logic, so the microcode can ignore them.
Specifically, before the source and destination specifications go to the register control circuitry, a crossover circuit can swap them based
on the value of the direction bit.&lt;/p&gt;
&lt;h2&gt;The Translation ROM&lt;/h2&gt;
&lt;p&gt;As explained above, the starting address for a machine instruction is derived directly from the instruction&#39;s opcode.
However, the microcode engine needs a mechanism to provide the address for jump and call operations. In the 8086, this
address is hard-coded into the Translation ROM, which provides a 13-bit address.&lt;span id=&quot;fnref:bp&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:bp&quot;&gt;8&lt;/a&gt;&lt;/span&gt;
It holds ten destination addresses for jump operations and ten (different) addresses for call operations.&lt;/p&gt;
&lt;p&gt;A second role of the Translation ROM is to hold target addresses for each ModR/M addressing mode, pointing to the code to
compute the effective address.
As a complication, two of the jump table entries in the Translation ROM are implemented with conditional logic, depending on
whether or not the instruction&#39;s memory address calculation includes a displacement.
By wiring this condition into the Translation ROM, the microcode avoids the need to test this condition.&lt;/p&gt;
&lt;p&gt;The image below shows how the Translation ROM appears on the die.
It is implemented as a partially-decoded ROM with multiplexed inputs.&lt;span id=&quot;fnref:translation-pla&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:translation-pla&quot;&gt;9&lt;/a&gt;&lt;/span&gt;
The inputs are at the bottom left.
For a jump or call, the ROM uses 4 input bits from the microcode output, since the microcode selects the jump targets.
For an address computation, it takes 5 bits from the instruction&#39;s ModR/M byte, so the routine is selected by the instruction.
The ROM has additional input bits to select the mode (jump, call, or address) and for the conditional jumps.
The decoding logic (left half) activates a row in the right half, generating the output address.
This address exits at the bottom and is loaded into the micro-address register below the Translation ROM.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-mc-overview/translation-rom.jpg&quot;&gt;&lt;img alt=&quot;The Translation ROM holds addresses of routines in the microcode.&quot; class=&quot;hilite&quot; height=&quot;636&quot; src=&quot;https://static.righto.com/images/8086-mc-overview/translation-rom-w350.jpg&quot; title=&quot;The Translation ROM holds addresses of routines in the microcode.&quot; width=&quot;350&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The Translation ROM holds addresses of routines in the microcode.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;The Group Decode ROM&lt;/h2&gt;
&lt;p&gt;In the discussion above, I&#39;ve discussed how various categories of instructions are optimized.
For instance, many instructions have a bit that selects if they act on a byte or a word.
Many instructions have a bit to reverse the direction of the operation&#39;s memory and register accesses.
These features are implemented in logic rather than microcode.
Other instructions are implemented outside microcode entirely.
How does the 8086 determine which way to process an instruction?&lt;/p&gt;
&lt;p&gt;The Group Decode ROM takes an instruction opcode and generate 15 signals that indicate various categories
of instructions that are handled differently.&lt;span id=&quot;fnref:group-decode-rom&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:group-decode-rom&quot;&gt;10&lt;/a&gt;&lt;/span&gt;
The outputs from the Group Decode ROM are used by various logic circuits to determine how to handle the instruction.
Some cases affect the microcode, for instance calling a microcode addressing routine if the instruction has a ModR/M byte.
In other cases, these signals act &quot;downstream&quot; of the microcode, for example to determine if the operation should act
on a byte or a word.
Other signals cause the microcode to be bypassed completely.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-mc-overview/pla.jpg&quot;&gt;&lt;img alt=&quot;A closeup of the Group Decode ROM. The circuit uses two layers of NOR gates to generate the output signals from the opcode inputs. This image shows a composite of the metal, polysilicon, and silicon layers.&quot; class=&quot;hilite&quot; height=&quot;434&quot; src=&quot;https://static.righto.com/images/8086-mc-overview/pla-w450.jpg&quot; title=&quot;A closeup of the Group Decode ROM. The circuit uses two layers of NOR gates to generate the output signals from the opcode inputs. This image shows a composite of the metal, polysilicon, and silicon layers.&quot; width=&quot;450&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;A closeup of the Group Decode ROM. The circuit uses two layers of NOR gates to generate the output signals from the opcode inputs. This image shows a composite of the metal, polysilicon, and silicon layers.&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;Specially-encoded instructions&lt;/h2&gt;
&lt;p&gt;For most of the 8086 instructions, the first byte specifies the instruction.
However, the 8086 has a few instructions where the ModR/M byte completely changes the meaning of the first byte.
For instance, opcode 0xF6 (Grp 1 below) can be a TEST, NOT, NEG, MUL, IMUL, DIV, or IDIV instruction based on the value of the ModR/M byte.
Similarly, opcode 0xFE (Grp 2) indicates an INC, DEC, CALL, JMP, or PUSH instruction.&lt;span id=&quot;fnref:groups&quot;&gt;&lt;a class=&quot;ref&quot; href=&quot;#fn:groups&quot;&gt;11&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-mc-overview/opcodes-fx.jpg&quot;&gt;&lt;img alt=&quot;The 8086 instruction map for opcodes 0xF0 to 0xFF. Based on MCS-86 Assembly Language Reference Guide.&quot; class=&quot;hilite&quot; height=&quot;301&quot; src=&quot;https://static.righto.com/images/8086-mc-overview/opcodes-fx-w600.jpg&quot; title=&quot;The 8086 instruction map for opcodes 0xF0 to 0xFF. Based on MCS-86 Assembly Language Reference Guide.&quot; width=&quot;600&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;The 8086 instruction map for opcodes 0xF0 to 0xFF. Based on &lt;a href=&quot;http://bitsavers.org/components/intel/8086/9800749-1_MCS-86_Assembly_Language_Reference_Guide_Oct78.pdf&quot;&gt;MCS-86 Assembly Language Reference Guide&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;This encoding may seem a bit random, but there&#39;s a reason behind it.
Most instructions act on a source and a destination. But some, such as INC (increment) use the same register or memory location
for the source and the destination.
Others, such as CALL or JMP, only use one address.
Thus, the &quot;reg&quot; field in the ModR/M byte is redundant.
Since these bits would be otherwise &quot;wasted&quot;, they are used instead to specify different instructions.
(There are only 256 single-byte opcodes, so you want to make the best use of them.)&lt;/p&gt;
&lt;p&gt;The implementation of these instructions in microcode is interesting.
Since the instructions share the same first byte, the standard microcode mapping would put them at the same microcode address.
However, these instructions are treated specially, with the &quot;reg&quot; field from the ModR/M byte copied into the lower bits of the microcode address.
In effect, the instructions are treated as opcodes 0xF0 through 0xFF, so the different instruction variants execute at separate microcode addresses.
You might expect a collision with the opcodes that really have the values 0xF0 through 0xFF.
However, the 8086 opcodes were cleverly arranged so none of the other instructions in this range use microcode.
As you can see above, the other instructions are prefixes (LOCK, REP, REPZ), halt (HLT), or flag operations (CMC, CLC, STC, CLI, STI, CLD, STD),
all implemented outside microcode.
Thus, the range 0xF0-0xFF is freed up for the &quot;expanded&quot; instructions.&lt;/p&gt;
&lt;p&gt;The hardware implementation for this is not too complex.
The Group ROM produces an output for these special instructions.
This causes the microcode address register to load the appropriate bits from the ModR/M byte, causing the
appropriate microcode routine to be executed.&lt;/p&gt;
&lt;h2&gt;The microcode address register&lt;/h2&gt;
&lt;p&gt;The heart of the microcode engine is the microcode address register, which determines which microcode address to execute.
As described earlier, the microcode address is 13 bits, of which 8 bits generally correspond to the instruction opcode,
one bit is an extra &quot;X&quot; instruction bit, and 4 bits are sequentially incremented.
The diagram below shows how the circuitry for the bits is arranged.
The 9 instruction bits each have a nearly-identical circuit. The sequence bits have more circuitry and each one is different,
because the circuit to increment the address is different for each bit.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-mc-overview/mar.jpg&quot;&gt;&lt;img alt=&quot;Layout of the microcode address register. Each bit has a roughly vertical block of circuitry.&quot; class=&quot;hilite&quot; height=&quot;201&quot; src=&quot;https://static.righto.com/images/8086-mc-overview/mar-w700.jpg&quot; title=&quot;Layout of the microcode address register. Each bit has a roughly vertical block of circuitry.&quot; width=&quot;700&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Layout of the microcode address register. Each bit has a roughly vertical block of circuitry.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;The schematic below shows the circuitry for one bit in the microcode address register.
It has two flip-flops: one to hold the current address bit and one to hold the old address while performing a subroutine call.
A multiplexer (mux) selects the input to each flip-flop.
For instance, if the microcode is waiting for a memory access, the &quot;hold&quot; input to the multiplexer causes the current address to
loop around and get reloaded into the flip-flop.
For a subroutine call, the &quot;call&quot; input saves the current address in the subroutine flip-flop.
Conversely, when returning from a subroutine, the &quot;return&quot; input loads the old address from the subroutine flip-flop.
The address flip-flop also has inputs to load the instruction as the address, to load an address from the translation ROM, or
to load an interrupt microcode handler address.
The circuit sends the address bit (and inverted address bit) to the microcode ROM&#39;s address decoder.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://static.righto.com/images/8086-mc-overview/addr-reg.jpg&quot;&gt;&lt;img alt=&quot;Schematic of a typical bit in the microcode address register.&quot; class=&quot;hilite&quot; height=&quot;353&quot; src=&quot;https://static.righto.com/images/8086-mc-overview/addr-reg-w400.jpg&quot; title=&quot;Schematic of a typical bit in the microcode address register.&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;div class=&quot;cite&quot;&gt;Schematic of a typical bit in the microcode address register.&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Each bit has some special-case handling, so this schematic should be viewed as an illustration, not an accurate
wiring diagram.
In particular, the sequence bits also have inputs from the incrementer, so they can step to the next address.
The low-order bits have instruction inputs to handle the specially-encoded &quot;group&quot; instructions discussed in the previous section.&lt;/p&gt;
&lt;p&gt;The control signals for the multiplexers are generated from various sources. A circuit called the loader starts processing of
an instruction, synchronized to the prefetch queue and instruction fetch from memory.
The call and return operations are microcode instructions. The Group Decode ROM controls some of the inputs,
for instance to process a ModR/M byte.
Thus, there is a moderate amount of conditional logic that determines the microcode address and thus what microcode gets executed.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;This has been a lot of material, so thank you for sticking with it to the end.
I draw three conclusions from studying the microcode engine of the 8086.
First, the implementation of microcode is considerably more complex than the clean description of microcode that is presented in books.
A lot of functionality is implemented in logic outside of microcode, so it&#39;s not a &quot;pure&quot; microcode implementation.
Moreover, there are many optimizations and corner cases.
The microcode engine has two supporting ROMs: the Translation ROM and the Group Decode ROM.
Even the microcode address register has complications.&lt;/p&gt;
&lt;p&gt;Second, the need for all these optimizations shows how the 8086 was just on the edge of what was practical.
The designers clearly went to a lot of effort to get the microcode to fit in the space available.&lt;/p&gt;
&lt;p&gt;Finally, looking at the 8086 in detail shows how complex its instruction set is.
I knew in the abstract that it was much more convoluted than, say, an ARM chip.
But seeing all the special case circuitry on the die to handle the corner cases of the instruction set really
makes this clear.&lt;/p&gt;
&lt;p&gt;I plan to continue reverse-engineering the 8086 die so
follow me on Twitter &lt;a href=&quot;https://twitter.com/kenshirriff&quot;&gt;@kenshirriff&lt;/a&gt; or &lt;a href=&quot;http://www.righto.com/feeds/posts/default&quot;&gt;RSS&lt;/a&gt; for updates.
I&#39;ve also started experimenting with Mastodon recently as &lt;a href=&quot;https://oldbytes.space/@kenshirriff&quot;&gt;@kenshirriff@oldbytes.space&lt;/a&gt;.
If you&#39;re interested in the 8086, I wrote about the &lt;a href=&quot;http://www.righto.com/2020/06/a-look-at-die-of-8086-processor.html&quot;&gt;8086 die&lt;/a&gt;, its &lt;a href=&quot;https://www.righto.com/2020/06/die-shrink-how-intel-scaled-down-8086.html&quot;&gt;die shrink process&lt;/a&gt; and the &lt;a href=&quot;http://www.righto.com/2020/07/the-intel-8086-processors-registers.html&quot;&gt;8086 registers&lt;/a&gt; earlier.&lt;/p&gt;
&lt;h2&gt;Notes and references&lt;/h2&gt;
&lt;div class=&quot;footnote&quot;&gt;
&lt;ol&gt;
&lt;li id=&quot;fn:reenigne&quot;&gt;
&lt;p&gt;The 8086 microcode was disassembled (&lt;a href=&quot;https://www.reenigne.org/blog/8086-microcode-disassembled/&quot;&gt;link&lt;/a&gt;)
a couple of years ago by Andrew Jenner by extracting the bits from my die photos.
My post here is a bit different, looking at hardware that runs the microcode, rather than the contents of the microcode.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:reenigne&quot; title=&quot;Jump back to footnote 1 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:z8000&quot;&gt;
&lt;p&gt;According to Wikipedia, the Zilog Z8000 (1979) didn&#39;t use microcode, which is a bit surprising for that timeframe.
This design decision had the advantage of reducing transistor count, but the disadvantage of hard-to-fix logic bugs in the instruction decoder.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:z8000&quot; title=&quot;Jump back to footnote 2 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:pla&quot;&gt;
&lt;p&gt;As an example of a non-microcoded processor, the MOS 6502 (1975) used a PLA (Programmable Logic Array) to perform much of the decoding (&lt;a href=&quot;https://www.pagetable.com/?p=39&quot;&gt;details&lt;/a&gt;).
A PLA provides a structured way of implementing logic gates in a relatively dense array.
A PLA is kind of like a ROM&amp;mdash;a PLA can implement a ROM and vice versa&amp;mdash;so it can be hard to see the difference.
The usual distinction is that only one row of a ROM is active at a time, the address that you&#39;re reading out.
A PLA is more general since multiple rows can be active at a time, combined to form the outputs.&lt;/p&gt;
&lt;p&gt;The Z80 had a slightly different implementation. It used a smaller PLA to perform basic decoding of instructions into various types. It then generated control
signals through a large amount of &quot;random&quot; logic (so-called because of its appearance, not because it&#39;s actually random).
This logic combined instruction types and timing signals to generate the appropriate control signals.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:pla&quot; title=&quot;Jump back to footnote 3 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:rom-decoding&quot;&gt;
&lt;p&gt;In a &quot;normal&quot; ROM, the address bits are decoded with logic gates so each unique address selects a different storage column in the ROM.
However, parts of the decoder circuitry can &quot;ignore&quot; bits so multiple addresses select the same storage column.
For a hypothetical example, suppose you&#39;re decoding 5-bit addresses. Instead of decoding 11010 and 11011 separately, you could
ignore the last bit so both addresses access the same ROM data. or you could ignore the last three bits so all 8 addresses
of the form 11xxx go to the same ROM location (where x indicates a bit that can be either 0 or 1).
This makes the ROM more like a PLA (Programmable Logic Array), but still accessing a single row at a time.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:rom-decoding&quot; title=&quot;Jump back to footnote 4 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:8087&quot;&gt;
&lt;p&gt;The Intel 8087 was the floating point co-processor for the 8086.
The 8087 required a lot of microcode, more than could fit in a standard ROM on the die.
To get the microcode to fit, Intel created a special ROM that stored two bits per transistor (instead of one)
by using four different sizes of transistors to generate four different voltages. Analog circuitry converted each
voltage level into two bits. This complex technique doubled the density (at least in theory), allowing the
microcode to fit on the chip.
I wrote about the 8087&#39;s non-binary ROM &lt;a href=&quot;https://www.righto.com/2018/09/two-bits-per-transistor-high-density.html&quot;&gt;here&lt;/a&gt;.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:8087&quot; title=&quot;Jump back to footnote 5 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:aluops&quot;&gt;
&lt;p&gt;The ALU operations that are grouped together are add, add with carry, subtract, subtract with borrow, logical AND, logical XOR, logical OR, and compare.
The compare operation may seem out of place in this list, but it is implemented as a subtract operation that updates the condition
flags without changing the value.
Operations such as increment, decrement, negation, and logical NOT may seem like they should be included, but since they operate on a single
argument instead of two, they are implemented differently at the microcode level. Increment and decrement are combined in the
microcode, however.
Negation and logical NOT could be combined except that negation affects the condition code flags, while NOT doesn&#39;t, so they need
separate microcode.
(This illustrates how subtle features of the instruction set can have more impact than you might expect.)
Since the ALU doesn&#39;t have hardware multiplication and division, the multiplication and division operations are implemented separately in microcode with loops.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:aluops&quot; title=&quot;Jump back to footnote 6 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:alu-control&quot;&gt;
&lt;p&gt;The ALU itself isn&#39;t examining instruction bits to decide what to do. There&#39;s some control circuitry next to the ALU that
uses a PLA (Programmable Logic Array) to examine the instruction bits and the microcode&#39;s ALU command to generate low-level
control signals for the ALU. These signals control things such as carry propagation, argument negation, and logical operation
selection to cause the ALU to perform the desired operation.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:alu-control&quot; title=&quot;Jump back to footnote 7 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:bp&quot;&gt;
&lt;p&gt;The Translation ROM has one additional output: a wire indicating an address mode that uses the BP register.
This output goes to the segment register selection circuitry and selects a different segment register.
The reason is that the 8086 uses the Data Segment by default for effective address computation, unless the address mode uses
BP as a base register. In that case, the Stack Segment is used.
This is an example of how the 8086 architecture is not orthogonal and has lots of corner cases.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:bp&quot; title=&quot;Jump back to footnote 8 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:translation-pla&quot;&gt;
&lt;p&gt;You can also view the Translation ROM as a PLA (Programmable Logic Array) constructed from two layers of NOR gates.
The conditional entries make it seem more like a PLA than a ROM.
Technically, it can be considered a ROM since a single row is active at a time.
I&#39;m using the name &quot;Translation ROM&quot; because that&#39;s what Intel calls it in the patents.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:translation-pla&quot; title=&quot;Jump back to footnote 9 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:group-decode-rom&quot;&gt;
&lt;p&gt;Although the Group Decode ROM is called a ROM in the patent, I&#39;d consider it more of a PLA (programmable logic array).
Conceptually it holds 256 words, one for each instruction.
But its implementation is an array of logic functions.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:group-decode-rom&quot; title=&quot;Jump back to footnote 10 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn:groups&quot;&gt;
&lt;p&gt;These instructions were called &quot;Group 1&quot; and &quot;Group 2&quot; instructions in the 8086 documentation.
Later Intel documentation renamed them as &quot;Unary Group 3&quot;, &quot;INC/DEC Group 4&quot; and &quot;Indirect Group 5&quot;.
Some details are &lt;a href=&quot;https://stackoverflow.com/questions/67567995/where-do-assembly-instruction-intel-group-categories-originate&quot;&gt;here&lt;/a&gt;.
The 8086 has two other groups of instructions where the reg field defines the instruction: the &quot;Immediate&quot; instructions 0x80-0x83 and
the &quot;Shift&quot; instructions 0xD0-0xD3.
For these opcodes, the different instructions were implemented by the ALU. As far as the microcode was concerned, these were
&quot;normal&quot; instructions so I won&#39;t discuss them in this post.&lt;/p&gt;
&lt;p&gt;I should mention that although the 8086 opcodes are always expressed in hexadecimal, the encoding makes &lt;em&gt;much&lt;/em&gt; more sense
if you look at it in octal. Details &lt;a href=&quot;https://gist.github.com/seanjensengrey/f971c20d05d4d0efc0781f2f3c0353da&quot;&gt;here&lt;/a&gt;.
The octal encoding also applies to other related chips including the 8008, 8080, and Z80.&amp;#160;&lt;a class=&quot;footnote-backref&quot; href=&quot;#fnref:groups&quot; title=&quot;Jump back to footnote 11 in the text&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.righto.com/feeds/3555662096871568632/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=6264947694886887540&amp;postID=3555662096871568632' title='17 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/3555662096871568632'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6264947694886887540/posts/default/3555662096871568632'/><link rel='alternate' type='text/html' href='http://www.righto.com/2022/11/how-8086-processors-microcode-engine.html' title='How the 8086 processor&#39;s microcode engine works'/><author><name>Ken Shirriff</name><uri>http://www.blogger.com/profile/08097301407311055124</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>17</thr:total></entry></feed>